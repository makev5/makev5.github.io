<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/p/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>IO流基本知识总结</title>
    <url>/p/42f7140.html</url>
    <content><![CDATA[<h2 id="Java-IO流学习总结"><a href="#Java-IO流学习总结" class="headerlink" title="Java IO流学习总结"></a>Java IO流学习总结</h2><h2 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h2><ul>
<li>根据处理数据类型的不同分为：<strong>字符流</strong>和<strong>字节流</strong></li>
<li>根据数据流向不同分为：<strong>输入流</strong>和<strong>输出流</strong></li>
</ul>
<h3 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h3><p>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 字节流和字符流的区别：</p>
<ul>
<li>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li>
<li>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</li>
</ul>
<p>结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。</p>
<h3 id="输入流和输出流"><a href="#输入流和输出流" class="headerlink" title="输入流和输出流"></a>输入流和输出流</h3><p>以程序本身考虑：</p>
<ul>
<li><p>读操作：使用输入流</p>
</li>
<li><p>写操作：使用输出流</p>
</li>
</ul>
<p>程序中需要根据待传输数据的不同特性而使用不同的流。</p>
<h2 id="Java-IO流对象"><a href="#Java-IO流对象" class="headerlink" title="Java IO流对象"></a>Java IO流对象</h2><h3 id="1-输入字节流InputStream"><a href="#1-输入字节流InputStream" class="headerlink" title="1. 输入字节流InputStream"></a><strong>1. 输入字节流InputStream</strong></h3><ul>
<li>InputStream：这个抽象类是表示字节输入流的所有类的超类</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次读一个</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;.\\fos.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read=fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一次读一个字节数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;.\\fos.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(bytes, <span class="number">0</span> , len));</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BufferedInputStream(InputStream in)：字节缓冲输入流</li>
</ul>
<h3 id="2-输出字节流OutputStream"><a href="#2-输出字节流OutputStream" class="headerlink" title="2.输出字节流OutputStream"></a><strong>2.输出字节流OutputStream</strong></h3><ul>
<li>OutputStream：这个抽象类是表示字节输出流的所有类的超类</li>
</ul>
<p>   字节流写数据的3种方式</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void write(int b)</td>
<td align="center">将指定的字节写入该输出流中</td>
</tr>
<tr>
<td align="center">void write(byte[] b)</td>
<td align="center">写 <code>b.length</code>字节从指定的字节数组的输出流</td>
</tr>
<tr>
<td align="center">void write(byte[] b, int off, int len)</td>
<td align="center">写 <code>len</code>字节指定字节数组中的偏移 <code>off</code>开始到输出流</td>
</tr>
</tbody></table>
<ul>
<li>BufferedOutputStream(OutputStream in)：字节缓冲输出流</li>
</ul>
<h3 id="3-字符输入流Reader"><a href="#3-字符输入流Reader" class="headerlink" title="3. 字符输入流Reader"></a><strong>3. 字符输入流Reader</strong></h3><ul>
<li><p>InputStreamReader：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">InputStreamReader(InputStream in)</td>
<td align="center">创建一个inputstreamreader使用默认字符集</td>
</tr>
<tr>
<td align="center">InputStreamReader(InputStream in, Charset cs)</td>
<td align="center">创建一个inputstreamreader使用给定的字符集</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;.\\osw.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch=isr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>) ch);</span><br><span class="line">&#125;</span><br><span class="line">isr.close();</span><br></pre></td></tr></table></figure></li>
<li><p>字符流读数据的2种方式</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int read()</td>
<td align="center">一次读一个字符数据</td>
</tr>
<tr>
<td align="center">int read(char[] cbuf)</td>
<td align="center">一次读一个字符数组数据</td>
</tr>
</tbody></table>
</li>
<li><p>FileReader：InputStreamReader的简化版，如果需要涉及字符编码，不适合</p>
</li>
<li><p>BufferedReader：字符缓冲输入流</p>
<ul>
<li>特有功能：public String readLine(): 读一行文字。结果包含行的内容的字符串，不包含任何行终止字符，如果流得结尾已经到达，则为null</li>
</ul>
</li>
</ul>
<h3 id="4-字符输出流Writer"><a href="#4-字符输出流Writer" class="headerlink" title="4. 字符输出流Writer"></a><strong>4. 字符输出流Writer</strong></h3><ul>
<li><p>OutputStreamWriter：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OutputStreamWriter(OutputStream out)</td>
<td align="center">创建一个outputstreamwriter使用默认的字符编码</td>
</tr>
<tr>
<td align="center">OutputStreamWriter(OutputStream out, Charset cs)</td>
<td align="center">创建一个outputstreamwriter使用给定的字符集</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;.\\osw.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">osw.write(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">osw.close();</span><br></pre></td></tr></table></figure></li>
<li><p>字符流写数据的5种方式</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void write(int c)</td>
<td align="center">写一个字符</td>
</tr>
<tr>
<td align="center">void write(char[] cbuf)</td>
<td align="center">写一个字符数组</td>
</tr>
<tr>
<td align="center">void write(char[] cbuf,  int off, int len)</td>
<td align="center">写一个字符的一部分</td>
</tr>
<tr>
<td align="center">void write(String str)</td>
<td align="center">写一个字符串</td>
</tr>
<tr>
<td align="center">void write(String str,  int off, int len)</td>
<td align="center">写一个字符串的一部分</td>
</tr>
</tbody></table>
</li>
<li><p>FileWriter：OutputStreamWriter的简化版，如果需要涉及字符编码，不适合。</p>
</li>
<li><p>BufferedWriter：字符缓冲输出流</p>
<ul>
<li><p>特有功能：void newLine():  写一行行分隔符，行分隔符字符串由系统属性定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//根据数据源创建字符缓冲输入流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;.\\1.java&quot;</span>));</span><br><span class="line">        <span class="comment">//根据目的地创建字符缓冲输出流对象</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;.\\copy.java&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读写数据，复制文件</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="5-File类"><a href="#5-File类" class="headerlink" title="5. File类"></a><strong>5. File类</strong></h3><h4 id="5-1-三个构造方法"><a href="#5-1-三个构造方法" class="headerlink" title="5.1 三个构造方法"></a><strong>5.1 三个构造方法</strong></h4><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">File(String pathname)</td>
<td align="center">通过将给定的路径名字符串转换为抽象路径名来创建新的File实例</td>
</tr>
<tr>
<td align="center">File(String parent, String child)</td>
<td align="center">从父路径名字符串和子路径名字符串创建新的File实例</td>
</tr>
<tr>
<td align="center">File(File parent, String child)</td>
<td align="center">从父抽象路径名和子路径名字符串创建新的File实例</td>
</tr>
</tbody></table>
<h4 id="5-2-File类创建功能"><a href="#5-2-File类创建功能" class="headerlink" title="5.2 File类创建功能"></a><strong>5.2 File类创建功能</strong></h4><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public boolean createNewFile()</td>
<td align="center">自动创建一个新的空文件命名的抽象路径名的当且仅当该文件不存在</td>
</tr>
<tr>
<td align="center">public boolean mkdir()</td>
<td align="center">创建该目录下的抽象路径名命名</td>
</tr>
<tr>
<td align="center">public boolean mkdirs()</td>
<td align="center">创建该目录下的抽象路径名命名，包括任何必要的但不存在父目录</td>
</tr>
</tbody></table>
<h4 id="5-3-File类的删除功能"><a href="#5-3-File类的删除功能" class="headerlink" title="5.3 File类的删除功能"></a><strong>5.3 File类的删除功能</strong></h4><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public boolean delete()</td>
<td align="center">删除由此抽象路径名表示的文件或目录</td>
</tr>
</tbody></table>
<p>删除目录时注意事项：</p>
<ul>
<li><p>如果一个目录中有内容（目录或文件），不能直接删除。应该先删除目录中的内容，最后才能删除目录</p>
<h4 id="5-4-File类判断和获取功能"><a href="#5-4-File类判断和获取功能" class="headerlink" title="5.4 File类判断和获取功能"></a><strong>5.4 File类判断和获取功能</strong></h4></li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public boolean isDirectory()</td>
<td align="center">测试文件是否通过这种抽象路径名表示是一个目录</td>
</tr>
<tr>
<td align="center">public boolean isFile()</td>
<td align="center">测试文件是否通过这种抽象路径名表示的是一种正常的文件</td>
</tr>
<tr>
<td align="center">public boolean exists()</td>
<td align="center">检查文件或目录是否存在这种抽象路径名</td>
</tr>
<tr>
<td align="center">public String getAbsolutePath()</td>
<td align="center">返回此抽象路径名的绝对路径名的字符串</td>
</tr>
<tr>
<td align="center">public String getPath()</td>
<td align="center">转换这个抽象路径名为路径名的字符串</td>
</tr>
<tr>
<td align="center">public String getName()</td>
<td align="center">返回的名称的文件或目录的路径名表示的抽象</td>
</tr>
<tr>
<td align="center">public String[] list()</td>
<td align="center">返回的字符串在该目录下的抽象路径名的文件和目录命名为数组</td>
</tr>
<tr>
<td align="center">public File[] listFiles()</td>
<td align="center">返回表示抽象路径名的目录中的文件的路径名表示抽象的数组</td>
</tr>
</tbody></table>
<h4 id="5-5-递归"><a href="#5-5-递归" class="headerlink" title="5.5 递归"></a><strong>5.5 递归</strong></h4><p>递归解决问题要找到两个内容：</p>
<ul>
<li>递归出口：否则会出现内存溢出</li>
<li>递归规则：与原问题相似的规模较小的问题</li>
</ul>
<h2 id="IO流小结"><a href="#IO流小结" class="headerlink" title="IO流小结"></a>IO流小结</h2><p><img src="http://image.xiaoke6.cn/image/blog2012031413373126.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程知识点总结</title>
    <url>/p/66e505b.html</url>
    <content><![CDATA[<h2 id="多线程知识总结"><a href="#多线程知识总结" class="headerlink" title="多线程知识总结"></a>多线程知识总结</h2><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>进程：是一个正在运行的程序</p>
<ul>
<li>是系统进行资源分配和调用的独立单位</li>
<li>每一个进程都有它自己的内存空间和系统资源</li>
</ul>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程：是进程中的单个顺序控制流，是一条执行的路径</p>
<ul>
<li>单线程：一个程序如果只有一条执行的路径，则成为单线程程序</li>
<li>多线程：一个程序如果有多条执行的路径，则成为多线程程序</li>
</ul>
<h2 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h2><h3 id="方式1：继承Thread类"><a href="#方式1：继承Thread类" class="headerlink" title="方式1：继承Thread类"></a>方式1：继承Thread类</h3><ul>
<li>定义一个类MyThread继承Thread类</li>
<li>在MyThread类中重写run()方法</li>
<li>创建MyThread类的对象</li>
<li>启动线程</li>
</ul>
<h3 id="方式2：实现Runnable接口"><a href="#方式2：实现Runnable接口" class="headerlink" title="方式2：实现Runnable接口"></a>方式2：实现Runnable接口</h3><ul>
<li>定义一个类MyRunnable实现Runnable接口</li>
<li>在MyRunnable类中重写run()方法</li>
<li>创建MyRunnable类的对象</li>
<li>创建Thread类的对象，把MyRunnable对象作为构造方法的参数</li>
<li>启动线程</li>
</ul>
<p>相比继承Thread类，实现Runnable接口的好处:</p>
<ul>
<li>避免了Java单继承的局限性</li>
<li>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</li>
</ul>
<p>线程两种调度模型：</p>
<ul>
<li><p>分时调度模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片</p>
</li>
<li><p>抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机一个，优先级高的线程获取的CPU时间片相对多一些</p>
<p>多线程程序的执行是有随机性的，因为谁抢到CPU使用权是不一定的。</p>
</li>
</ul>
<p>Thread类中设置和获取线程优先级的方法</p>
<ul>
<li><p>getPriority()：返回此线程的优先级</p>
</li>
<li><p>setPriority()：更改此线程的优先级</p>
<p>线程默认优先级是<strong>5</strong>；线程优先级的范围是：<strong>1-10</strong></p>
<p>线程优先级高仅仅表示获取的CPU时间片的几率高</p>
</li>
</ul>
<h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">static void sleep(long millis)</td>
<td align="center">使用当前正在执行的线程停留（暂停执行）指定的毫秒数</td>
</tr>
<tr>
<td align="center">void join()</td>
<td align="center">等待这个线程死亡</td>
</tr>
<tr>
<td align="center">void setDaemon(boolean on)</td>
<td align="center">将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出</td>
</tr>
</tbody></table>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xfnihao.cn%2Fupload%2F2020%2F4%2Fimage-3c19d0b1afc1478f8f9d4e8fd304265c.png&refer=http%3A%2F%2Fwww.xfnihao.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643890180&t=3d49254cf84beaacd778653a950edf46"></p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>同步代码块：锁多条语句操作共享数据，可以使用同步代码块实现</p>
<ul>
<li><p>格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>()&#123;</span><br><span class="line">	多条语句操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成1一把锁</p>
</li>
</ul>
<p>同步的好处和弊端：</p>
<ul>
<li>好处：解决了多线程的数据安全问题</li>
<li>弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很消耗资源的，无形中就会降低程序的运行效率</li>
</ul>
<p>同步方法：就是把synchronized关键字加到方法上</p>
<ul>
<li><p>格式</p>
<p>修饰符 synchronized 返回值类型 方法名(参数){ }</p>
</li>
</ul>
<p>同步方法的锁对象是什么呢？</p>
<ul>
<li>  <strong>this</strong></li>
</ul>
<p>同步静态方法：就是把synchronized关键字加到静态方法上</p>
<ul>
<li><p>格式：</p>
<p>修饰符 static synchronized 返回值类型 方法名(参数){ }</p>
</li>
</ul>
<p>同步静态方法的锁对象是什么呢？</p>
<ul>
<li><strong>类名.class</strong></li>
</ul>
<p>线程安全的类：StringBuffer、Vector、Hashtable</p>
<p>StringBuffer</p>
<ul>
<li><p>线程安全，可变的字符序列</p>
</li>
<li><p>从JDK 5开始，被StringBuilder替代。通常应该使用StringBuilder类，因为它支持所有相同的操作，但它的速度更快，因为它不进行同步</p>
</li>
</ul>
<p>Vector</p>
<ul>
<li>从java 2平台V1.2，该类改进了List接口，使其成为Java Collections  Framework成员。Vector是同步的。如果一个线程安全的实现是不需要的，建议使用ArrayList代替Vector</li>
</ul>
<p>Hashtable</p>
<ul>
<li><p>该类实现了一个哈希表，它将键映射到值。任何非null对象都可以用作键或者值</p>
</li>
<li><p>作为java 2平台V1.2，该类改进了Map接口，使其成为 Java Collections  Framework成员。Hashtable是同步的。如果一个线程安全的实现是不需要的，建议使用HashMap代替Hashtable</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合知识点总结</title>
    <url>/p/1dfa12bb.html</url>
    <content><![CDATA[<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="数组ArraryList"><a href="#数组ArraryList" class="headerlink" title="数组ArraryList"></a>数组ArraryList</h3><p>数组是一种<strong>查询修改快</strong>的模型（对比链表）  </p>
<h3 id="链表LinkedList"><a href="#链表LinkedList" class="headerlink" title="链表LinkedList"></a>链表LinkedList</h3><p>链表是一种<strong>增删快</strong>的模型（对比数组）</p>
<p>特有功能：addFist，addLast，getFirst，getLast，removeFirst，removeLast</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Set集合特点"><a href="#Set集合特点" class="headerlink" title="Set集合特点"></a>Set集合特点</h3><ul>
<li><p>不包含重复元素的集合</p>
</li>
<li><p>没有带索引的方法，不能用普通for循环遍历</p>
</li>
</ul>
<p>HashSet：对集合的迭代顺序不作任何保证</p>
<h3 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h3><p>哈希值：是JDK根据对象的<strong>地址</strong>或者<strong>字符串</strong>或者<strong>数字</strong>算出来的int类型的<strong>数值</strong></p>
<p>Object类中有一个方法可以获取对象的哈希值</p>
<ul>
<li>public int hashCode(): 返回对象的哈希值</li>
</ul>
<p>对象的哈希值特点</p>
<ul>
<li>同一个对象多次调用hashCode()返回的哈希值是相同的</li>
<li>默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同</li>
</ul>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet集合特点</p>
<ul>
<li>底层数据结构是哈希表</li>
<li>对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致</li>
<li>没有带索引的方法，所以不能使用普通的for循环遍历</li>
<li>由于是Set集合，所以是不包含重复元素的集合</li>
</ul>
<p>HashSet集合保证元素唯一性源码分析</p>
<p><img src="http://image.xiaoke6.cn/images/bloghash.png"></p>
<p>HashSet集合存储元素：</p>
<ul>
<li>要保证元素唯一性，需要重写<strong>hashCode()和equals()</strong></li>
</ul>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet集合特点</p>
<ul>
<li>哈希表和链表实现的Set接口，具有可预测的迭代次序</li>
<li>由链表保证元素有序，也就是说元素的存储和取出顺序是一致的</li>
<li>由哈希表保证元素唯一，也就是说没有重复的元素</li>
</ul>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet集合特点</p>
<ul>
<li><p>元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法</p>
<p>TreeSet(): 根据其元素的自然排序进行排序</p>
<p>TreeSet(Comparator comparator): 根据指定的比较器进行排序</p>
</li>
<li><p>没有带索引的方法，所以不能使用普通的for循环遍历</p>
</li>
<li><p>由于是Set集合，所以不包含重复元素的集合</p>
</li>
</ul>
<p>自然排序Comparable的使用</p>
<ul>
<li>用TreeSet集合存储自定义对象，无参构造方法使用的是<strong>自然排序</strong>对元素进行排序的</li>
<li>自然排序，就是让元素所属的类实现Comparable接口，重写comparaTo()方法</li>
<li>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return -1; //-1按照降序，1按照升序，0重复元素不添加</span></span><br><span class="line">        <span class="comment">// 按照年龄从小到大排序,年龄相同，按照姓名字母顺序排序</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="keyword">this</span>.age - s.age;</span><br><span class="line">        <span class="keyword">int</span> num2 = num==<span class="number">0</span>?<span class="keyword">this</span>.name.compareTo(s.name):num;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>比较器排序Comparator的使用</p>
<ul>
<li>用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的</li>
<li>比较器排序，就是让集合构造方法接受Comparator的实现类对象，重写compare(T o1, T o2)方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;Student&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按照年龄从小到大排序,年龄相同，按照姓名字母顺序排序</span></span><br><span class="line">        <span class="comment">//this.age - s.age</span></span><br><span class="line">        <span class="comment">//s1,s1</span></span><br><span class="line">        <span class="keyword">int</span> num = s1.getAge() - s2.getAge();</span><br><span class="line">        <span class="keyword">int</span> num2 = num==<span class="number">0</span>? s1.getName().compareTo(s2.getName()):num;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>




<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><strong>Map集合遍历</strong></p>
<p><strong>方法一：增强for循环中使用entry来遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：在for-each循环中遍历keys或values</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//遍历map中的键</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + key);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//遍历map中的值</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Value = &quot;</span> + value);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：使用Iterator遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> </span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line"> </span><br><span class="line">    Map.Entry&lt;Integer, Integer&gt; entry = entries.next();</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法四：通过键找值遍历（效率低）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line"> </span><br><span class="line">    Integer value = map.get(key);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + key + <span class="string">&quot;, Value = &quot;</span> + value);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>如果仅需要键(keys)或值(values)使用方法二。如果你使用的语言版本低于java 5，或是打算在遍历时删除entries，必须使用方法三。否则使用方法一(键值都要)</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法设计</title>
    <url>/p/a8930426.html</url>
    <content><![CDATA[<h3 id="P53习题"><a href="#P53习题" class="headerlink" title="P53习题"></a>P53习题</h3><p><strong>(1)将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两个链表</strong></p>
<p>  <strong>的存储空间，不另外占用其他的存储空间。表中不允许有重复的数据。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType  data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//下一个节点地址</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line">LinkList pa, pb, pc, q, r, t;</span><br><span class="line">LinkList La, Lb, Lc; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IintList</span> <span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	L = <span class="keyword">new</span> LNode;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span></span>&#123; <span class="comment">// 合并链表La和Lb，合并后的新表使用头指针Lc指向 </span></span><br><span class="line">	pa=La-&gt;next;</span><br><span class="line">	pb=Lb-&gt;next;<span class="comment">//pa和pb分别是链表La和Lb的工作指针，初始化为相应链表的第一个结点</span></span><br><span class="line">	</span><br><span class="line">	Lc = pc =La; <span class="comment">//用La的头结点作为Lc的头结点</span></span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line">	    <span class="keyword">if</span>(pa-&gt;data&lt;pb-&gt;data)&#123;</span><br><span class="line">	        pc-&gt;next=pa;</span><br><span class="line">	        pc=pa;</span><br><span class="line">	        pa=pa-&gt;next;</span><br><span class="line">	    &#125;	<span class="comment">//取较小者La中的元素，将pa链接在pc的后面，pa的指针后移</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pa-&gt;data&gt;pb-&gt;data)&#123;</span><br><span class="line">			pc-&gt;next=pb;</span><br><span class="line">	        pc=pb;</span><br><span class="line">	        pb=pb-&gt;next;</span><br><span class="line">		&#125;   <span class="comment">//取较小者Lb中的元素，将pb链接在pc的后面，pb的指针后移</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">	        pc-&gt;next = pa;</span><br><span class="line">			pc = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">			q = pb-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> pb;</span><br><span class="line">			pb = q;   </span><br><span class="line">		&#125;	<span class="comment">//相等时取La中的元素，删除Lb中的元素 </span></span><br><span class="line">	&#125;</span><br><span class="line">   pc-&gt;next = pa ? pa : pb;  </span><br><span class="line">   <span class="keyword">delete</span> Lb;          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, n;</span><br><span class="line">	<span class="built_in">IintList</span>(La); </span><br><span class="line">	<span class="built_in">IintList</span>(Lb);</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入La表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="comment">// 尾插法</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向La顺序表赋值：&quot;</span>);</span><br><span class="line">	r = La;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">		pa = <span class="keyword">new</span> LNode; </span><br><span class="line">		cin&gt;&gt;pa-&gt;data;</span><br><span class="line"></span><br><span class="line">		pa-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next = pa;</span><br><span class="line">        r = pa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;La的数据为: &quot;</span>);</span><br><span class="line">	<span class="comment">//链表遍历 </span></span><br><span class="line">	pa = La-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pa)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pa-&gt;data);</span><br><span class="line">		pa = pa-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n输入Lb表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="comment">// 尾插法</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向Lb顺序表赋值：&quot;</span>);</span><br><span class="line">	r = Lb;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;n; i++)&#123;</span><br><span class="line">		pb = <span class="keyword">new</span> LNode;  </span><br><span class="line">		cin&gt;&gt;pb-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pb;</span><br><span class="line">		r = pb;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Lb的数据为：&quot;</span>);</span><br><span class="line">	<span class="comment">//链表遍历</span></span><br><span class="line">	pb = Lb-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pb)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pb-&gt;data);</span><br><span class="line">		pb = pb-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">MergeList</span>(La, Lb, Lc);</span><br><span class="line">	<span class="comment">//链表遍历</span></span><br><span class="line">	t = La-&gt;next;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;合并后链表为：&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;data);</span><br><span class="line">		t = t-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)将两个非递减的有序链表合并为一个非递增的有序链表。要求结果链表仍使用原来两个链表的存储空间,不另外占用其他的存储空间。表中允许有重复的数据。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span>	<span class="comment">//下一个节点地址</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line">LinkList pa, pb, pc, q, r, t;</span><br><span class="line">LinkList La, Lb, Lc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IintList</span> <span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	L = <span class="keyword">new</span> LNode;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span></span>&#123; <span class="comment">//合并链表La和Lb，合并后的新表使用头指针Lc指向</span></span><br><span class="line">    pa=La-&gt;next;</span><br><span class="line">    pb=Lb-&gt;next; <span class="comment">//pa和pb分别是链表La和Lb的工作指针，初始化为相应链表的第一个结点</span></span><br><span class="line">    </span><br><span class="line">    Lc = pc =La; <span class="comment">//用La的头结点作为Lc的头结点</span></span><br><span class="line">    Lc-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(pa || pb)&#123;<span class="comment">//只要存在一个非空表，用q指向待摘取的元素 </span></span><br><span class="line">    	<span class="keyword">if</span>(!pa)&#123;</span><br><span class="line">    		q = pb;</span><br><span class="line">    		pb = pb-&gt;next;</span><br><span class="line">		&#125; <span class="comment">//La表为空，用q指向pb，pb指针后移</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!pb)&#123;</span><br><span class="line">			q = pb;</span><br><span class="line">			pa = pa-&gt;next; </span><br><span class="line">		&#125; <span class="comment">//Lb表为空，用q指向pa，pa指针后移</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pa-&gt;data&lt;=pb-&gt;data)&#123;</span><br><span class="line">			q = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">		&#125; <span class="comment">//取较小者（包括等于）La中的元素，用q指向pa，pa指针后移 </span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">	        q = pb;</span><br><span class="line">			pb = pb-&gt;next;</span><br><span class="line">		&#125; <span class="comment">//取较小者Lb中的元素，用q指向pb，pb指针后移 </span></span><br><span class="line">		q-&gt;next = Lc-&gt;next;</span><br><span class="line">		Lc-&gt;next = q; <span class="comment">//将q指向的结点插在Lc表的表头结点之后 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> Lb; <span class="comment">//释放Lb的头结点 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line">	<span class="built_in">IintList</span>(La); </span><br><span class="line">	<span class="built_in">IintList</span>(Lb);</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入La表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向La顺序表赋值：&quot;</span>);</span><br><span class="line">	<span class="comment">//尾插法 </span></span><br><span class="line">	r = La; </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">		pa = <span class="keyword">new</span> LNode; </span><br><span class="line">		cin&gt;&gt;pa-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pa-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pa;</span><br><span class="line">		r = pa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;La的数据为: &quot;</span>);</span><br><span class="line">	<span class="comment">//链表La遍历 </span></span><br><span class="line">	pa = La-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pa)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pa-&gt;data);</span><br><span class="line">		pa = pa-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n输入Lb表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向Lb顺序表赋值：&quot;</span>);</span><br><span class="line">	<span class="comment">//尾插法</span></span><br><span class="line">	r = Lb; </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;n; i++)&#123;</span><br><span class="line">		pb = <span class="keyword">new</span> LNode;  </span><br><span class="line">		cin&gt;&gt;pb-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pb;</span><br><span class="line">		r = pb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Lb的数据为：&quot;</span>);</span><br><span class="line">	<span class="comment">//链表Lb的遍历 </span></span><br><span class="line">	pb = Lb-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pb)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pb-&gt;data);</span><br><span class="line">		pb = pb-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">MergeList</span>(La, Lb, Lc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;合并后链表为：&quot;</span>);</span><br><span class="line">	<span class="comment">//链表遍历</span></span><br><span class="line">	t = La-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;data);</span><br><span class="line">		t = t-&gt;next;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(3)已知两个链表A和B分别表示两个集合，其元素递增排列。 请设计一个算法，用于求出A与B的交集，并存放在A链表中。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType  data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//下一个节点地址</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line">LinkList pa, pb, pc, u, r, t;</span><br><span class="line">LinkList La, Lb, Lc; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IintList</span> <span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	L = <span class="keyword">new</span> LNode;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mix</span><span class="params">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span></span>&#123;</span><br><span class="line">    pa = La-&gt;next;</span><br><span class="line">    pb = Lb-&gt;next;	<span class="comment">//pa和pb分别是链表La和Lb的工作指针，初始化为相应链表的第一个结点</span></span><br><span class="line">    </span><br><span class="line">    Lc = pc =La; <span class="comment">//用La的头结点作为Lc的头结点</span></span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(pa-&gt;data == pb-&gt;data)&#123;	<span class="comment">//交集并入结果表中 </span></span><br><span class="line">    		pc-&gt;next = pa;</span><br><span class="line">			pc = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">			u = pb;</span><br><span class="line">			pb = pb-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> u; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pa-&gt;data&lt;pb-&gt;data)&#123;</span><br><span class="line">			u = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> u;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			u = pb;</span><br><span class="line">			pb = pb-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> u;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(pa)&#123;</span><br><span class="line">		u = pa;</span><br><span class="line">		pa = pa-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> u;</span><br><span class="line">	&#125; <span class="comment">//释放结点空间 </span></span><br><span class="line">	<span class="keyword">while</span>(pb)&#123;</span><br><span class="line">		u = pb;</span><br><span class="line">		pb = pb-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> u;</span><br><span class="line">	&#125; <span class="comment">//释放结点空间 </span></span><br><span class="line">	pc-&gt;next = <span class="literal">NULL</span>; <span class="comment">//置链表尾标记 </span></span><br><span class="line">	<span class="keyword">delete</span> Lb; <span class="comment">//释放Lb的头结点 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, n;</span><br><span class="line">	<span class="built_in">IintList</span>(La); </span><br><span class="line">	<span class="built_in">IintList</span>(Lb);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入La表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向La顺序表赋值：&quot;</span>);</span><br><span class="line">	<span class="comment">//尾插法</span></span><br><span class="line">    r = La;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">		pa = <span class="keyword">new</span> LNode; </span><br><span class="line">		cin&gt;&gt;pa-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pa-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pa;</span><br><span class="line">		r = pa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;La的数据为: &quot;</span>);</span><br><span class="line">	<span class="comment">//链表La的遍历 </span></span><br><span class="line">	pa = La-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pa)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,pa-&gt;data);</span><br><span class="line">		pa = pa-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n输入Lb表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向Lb顺序表赋值：&quot;</span>);</span><br><span class="line">	<span class="comment">//尾插法 </span></span><br><span class="line">	r = Lb;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;n; i++)&#123;</span><br><span class="line">		pb = <span class="keyword">new</span> LNode;  </span><br><span class="line">		cin&gt;&gt;pb-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pb;</span><br><span class="line">		r = pb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Lb的数据为：&quot;</span>);</span><br><span class="line">	<span class="comment">//链表Lb的遍历 </span></span><br><span class="line">	pb = Lb-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pb)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pb-&gt;data);</span><br><span class="line">		pb = pb-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Mix</span>(La,Lb,Lc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n合并后链表为：&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	t = La-&gt;next;	</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;data);</span><br><span class="line">		t = t-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="P85习题"><a href="#P85习题" class="headerlink" title="P85习题"></a>P85习题</h3><p><strong>(2)回文是指正读反读均相同的字符序列，如：“abba ”和 “abdba ” 均是回文，但“good ” 不是回文。<br>  试写一个算法判定给定的字符序列是否为回文。（提示：将一半字符入栈）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;String.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个栈 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *base;</span><br><span class="line">	<span class="keyword">char</span> *top;</span><br><span class="line">	<span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化栈 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">	S.base=<span class="keyword">new</span> <span class="keyword">char</span>[MAX];</span><br><span class="line">	<span class="keyword">if</span>(!S.base)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	S.top=S.base;</span><br><span class="line">	S.stacksize=MAX;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==S.base)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//栈空 </span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈非空 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断栈是否满</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top-S.base==S.stacksize)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//栈满 </span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈空 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,<span class="keyword">char</span> e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsFull</span>(S))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈满，无法入栈 </span></span><br><span class="line">	&#125;</span><br><span class="line">	*S.top++=e;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,<span class="keyword">char</span> &amp;e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsEmpty</span>(S))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈空，无法出栈 </span></span><br><span class="line">	&#125;</span><br><span class="line">	e=*--S.top;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsHuiWen2</span><span class="params">(SqStack &amp;S,<span class="keyword">char</span> str[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">int</span> m=len/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="built_in">Push</span>(S,str[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(S))&#123;</span><br><span class="line">			<span class="keyword">char</span> e;</span><br><span class="line">			<span class="built_in">Pop</span>(S,e);</span><br><span class="line">			temp=e;</span><br><span class="line">			<span class="keyword">if</span>(temp!=str[i])&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(len%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">		i=i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(S))&#123;</span><br><span class="line">			<span class="keyword">char</span> e;</span><br><span class="line">			<span class="built_in">Pop</span>(S,e);</span><br><span class="line">			temp=e;</span><br><span class="line">			<span class="keyword">if</span>(temp!=str[i])&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	SqStack S;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">InitStack</span>(S))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;初始化成功!\n&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;初始化失败!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入字符串:&quot;</span>);</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsHuiWen2</span>(S,str))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;是回文串!\n&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;不是回文串!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**(3)设从键盘输入一整数的序列：a1,a2,a3,…an,试编写算法实现：<br>   用栈结构存储输入的整数，当ai≠-1时，将ai进栈；当ai=-1时，输入栈顶整数并出栈。<br>   算法应对异常情况（入栈满等）给出相应的信息。 **</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TRUE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> FALSE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STACK_MAXSIZE = <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *base;</span><br><span class="line">    <span class="keyword">int</span> *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_Stack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base=<span class="keyword">new</span> <span class="keyword">int</span> [STACK_MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!S.base) <span class="keyword">return</span>;</span><br><span class="line">    S.top=S.base;</span><br><span class="line">    S.stacksize=STACK_MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Push_Stack</span><span class="params">(SqStack &amp;s, <span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.top - s.base == s.stacksize)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;\nerror:栈满&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		*s.top = e;</span><br><span class="line">		s.top ++;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">Pop_Stack</span><span class="params">(SqStack &amp;s, <span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.top == s.base)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;\n栈空，无法执行出栈操作&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		s.top--;</span><br><span class="line">		e = *s.top;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Page85.2.(3)</span></span><br><span class="line">	<span class="keyword">int</span> input_num, pop_num;</span><br><span class="line">	SqStack s;</span><br><span class="line"> </span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;\n输入整数序列：&quot;</span>;</span><br><span class="line">	<span class="built_in">Init_Stack</span>(s);</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;input_num;</span><br><span class="line">		<span class="keyword">if</span>(input_num == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">Pop_Stack</span>(s, pop_num))</span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;pop_num;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Push_Stack</span>(s, input_num);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(s.top - s.base &lt;= s.stacksize);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;PAUSE&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P109习题"><a href="#P109习题" class="headerlink" title="P109习题"></a>P109习题</h3><p><strong>(1)写一个算法统计在输入字符串中各个不同字符出现的频度并将结果存入文件（字符串中的合法字符串为A~Z这26个字母和0 ~ 9这10个数字)。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">charCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,digit_num[<span class="number">10</span>],cap_num[<span class="number">26</span>];</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">		digit_num[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">26</span>; j++)</span><br><span class="line">		cap_num[j]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((ch = <span class="built_in">getchar</span>())!= <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span>(ch)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>..<span class="number">.&#x27;</span>Z<span class="number">&#x27;</span>:</span><br><span class="line">				j=ch<span class="number">-65</span>;</span><br><span class="line">				cap_num[j]++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>..<span class="number">.&#x27;9&#x27;</span>:</span><br><span class="line">				i=ch<span class="number">-48</span>;</span><br><span class="line">				digit_num[i]++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请输入合法字符（A~Z或0~9）！&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fp = <span class="built_in">fopen</span>(<span class="string">&quot;charCount.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;数字 %d 的个数为 %d ;\n&quot;</span>,i,digit_num[i]);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fprintf</span>(fp,<span class="string">&quot;数字 %d 的个数为 %d ;\n&quot;</span>,i,digit_num[i]) ==<span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;ERROR:结果写入文件charCount.txt失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">26</span>; j++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;字母 %c 的个数为 %d ;\n&quot;</span>,j+<span class="number">65</span>,cap_num[j]);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fprintf</span>(fp,<span class="string">&quot;字母 %c 的个数为 %d ;\n&quot;</span>,j+<span class="number">65</span>,cap_num[j]) == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;ERROR:结果写入文件charCount.txt失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n已将字符频度统计结果写入文件charCount.txt\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入一字符串，以#号结束输入：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">charCount</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）写一个递归算法来实现字符串逆序存储，要求不另设串存储空间</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">(<span class="keyword">char</span> A[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//利用静态变量存储数组下标</span></span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">invert</span>(A);</span><br><span class="line">        A[i++]=ch;<span class="comment">//先存的放到后边</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> A[<span class="number">100</span>];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入一个字符串（以‘#’为结束标志，不包括‘#’）&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">invert</span>(A);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;逆置后为：&quot;</span>&lt;&lt;A;<span class="comment">//char型数组可以利用数组名直接输出，int型则会输出其首地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P147习题"><a href="#P147习题" class="headerlink" title="P147习题"></a>P147习题</h3><p><strong>（1）统计二叉树的叶结点个数。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历顺序建立二叉树为：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreatBiTree</span>(T);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;中序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;后序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PostOrderTraverse</span>(T);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;该二叉树叶子结点个数为：&quot;</span>&lt;&lt;<span class="built_in">LeafCount</span>(T)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序建立二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历:若结点不为空就输出，遍历左子树，然后遍历右子树；</span></span><br><span class="line"><span class="comment">//若为空就不输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历:若结点不为空就遍历左子树，输出根结点数据，再遍历右子树；</span></span><br><span class="line"><span class="comment">//为空就不输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历:若结点不为空就遍历左子树，然后遍历右子树，输出根结点数据；</span></span><br><span class="line"><span class="comment">//若为空就不输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//叶子结点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; T-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LeafCount</span>(T-&gt;lchild)+<span class="built_in">LeafCount</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)判断两棵树是否相等</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitBiTree</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEqual</span><span class="params">(BiTree T1,BiTree T2)</span></span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiTree T1,T2;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历顺序建立二叉树T1为：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreatBiTree</span>(T1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;T1先序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T1);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历顺序建立二叉树T2为：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreatBiTree</span>(T2);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;T2先序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T2);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsEqual</span>(T1,T2))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;T1和T2相等&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">IsEqual</span>(T1,T2))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;T1和T2不相等&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序建立二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span> &amp;&amp; ch!=<span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序遍历:若结点不为空就输出，遍历左子树，然后遍历右子树；</span></span><br><span class="line"><span class="comment">//         若为空就不输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两棵树是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEqual</span><span class="params">(BiTree T1,BiTree T2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((T1==<span class="literal">NULL</span>) &amp;&amp; (T1==<span class="literal">NULL</span>))&#123;<span class="comment">//根结点都为空相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((T1==<span class="literal">NULL</span>)!=(T1==<span class="literal">NULL</span>))&#123;<span class="comment">//根结点一个为空，</span></span><br><span class="line">                                    <span class="comment">//一个不为空不相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(T1-&gt;data!=T2-&gt;data)&#123;<span class="comment">//根结点数据不等就不相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结点不空有数据</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">IsEqual</span>(T1-&gt;lchild,T2-&gt;lchild)</span><br><span class="line">            &amp;&amp; <span class="built_in">IsEqual</span>(T1-&gt;rchild,T2-&gt;rchild));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(6)用按层次顺序遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义结点 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">ElemType</span>;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MAX];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序建立二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span> &amp;&amp; ch!=<span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化循环队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front = Q.rear=<span class="number">0</span>;<span class="comment">//队头和队尾相等即为空队列 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进队 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,BiTree bt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>) % MAX == Q.front)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队列满了无法入队&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear = (Q.rear+<span class="number">1</span>) % MAX;</span><br><span class="line">		Q.data[Q.rear] = bt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队 </span></span><br><span class="line"><span class="function">BiTree <span class="title">OutQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    BiTree bt;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队列空了无法出队&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.front = (Q.front+<span class="number">1</span>) % MAX;</span><br><span class="line">        bt = Q.data[Q.front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断空队 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EmptyQueue</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front==Q.rear);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次顺序遍历:先进先出符合队列，先让第一层结点入队，然后依次入队；</span></span><br><span class="line"><span class="comment">//依次出队就为层次顺序遍历</span></span><br><span class="line"><span class="comment">//度为1的结点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Level</span><span class="params">(BiTree bt)</span></span>&#123;</span><br><span class="line">	BiTree p;</span><br><span class="line">	SqQueue Q;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(bt)&#123;</span><br><span class="line">		<span class="built_in">InitQueue</span>(Q);</span><br><span class="line">		<span class="built_in">EnQueue</span>(Q, bt);</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">EmptyQueue</span>(Q))&#123;</span><br><span class="line">			p=<span class="built_in">OutQueue</span>(Q);</span><br><span class="line">			cout&lt;&lt;p-&gt;data;</span><br><span class="line">			<span class="keyword">if</span>((p-&gt;lchild &amp;&amp; !p-&gt;rchild) ||(!p-&gt;lchild &amp;&amp; p-&gt;rchild))&#123;</span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;lchild)&#123;</span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,p-&gt;lchild);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild)&#123;</span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,p-&gt;rchild);</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历顺序建立二叉树为：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreatBiTree</span>(T);</span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;层次遍历后,度为1的结点个数为：&quot;</span>&lt;&lt;<span class="built_in">Level</span>(T)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
