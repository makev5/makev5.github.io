<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IO流基本知识总结</title>
    <url>/p/42f7140.html</url>
    <content><![CDATA[<h2 id="Java-IO流学习总结"><a href="#Java-IO流学习总结" class="headerlink" title="Java IO流学习总结"></a>Java IO流学习总结</h2><h2 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h2><ul>
<li>根据处理数据类型的不同分为：<strong>字符流</strong>和<strong>字节流</strong></li>
<li>根据数据流向不同分为：<strong>输入流</strong>和<strong>输出流</strong></li>
</ul>
<h3 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h3><p>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 字节流和字符流的区别：</p>
<ul>
<li>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li>
<li>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</li>
</ul>
<p>结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。</p>
<h3 id="输入流和输出流"><a href="#输入流和输出流" class="headerlink" title="输入流和输出流"></a>输入流和输出流</h3><p>以程序本身考虑：</p>
<ul>
<li><p>读操作：使用输入流</p>
</li>
<li><p>写操作：使用输出流</p>
</li>
</ul>
<p>程序中需要根据待传输数据的不同特性而使用不同的流。</p>
<h2 id="Java-IO流对象"><a href="#Java-IO流对象" class="headerlink" title="Java IO流对象"></a>Java IO流对象</h2><h3 id="1-输入字节流InputStream"><a href="#1-输入字节流InputStream" class="headerlink" title="1. 输入字节流InputStream"></a><strong>1. 输入字节流InputStream</strong></h3><ul>
<li>InputStream：这个抽象类是表示字节输入流的所有类的超类</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次读一个</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;.\\fos.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read=fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一次读一个字节数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;.\\fos.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(bytes, <span class="number">0</span> , len));</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BufferedInputStream(InputStream in)：字节缓冲输入流</li>
</ul>
<h3 id="2-输出字节流OutputStream"><a href="#2-输出字节流OutputStream" class="headerlink" title="2.输出字节流OutputStream"></a><strong>2.输出字节流OutputStream</strong></h3><ul>
<li>OutputStream：这个抽象类是表示字节输出流的所有类的超类</li>
</ul>
<p>   字节流写数据的3种方式</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void write(int b)</td>
<td align="center">将指定的字节写入该输出流中</td>
</tr>
<tr>
<td align="center">void write(byte[] b)</td>
<td align="center">写 <code>b.length</code>字节从指定的字节数组的输出流</td>
</tr>
<tr>
<td align="center">void write(byte[] b, int off, int len)</td>
<td align="center">写 <code>len</code>字节指定字节数组中的偏移 <code>off</code>开始到输出流</td>
</tr>
</tbody></table>
<ul>
<li>BufferedOutputStream(OutputStream in)：字节缓冲输出流</li>
</ul>
<h3 id="3-字符输入流Reader"><a href="#3-字符输入流Reader" class="headerlink" title="3. 字符输入流Reader"></a><strong>3. 字符输入流Reader</strong></h3><ul>
<li><p>InputStreamReader：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">InputStreamReader(InputStream in)</td>
<td align="center">创建一个inputstreamreader使用默认字符集</td>
</tr>
<tr>
<td align="center">InputStreamReader(InputStream in, Charset cs)</td>
<td align="center">创建一个inputstreamreader使用给定的字符集</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;.\\osw.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch=isr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>) ch);</span><br><span class="line">&#125;</span><br><span class="line">isr.close();</span><br></pre></td></tr></table></figure></li>
<li><p>字符流读数据的2种方式</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int read()</td>
<td align="center">一次读一个字符数据</td>
</tr>
<tr>
<td align="center">int read(char[] cbuf)</td>
<td align="center">一次读一个字符数组数据</td>
</tr>
</tbody></table>
</li>
<li><p>FileReader：InputStreamReader的简化版，如果需要涉及字符编码，不适合</p>
</li>
<li><p>BufferedReader：字符缓冲输入流</p>
<ul>
<li>特有功能：public String readLine(): 读一行文字。结果包含行的内容的字符串，不包含任何行终止字符，如果流得结尾已经到达，则为null</li>
</ul>
</li>
</ul>
<h3 id="4-字符输出流Writer"><a href="#4-字符输出流Writer" class="headerlink" title="4. 字符输出流Writer"></a><strong>4. 字符输出流Writer</strong></h3><ul>
<li><p>OutputStreamWriter：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OutputStreamWriter(OutputStream out)</td>
<td align="center">创建一个outputstreamwriter使用默认的字符编码</td>
</tr>
<tr>
<td align="center">OutputStreamWriter(OutputStream out, Charset cs)</td>
<td align="center">创建一个outputstreamwriter使用给定的字符集</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;.\\osw.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">osw.write(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">osw.close();</span><br></pre></td></tr></table></figure></li>
<li><p>字符流写数据的5种方式</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void write(int c)</td>
<td align="center">写一个字符</td>
</tr>
<tr>
<td align="center">void write(char[] cbuf)</td>
<td align="center">写一个字符数组</td>
</tr>
<tr>
<td align="center">void write(char[] cbuf,  int off, int len)</td>
<td align="center">写一个字符的一部分</td>
</tr>
<tr>
<td align="center">void write(String str)</td>
<td align="center">写一个字符串</td>
</tr>
<tr>
<td align="center">void write(String str,  int off, int len)</td>
<td align="center">写一个字符串的一部分</td>
</tr>
</tbody></table>
</li>
<li><p>FileWriter：OutputStreamWriter的简化版，如果需要涉及字符编码，不适合。</p>
</li>
<li><p>BufferedWriter：字符缓冲输出流</p>
<ul>
<li><p>特有功能：void newLine():  写一行行分隔符，行分隔符字符串由系统属性定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//根据数据源创建字符缓冲输入流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;.\\1.java&quot;</span>));</span><br><span class="line">        <span class="comment">//根据目的地创建字符缓冲输出流对象</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;.\\copy.java&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读写数据，复制文件</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="5-File类"><a href="#5-File类" class="headerlink" title="5. File类"></a><strong>5. File类</strong></h3><h4 id="5-1-三个构造方法"><a href="#5-1-三个构造方法" class="headerlink" title="5.1 三个构造方法"></a><strong>5.1 三个构造方法</strong></h4><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">File(String pathname)</td>
<td align="center">通过将给定的路径名字符串转换为抽象路径名来创建新的File实例</td>
</tr>
<tr>
<td align="center">File(String parent, String child)</td>
<td align="center">从父路径名字符串和子路径名字符串创建新的File实例</td>
</tr>
<tr>
<td align="center">File(File parent, String child)</td>
<td align="center">从父抽象路径名和子路径名字符串创建新的File实例</td>
</tr>
</tbody></table>
<h4 id="5-2-File类创建功能"><a href="#5-2-File类创建功能" class="headerlink" title="5.2 File类创建功能"></a><strong>5.2 File类创建功能</strong></h4><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public boolean createNewFile()</td>
<td align="center">自动创建一个新的空文件命名的抽象路径名的当且仅当该文件不存在</td>
</tr>
<tr>
<td align="center">public boolean mkdir()</td>
<td align="center">创建该目录下的抽象路径名命名</td>
</tr>
<tr>
<td align="center">public boolean mkdirs()</td>
<td align="center">创建该目录下的抽象路径名命名，包括任何必要的但不存在父目录</td>
</tr>
</tbody></table>
<h4 id="5-3-File类的删除功能"><a href="#5-3-File类的删除功能" class="headerlink" title="5.3 File类的删除功能"></a><strong>5.3 File类的删除功能</strong></h4><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public boolean delete()</td>
<td align="center">删除由此抽象路径名表示的文件或目录</td>
</tr>
</tbody></table>
<p>删除目录时注意事项：</p>
<ul>
<li><p>如果一个目录中有内容（目录或文件），不能直接删除。应该先删除目录中的内容，最后才能删除目录</p>
<h4 id="5-4-File类判断和获取功能"><a href="#5-4-File类判断和获取功能" class="headerlink" title="5.4 File类判断和获取功能"></a><strong>5.4 File类判断和获取功能</strong></h4></li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public boolean isDirectory()</td>
<td align="center">测试文件是否通过这种抽象路径名表示是一个目录</td>
</tr>
<tr>
<td align="center">public boolean isFile()</td>
<td align="center">测试文件是否通过这种抽象路径名表示的是一种正常的文件</td>
</tr>
<tr>
<td align="center">public boolean exists()</td>
<td align="center">检查文件或目录是否存在这种抽象路径名</td>
</tr>
<tr>
<td align="center">public String getAbsolutePath()</td>
<td align="center">返回此抽象路径名的绝对路径名的字符串</td>
</tr>
<tr>
<td align="center">public String getPath()</td>
<td align="center">转换这个抽象路径名为路径名的字符串</td>
</tr>
<tr>
<td align="center">public String getName()</td>
<td align="center">返回的名称的文件或目录的路径名表示的抽象</td>
</tr>
<tr>
<td align="center">public String[] list()</td>
<td align="center">返回的字符串在该目录下的抽象路径名的文件和目录命名为数组</td>
</tr>
<tr>
<td align="center">public File[] listFiles()</td>
<td align="center">返回表示抽象路径名的目录中的文件的路径名表示抽象的数组</td>
</tr>
</tbody></table>
<h4 id="5-5-递归"><a href="#5-5-递归" class="headerlink" title="5.5 递归"></a><strong>5.5 递归</strong></h4><p>递归解决问题要找到两个内容：</p>
<ul>
<li>递归出口：否则会出现内存溢出</li>
<li>递归规则：与原问题相似的规模较小的问题</li>
</ul>
<h2 id="IO流小结"><a href="#IO流小结" class="headerlink" title="IO流小结"></a>IO流小结</h2><p><img src="http://image.xiaoke6.cn/image/blog2012031413373126.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/p/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java集合知识点总结</title>
    <url>/p/1dfa12bb.html</url>
    <content><![CDATA[<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="数组ArraryList"><a href="#数组ArraryList" class="headerlink" title="数组ArraryList"></a>数组ArraryList</h3><p>数组是一种<strong>查询修改快</strong>的模型（对比链表）  </p>
<h3 id="链表LinkedList"><a href="#链表LinkedList" class="headerlink" title="链表LinkedList"></a>链表LinkedList</h3><p>链表是一种<strong>增删快</strong>的模型（对比数组）</p>
<p>特有功能：addFist，addLast，getFirst，getLast，removeFirst，removeLast</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Set集合特点"><a href="#Set集合特点" class="headerlink" title="Set集合特点"></a>Set集合特点</h3><ul>
<li><p>不包含重复元素的集合</p>
</li>
<li><p>没有带索引的方法，不能用普通for循环遍历</p>
</li>
</ul>
<p>HashSet：对集合的迭代顺序不作任何保证</p>
<h3 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h3><p>哈希值：是JDK根据对象的<strong>地址</strong>或者<strong>字符串</strong>或者<strong>数字</strong>算出来的int类型的<strong>数值</strong></p>
<p>Object类中有一个方法可以获取对象的哈希值</p>
<ul>
<li>public int hashCode(): 返回对象的哈希值</li>
</ul>
<p>对象的哈希值特点</p>
<ul>
<li>同一个对象多次调用hashCode()返回的哈希值是相同的</li>
<li>默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同</li>
</ul>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet集合特点</p>
<ul>
<li>底层数据结构是哈希表</li>
<li>对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致</li>
<li>没有带索引的方法，所以不能使用普通的for循环遍历</li>
<li>由于是Set集合，所以是不包含重复元素的集合</li>
</ul>
<p>HashSet集合保证元素唯一性源码分析</p>
<p><img src="http://image.xiaoke6.cn/images/bloghash.png"></p>
<p>HashSet集合存储元素：</p>
<ul>
<li>要保证元素唯一性，需要重写<strong>hashCode()和equals()</strong></li>
</ul>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet集合特点</p>
<ul>
<li>哈希表和链表实现的Set接口，具有可预测的迭代次序</li>
<li>由链表保证元素有序，也就是说元素的存储和取出顺序是一致的</li>
<li>由哈希表保证元素唯一，也就是说没有重复的元素</li>
</ul>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet集合特点</p>
<ul>
<li><p>元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法</p>
<p>TreeSet(): 根据其元素的自然排序进行排序</p>
<p>TreeSet(Comparator comparator): 根据指定的比较器进行排序</p>
</li>
<li><p>没有带索引的方法，所以不能使用普通的for循环遍历</p>
</li>
<li><p>由于是Set集合，所以不包含重复元素的集合</p>
</li>
</ul>
<p>自然排序Comparable的使用</p>
<ul>
<li>用TreeSet集合存储自定义对象，无参构造方法使用的是<strong>自然排序</strong>对元素进行排序的</li>
<li>自然排序，就是让元素所属的类实现Comparable接口，重写comparaTo()方法</li>
<li>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return -1; //-1按照降序，1按照升序，0重复元素不添加</span></span><br><span class="line">        <span class="comment">// 按照年龄从小到大排序,年龄相同，按照姓名字母顺序排序</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="keyword">this</span>.age - s.age;</span><br><span class="line">        <span class="keyword">int</span> num2 = num==<span class="number">0</span>?<span class="keyword">this</span>.name.compareTo(s.name):num;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>比较器排序Comparator的使用</p>
<ul>
<li>用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的</li>
<li>比较器排序，就是让集合构造方法接受Comparator的实现类对象，重写compare(T o1, T o2)方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;Student&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按照年龄从小到大排序,年龄相同，按照姓名字母顺序排序</span></span><br><span class="line">        <span class="comment">//this.age - s.age</span></span><br><span class="line">        <span class="comment">//s1,s1</span></span><br><span class="line">        <span class="keyword">int</span> num = s1.getAge() - s2.getAge();</span><br><span class="line">        <span class="keyword">int</span> num2 = num==<span class="number">0</span>? s1.getName().compareTo(s2.getName()):num;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>




<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><strong>Map集合遍历</strong></p>
<p><strong>方法一：增强for循环中使用entry来遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：在for-each循环中遍历keys或values</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//遍历map中的键</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + key);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//遍历map中的值</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Value = &quot;</span> + value);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：使用Iterator遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> </span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line"> </span><br><span class="line">    Map.Entry&lt;Integer, Integer&gt; entry = entries.next();</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法四：通过键找值遍历（效率低）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line"> </span><br><span class="line">    Integer value = map.get(key);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + key + <span class="string">&quot;, Value = &quot;</span> + value);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>如果仅需要键(keys)或值(values)使用方法二。如果你使用的语言版本低于java 5，或是打算在遍历时删除entries，必须使用方法三。否则使用方法一(键值都要)</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title>Junit单元测试、反射、注解</title>
    <url>/p/abb177c7.html</url>
    <content><![CDATA[<h3 id="Junit单元测试："><a href="#Junit单元测试：" class="headerlink" title="Junit单元测试："></a>Junit单元测试：</h3><h4 id="测试分类："><a href="#测试分类：" class="headerlink" title="测试分类："></a>测试分类：</h4><ol>
<li><strong>黑盒测试：</strong>不需要写代码，给输入值，看程序是否能够输出期望的值。</li>
<li><strong>白盒测试：</strong>需要写代码的。关注程序具体的执行流程。</li>
</ol>
<h4 id="Junit使用：白盒测试"><a href="#Junit使用：白盒测试" class="headerlink" title="Junit使用：白盒测试"></a>Junit使用：白盒测试</h4><h5 id="1-定义一个测试类-测试用例"><a href="#1-定义一个测试类-测试用例" class="headerlink" title="1. 定义一个测试类(测试用例)"></a>1. 定义一个测试类(测试用例)</h5><ul>
<li>测试类名：被测试的类名Test        CalculatorTest</li>
<li>包名：xxx.xxx.xx.test                    com.make.test</li>
</ul>
<h5 id="2-定义测试方法：可以独立运行"><a href="#2-定义测试方法：可以独立运行" class="headerlink" title="2. 定义测试方法：可以独立运行"></a>2. 定义测试方法：可以独立运行</h5><ul>
<li>方法名：test测试的方法名        testAdd()  </li>
<li>返回值：void</li>
<li>参数列表：空参</li>
</ul>
<h5 id="3-给方法加-Test"><a href="#3-给方法加-Test" class="headerlink" title="3. 给方法加@Test"></a>3. 给方法加@Test</h5><h5 id="4-导入junit依赖环境"><a href="#4-导入junit依赖环境" class="headerlink" title="4. 导入junit依赖环境"></a>4. 导入junit依赖环境</h5><ul>
<li><p>判定结果：</p>
<ul>
<li><p>红色：失败</p>
</li>
<li><p>绿色：成功</p>
</li>
<li><p>一般我们会使用断言操作来处理结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Assert.assertEquals(期望的结果,运算的结果);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>补充：</p>
<ul>
<li>@Before: 修饰的方法会在测试方法之前被自动执行</li>
<li>@After:  修饰的方法会在测试方法执行之后自动被执行</li>
</ul>
</li>
</ul>
<h3 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h3><ul>
<li>框架：半成品软件。可以在框架的基础上进行软件开发，简化编码</li>
<li>反射：将类的各个组成部分封装为其他对象，这就是反射机制<ul>
<li>好处：<ol>
<li>可以在程序运行过程中，操作这些对象。</li>
<li>可以解耦，提高程序的可扩展性。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="Class对象功能："><a href="#Class对象功能：" class="headerlink" title="Class对象功能："></a>Class对象功能：</h4><ul>
<li><p>获取功能：</p>
<ol>
<li>获取成员变量们</li>
</ol>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Field[] getFields()</td>
<td align="center">获取所有public修饰的成员变量</td>
</tr>
<tr>
<td align="center">Field getField(String name)</td>
<td align="center">获取指定名称的public修饰的成员变量</td>
</tr>
<tr>
<td align="center">Field[] getDeclaredFields()</td>
<td align="center">获取所有的成员变量，不考虑修饰符</td>
</tr>
<tr>
<td align="center">Field getDeclaredField(String name)</td>
<td align="center">获取指定名称的成员变量，不考虑修饰符</td>
</tr>
</tbody></table>
<ol start="2">
<li>获取构造方法们</li>
</ol>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Constructor&lt;?&gt;[] getConstructors()</td>
<td align="center">获取所有public修饰的构造方法</td>
</tr>
<tr>
<td align="center">Constructor<T> getConstructor(类&lt;?&gt;… parameterTypes)</td>
<td align="center">获取指定名称的public修饰的构造方法</td>
</tr>
<tr>
<td align="center">Constructor<T> getDeclaredConstructor(类&lt;?&gt;… parameterTypes)</td>
<td align="center">获取所有的构造方法，不考虑修饰符</td>
</tr>
<tr>
<td align="center">Constructor&lt;?&gt;[] getDeclaredConstructors()</td>
<td align="center">获取指定名称的构造方法，不考虑修饰符</td>
</tr>
</tbody></table>
<ol start="3">
<li>获取成员方法们</li>
</ol>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Method[] getMethods()</td>
<td align="center">获取所有public修饰的成员方法</td>
</tr>
<tr>
<td align="center">Method getMethod(String name, 类&lt;?&gt;… parameterTypes)</td>
<td align="center">获取指定名称的public修饰的成员方法</td>
</tr>
<tr>
<td align="center">Method[] getDeclaredMethods()</td>
<td align="center">获取所有的成员方法，不考虑修饰符</td>
</tr>
<tr>
<td align="center">Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes)</td>
<td align="center">获取指定名称的成员方法，不考虑修饰符</td>
</tr>
</tbody></table>
<ol start="4">
<li>获取全类名    </li>
</ol>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String getName()</td>
<td align="center">获取方法名</td>
</tr>
</tbody></table>
</li>
<li><p>Field：成员变量</p>
<ul>
<li><p>操作：</p>
<ol>
<li><p>设置值</p>
<ul>
<li>void set(Object obj, Object value)  </li>
</ul>
</li>
<li><p>获取值</p>
<ul>
<li>get(Object obj) </li>
</ul>
</li>
<li><p>忽略访问权限修饰符的安全检查</p>
<ul>
<li><strong>setAccessible(true): 暴力反射</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Constructor:构造方法</p>
<ul>
<li>创建对象：<ul>
<li>T newInstance(Object… initargs)  </li>
<li>如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</li>
</ul>
</li>
</ul>
</li>
<li><p>Method：方法对象</p>
<ul>
<li><p>执行方法：</p>
<ul>
<li>Object invoke(Object obj, Object… args)  </li>
</ul>
</li>
<li><p>获取方法名称：</p>
<ul>
<li>String getName:获取方法名</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h3><ul>
<li><p>概念：说明程序的。给计算机看的</p>
</li>
<li><p>注释：用文字描述程序的。给程序员看的</p>
</li>
<li><p>定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p>
</li>
<li><p>概念描述：</p>
<ul>
<li>JDK1.5之后的新特性</li>
<li>说明程序的</li>
<li>使用注解：@注解名称</li>
</ul>
</li>
<li><p>作用分类：<br>  ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】<br>  ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】<br>  ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</p>
</li>
<li><p>JDK中预定义的一些注解</p>
<ul>
<li>@Override    ：检测被该注解标注的方法是否是继承自父类(接口)的</li>
<li>@Deprecated：该注解标注的内容，表示已过时</li>
<li>@SuppressWarnings：压制警告。一般传递参数all  @SuppressWarnings(“all”)</li>
</ul>
</li>
<li><p>自定义注解</p>
<ul>
<li><p>格式：<br>  元注解<br>  public @interface 注解名称{</p>
<pre><code>  属性列表;
</code></pre>
<p>  }</p>
</li>
<li><p>本质：注解本质上就是一个接口，该接口默认继承Annotation接口</p>
<ul>
<li>public interface MyAnno extends java.lang.annotation.Annotation {}</li>
</ul>
</li>
<li><p>属性：接口中的抽象方法</p>
<ul>
<li><p>要求：</p>
<ol>
<li><p>属性的返回值类型有下列取值</p>
<ul>
<li>基本数据类型</li>
<li>String</li>
<li>枚举</li>
<li>注解</li>
<li>以上类型的数组</li>
</ul>
</li>
<li><p>定义了属性，在使用时需要给属性赋值</p>
<ol>
<li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</li>
<li>如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</li>
<li>数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li><p>元注解：用于描述注解的注解</p>
<ul>
<li>@Target：描述注解能够作用的位置<ul>
<li>ElementType取值：<ul>
<li>TYPE：可以作用于类上</li>
<li>METHOD：可以作用于方法上</li>
<li>FIELD：可以作用于成员变量上</li>
</ul>
</li>
</ul>
</li>
<li>@Retention：描述注解被保留的阶段<ul>
<li>@Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</li>
</ul>
</li>
<li>@Documented：描述注解是否被抽取到api文档中</li>
<li>@Inherited：描述注解是否被子类继承</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>在程序使用(解析)注解：获取注解中定义的属性值</p>
<ol>
<li><p>获取注解定义的位置的对象  （Class，Method,Field）</p>
</li>
<li><p>获取指定的注解</p>
<ul>
<li>getAnnotation(Class)<br>//其实就是在内存中生成了一个该注解接口的子类实现对象</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProImpl</span> <span class="keyword">implements</span> <span class="title">Pro</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">className</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;cn.make.annotation.Demo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;show&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用注解中的抽象方法获取配置的属性值</p>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Junit</tag>
        <tag>反射</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程知识点总结</title>
    <url>/p/66e505b.html</url>
    <content><![CDATA[<h2 id="多线程知识总结"><a href="#多线程知识总结" class="headerlink" title="多线程知识总结"></a>多线程知识总结</h2><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>进程：是一个正在运行的程序</p>
<ul>
<li>是系统进行资源分配和调用的独立单位</li>
<li>每一个进程都有它自己的内存空间和系统资源</li>
</ul>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程：是进程中的单个顺序控制流，是一条执行的路径</p>
<ul>
<li>单线程：一个程序如果只有一条执行的路径，则成为单线程程序</li>
<li>多线程：一个程序如果有多条执行的路径，则成为多线程程序</li>
</ul>
<h2 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h2><h3 id="方式1：继承Thread类"><a href="#方式1：继承Thread类" class="headerlink" title="方式1：继承Thread类"></a>方式1：继承Thread类</h3><ul>
<li>定义一个类MyThread继承Thread类</li>
<li>在MyThread类中重写run()方法</li>
<li>创建MyThread类的对象</li>
<li>启动线程</li>
</ul>
<h3 id="方式2：实现Runnable接口"><a href="#方式2：实现Runnable接口" class="headerlink" title="方式2：实现Runnable接口"></a>方式2：实现Runnable接口</h3><ul>
<li>定义一个类MyRunnable实现Runnable接口</li>
<li>在MyRunnable类中重写run()方法</li>
<li>创建MyRunnable类的对象</li>
<li>创建Thread类的对象，把MyRunnable对象作为构造方法的参数</li>
<li>启动线程</li>
</ul>
<p>相比继承Thread类，实现Runnable接口的好处:</p>
<ul>
<li>避免了Java单继承的局限性</li>
<li>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</li>
</ul>
<p>线程两种调度模型：</p>
<ul>
<li><p>分时调度模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片</p>
</li>
<li><p>抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机一个，优先级高的线程获取的CPU时间片相对多一些</p>
<p>多线程程序的执行是有随机性的，因为谁抢到CPU使用权是不一定的。</p>
</li>
</ul>
<p>Thread类中设置和获取线程优先级的方法</p>
<ul>
<li><p>getPriority()：返回此线程的优先级</p>
</li>
<li><p>setPriority()：更改此线程的优先级</p>
<p>线程默认优先级是<strong>5</strong>；线程优先级的范围是：<strong>1-10</strong></p>
<p>线程优先级高仅仅表示获取的CPU时间片的几率高</p>
</li>
</ul>
<h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">static void sleep(long millis)</td>
<td align="center">使用当前正在执行的线程停留（暂停执行）指定的毫秒数</td>
</tr>
<tr>
<td align="center">void join()</td>
<td align="center">等待这个线程死亡</td>
</tr>
<tr>
<td align="center">void setDaemon(boolean on)</td>
<td align="center">将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出</td>
</tr>
</tbody></table>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xfnihao.cn%2Fupload%2F2020%2F4%2Fimage-3c19d0b1afc1478f8f9d4e8fd304265c.png&refer=http%3A%2F%2Fwww.xfnihao.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643890180&t=3d49254cf84beaacd778653a950edf46"></p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>同步代码块：锁多条语句操作共享数据，可以使用同步代码块实现</p>
<ul>
<li><p>格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>()&#123;</span><br><span class="line">	多条语句操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成1一把锁</p>
</li>
</ul>
<p>同步的好处和弊端：</p>
<ul>
<li>好处：解决了多线程的数据安全问题</li>
<li>弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很消耗资源的，无形中就会降低程序的运行效率</li>
</ul>
<p>同步方法：就是把synchronized关键字加到方法上</p>
<ul>
<li><p>格式</p>
<p>修饰符 synchronized 返回值类型 方法名(参数){ }</p>
</li>
</ul>
<p>同步方法的锁对象是什么呢？</p>
<ul>
<li>  <strong>this</strong></li>
</ul>
<p>同步静态方法：就是把synchronized关键字加到静态方法上</p>
<ul>
<li><p>格式：</p>
<p>修饰符 static synchronized 返回值类型 方法名(参数){ }</p>
</li>
</ul>
<p>同步静态方法的锁对象是什么呢？</p>
<ul>
<li><strong>类名.class</strong></li>
</ul>
<p>线程安全的类：StringBuffer、Vector、Hashtable</p>
<p><strong>StringBuffer</strong></p>
<ul>
<li><p>线程安全，可变的字符序列</p>
</li>
<li><p>从JDK 5开始，被StringBuilder替代。通常应该使用StringBuilder类，因为它支持所有相同的操作，但它的速度更快，因为它不进行同步</p>
</li>
</ul>
<p><strong>Vector</strong></p>
<ul>
<li>从java 2平台V1.2，该类改进了List接口，使其成为Java Collections  Framework成员。Vector是同步的。如果一个线程安全的实现是不需要的，建议使用ArrayList代替Vector</li>
</ul>
<p><strong>Hashtable</strong></p>
<ul>
<li><p>该类实现了一个哈希表，它将键映射到值。任何非null对象都可以用作键或者值</p>
</li>
<li><p>作为java 2平台V1.2，该类改进了Map接口，使其成为 Java Collections  Framework成员。Hashtable是同步的。如果一个线程安全的实现是不需要的，建议使用HashMap代替Hashtable</p>
</li>
</ul>
<h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p>Lock中提供了获得锁和释放锁的方法</p>
<ul>
<li>void lock()：获得锁</li>
<li>void unlock()：释放锁</li>
</ul>
<p>Lock是接口不能直接实例化，这里采取它的实现类ReentrantLock来实例化</p>
<p>ReentrantLock的构造方法</p>
<ul>
<li>ReentrantLock()：创建一个ReentrantLock的实例</li>
</ul>
<h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2><p>为了体现生产和消费过程中的等待和唤醒，Java就提供了几个方法供我们使用，这几个方法在Object类中</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void wait()</td>
<td align="center">导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法</td>
</tr>
<tr>
<td align="center">void notify()</td>
<td align="center">唤醒正在等待对象监视器的单个线程</td>
</tr>
<tr>
<td align="center">void notifyAll()</td>
<td align="center">唤醒正在等待对象监视器的所有线程</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程基础知识</title>
    <url>/p/76d9b2bc.html</url>
    <content><![CDATA[<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h3 id="三要素：ip-端口-协议"><a href="#三要素：ip-端口-协议" class="headerlink" title="三要素：ip+端口+协议"></a>三要素：ip+端口+协议</h3><p><strong>IP地址</strong></p>
<ul>
<li>要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号，也就是设备的标识</li>
<li>InetAddress的使</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">static InetAddress getByName(String host)</td>
<td align="center">确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址</td>
</tr>
<tr>
<td align="center">String getHostName()</td>
<td align="center">获取此IP地址的主机名</td>
</tr>
<tr>
<td align="center">String getHostAddress()</td>
<td align="center">返回文本显示中的IP地址字符串</td>
</tr>
</tbody></table>
<p><strong>端口</strong></p>
<ul>
<li>网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序。那么在网络通信时，如何区分这些应用程序呢？如果IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识</li>
<li>端口号：取值范围0<del>65535。其中0</del>1023之间的端口号用于一些知名的网络服务和应用，普通程序需要使用1024以上的端口号</li>
</ul>
<p><strong>协议</strong></p>
<ul>
<li>  通过计算机网络可以使多台计算机实现连接，位于一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要1遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议。它对数据的传输格式、传输速率、传输步骤等做了统一的规定，通信双方必须同时遵守才能完成数据交换。常见的协议有<strong>UDP协议和TCP协议</strong></li>
</ul>
<h3 id="UDP发送数据"><a href="#UDP发送数据" class="headerlink" title="UDP发送数据"></a>UDP发送数据</h3><p>发送数据的步骤</p>
<ol>
<li>创建发送端的Socket对象（DatagramSocket）</li>
<li>创建数据，并把数据打包</li>
<li>调用DatagramSocket对象的方法发送数据</li>
<li>关闭发送端</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// DatagramSocket()构建一个数据报套接字绑定到本地主机的任何可用的端口。</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DatagramPacket(byte[] buf, int length, InetAddress address, int port)</span></span><br><span class="line">        <span class="comment">// 指定主机上的指定端口发送数据包的长度 length数据报包结构。</span></span><br><span class="line">        <span class="keyword">byte</span>[] bys=<span class="string">&quot;hello 我来了&quot;</span>.getBytes();</span><br><span class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bys, bys.length, InetAddress.getByName(<span class="string">&quot;192.168.31.15&quot;</span>), <span class="number">10086</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// send(DatagramPacket p) 从这个套接字发送数据报包。</span></span><br><span class="line">        socket.send(dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭发送端</span></span><br><span class="line">        <span class="comment">// close() 关闭该数据报套接字。</span></span><br><span class="line">        socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UDP接收数据"><a href="#UDP接收数据" class="headerlink" title="UDP接收数据"></a>UDP接收数据</h3><p>接收数据的步骤</p>
<ol>
<li>创建接收端的Socket对象（DatagramSocket）</li>
<li>创建一个数据包，用于接收数据</li>
<li>调用DatagramSocket对象的方法接收数据</li>
<li>解析数据包，并在控制台显示</li>
<li>关闭接收端</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建接收端的Socket对象（DatagramSocket）</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建一个数据包，用于接收数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bys, bys.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 调用DatagramSocket对象的方法接收数据</span></span><br><span class="line">        socket.receive(dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 解析数据包，并在控制台显示</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = dp.getData();</span><br><span class="line">        <span class="keyword">int</span> len = dp.getLength();</span><br><span class="line">        String dataString = <span class="keyword">new</span> String(data,<span class="number">0</span>,len);</span><br><span class="line">        System.out.print(<span class="string">&quot;数据是：&quot;</span> + dataString);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 关闭接收端</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="TCP发送数据"><a href="#TCP发送数据" class="headerlink" title="TCP发送数据"></a>TCP发送数据</h3><p>发送数据的步骤</p>
<ol>
<li>创建客户端的Socket对象（Socket）</li>
<li>获取输出流，写数据</li>
<li>释放资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建客户端的Socket对象（Socket）</span></span><br><span class="line">        <span class="comment">// Socket(InetAddress address, int port) 创建一个流套接字，并将其与指定的IP地址中的指定端口号连接起来。</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;192.168.31.15&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 2. 获取输出流，写数据</span></span><br><span class="line">        <span class="comment">// OutputStream getOutputStream() 返回此套接字的输出流。</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;hello,tcp,我来了&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="TCP接收数据"><a href="#TCP接收数据" class="headerlink" title="TCP接收数据"></a>TCP接收数据</h3><p>接收数据的步骤</p>
<ol>
<li>创建服务器的Socket对象（ServerSocket）</li>
<li>监听客户端连接，返回一个Socket对象</li>
<li>获取输入流，读数据，并在控制台显示</li>
<li>释放资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建服务器的Socket对象（ServerSocket）</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">10000</span>);</span><br><span class="line">    	<span class="comment">//2.监听客户端连接，返回一个Socket对象</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">//3. 获取输入流，读数据，并在控制台显示</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bys);</span><br><span class="line">        String data = <span class="keyword">new</span> String(bys, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(<span class="string">&quot;数据是：&quot;</span> + data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        serverSocket.close();</span><br><span class="line">        socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql基础知识总结</title>
    <url>/p/fb3a921a.html</url>
    <content><![CDATA[<h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><ol>
<li><p>数据库的英文单词： DataBase 简称 ： DB</p>
</li>
<li><p>什么数据库？</p>
<ul>
<li>用于存储和管理数据的仓库</li>
</ul>
</li>
<li><p>数据库的特点：</p>
<ul>
<li><p>持久化存储数据的。其实数据库就是一个文件系统</p>
</li>
<li><p>方便存储和管理数据</p>
</li>
<li><p>使用了统一的方式操作数据库  –  SQL</p>
</li>
</ul>
</li>
</ol>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h3><p>​        <strong>Structured Query Language：</strong>结构化查询语言</p>
<p>其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。</p>
<h3 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h3><ol>
<li>SQL 语句可以单行或多行书写，以分号结尾。</li>
<li>可使用空格和缩进来增强语句的可读性。</li>
<li>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</li>
<li>三种注释<ul>
<li>单行注释： – 注释内容 或 # 注释内容(mysql 特有)</li>
<li>多行注释：/* 注释 */</li>
</ul>
</li>
</ol>
<h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><ol>
<li>**DDL(Data Definition Language)**数据定义语言<pre><code> 用来定义数据库对象：数据库，表，列等。关键字：**create**, **drop**,**alter** 等
</code></pre>
</li>
<li>**DML(Data Manipulation Language)**数据操作语言<pre><code>用来对数据库中表的数据进行增删改。关键字：**insert**, **delete**, **update** 等
</code></pre>
</li>
<li>**DQL(Data Query Language)**数据查询语言<pre><code>用来查询数据库中表的记录(数据)。关键字：**select**, **where** 等
</code></pre>
</li>
<li>**DCL(Data Control Language)**数据控制语言(了解)<pre><code>用来定义数据库的访问权限和安全级别，及创建用户。关键字：**GRANT**， **REVOKE** 等
</code></pre>
</li>
</ol>
<h2 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h2><h3 id="操作数据库：CRUD"><a href="#操作数据库：CRUD" class="headerlink" title="操作数据库：CRUD"></a>操作数据库：CRUD</h3><h4 id="1-C-Create-：创建"><a href="#1-C-Create-：创建" class="headerlink" title="1. C(Create)：创建"></a>1. C(Create)：创建</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建数据库：</span></span><br><span class="line"><span class="keyword">create</span> database 数据库名称;</span><br><span class="line"><span class="comment">-- 创建数据库，判断不存在，再创建：</span></span><br><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> 数据库名称;</span><br><span class="line"><span class="comment">-- 创建数据库，并指定字符集</span></span><br><span class="line"><span class="keyword">create</span> database 数据库名称 <span class="type">character</span> <span class="keyword">set</span> 字符集名</span><br></pre></td></tr></table></figure>

<h4 id="2-R-Retrieve-：查询"><a href="#2-R-Retrieve-：查询" class="headerlink" title="2. R(Retrieve)：查询"></a>2. R(Retrieve)：查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有数据库的名称:</span></span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"><span class="comment">-- 查询某个数据库的字符集:查询某个数据库的创建语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> database 数据库名称;</span><br></pre></td></tr></table></figure>
<h4 id="3-U-Update-：修改"><a href="#3-U-Update-：修改" class="headerlink" title="3. U(Update)：修改"></a>3. U(Update)：修改</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 修改数据库的字符集</span></span><br><span class="line"><span class="keyword">alter</span> database 数据库名称 <span class="type">character</span> <span class="keyword">set</span> 字符集名称;</span><br></pre></td></tr></table></figure>
<h4 id="4-D-Delete-：删除"><a href="#4-D-Delete-：删除" class="headerlink" title="4. D(Delete)：删除"></a>4. D(Delete)：删除</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除数据库</span></span><br><span class="line"><span class="keyword">drop</span> database 数据库名称;</span><br><span class="line"><span class="comment">-- 判断数据库存在，存在再删除</span></span><br><span class="line"><span class="keyword">drop</span> database if <span class="keyword">exists</span> 数据库名称;</span><br></pre></td></tr></table></figure>
<h4 id="5-使用数据库"><a href="#5-使用数据库" class="headerlink" title="5. 使用数据库"></a>5. 使用数据库</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询当前正在使用的数据库名称</span></span><br><span class="line"><span class="keyword">select</span> database();</span><br><span class="line"><span class="comment">-- 使用数据库</span></span><br><span class="line">use 数据库名称;</span><br></pre></td></tr></table></figure>

<h3 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h3><h4 id="1-C-Create-：创建-1"><a href="#1-C-Create-：创建-1" class="headerlink" title="1.  C(Create)：创建"></a>1.  C(Create)：创建</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 语法：</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">	列名<span class="number">1</span> 数据类型<span class="number">1</span>,</span><br><span class="line">	列名<span class="number">2</span> 数据类型<span class="number">2</span>,</span><br><span class="line"> 	....</span><br><span class="line"> 	列名n 数据类型n</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 注意：最后一列，不需要加逗号（,）</span></span><br><span class="line"><span class="comment">-- 数据库类型：</span></span><br><span class="line"></span><br><span class="line">	<span class="number">1.</span> <span class="type">int</span>：整数类型</span><br><span class="line">			age <span class="type">int</span>,</span><br><span class="line">	<span class="number">2.</span> <span class="keyword">double</span>:小数类型</span><br><span class="line">			score <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line">	<span class="number">3.</span> <span class="type">date</span>:日期，只包含年月日，yyyy<span class="operator">-</span>MM<span class="operator">-</span>dd</span><br><span class="line">	<span class="number">4.</span> datetime:日期，包含年月日时分秒	 yyyy<span class="operator">-</span>MM<span class="operator">-</span>dd HH:mm:ss</span><br><span class="line">	<span class="number">5.</span> <span class="type">timestamp</span>:时间错类型	包含年月日时分秒	 yyyy<span class="operator">-</span>MM<span class="operator">-</span>dd HH:mm:ss	</span><br><span class="line">	如果将来不给这个字段赋值，或赋值为<span class="keyword">null</span>，则默认使用当前的系统时间，来自动赋值</span><br><span class="line">	<span class="number">6.</span> <span class="type">varchar</span>：字符串</span><br><span class="line">			name <span class="type">varchar</span>(<span class="number">20</span>):姓名最大<span class="number">20</span>个字符</span><br><span class="line">			zhangsan <span class="number">8</span>个字符  张三 <span class="number">2</span>个字符</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表:</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">32</span>),</span><br><span class="line">	age <span class="type">int</span> ,</span><br><span class="line">	score <span class="keyword">double</span>(<span class="number">4</span>,<span class="number">1</span>),</span><br><span class="line">	birthday <span class="type">date</span>,</span><br><span class="line">	insert_time <span class="type">timestamp</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 复制表：</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 <span class="keyword">like</span> 被复制的表名;  	</span><br></pre></td></tr></table></figure>

<h4 id="2-R-Retrieve-：查询-1"><a href="#2-R-Retrieve-：查询-1" class="headerlink" title="2. R(Retrieve)：查询"></a>2. R(Retrieve)：查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询某个数据库中所有的表名称</span></span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"><span class="comment">-- 查询表结构</span></span><br><span class="line"><span class="keyword">desc</span> 表名;</span><br></pre></td></tr></table></figure>
<h4 id="3-U-Update-：修改-1"><a href="#3-U-Update-：修改-1" class="headerlink" title="3. U(Update)：修改"></a>3. U(Update)：修改</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 修改表名</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 rename <span class="keyword">to</span> 新的表名;</span><br><span class="line"><span class="comment">-- 2. 修改表的字符集</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="type">character</span> <span class="keyword">set</span> 字符集名称;</span><br><span class="line"><span class="comment">-- 3. 添加一列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 数据类型;</span><br><span class="line"><span class="comment">-- 4. 修改列名称 类型</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 列名 新列别 新数据类型;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 列名 新数据类型;</span><br><span class="line"><span class="comment">-- 5. 删除列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 列名;</span><br></pre></td></tr></table></figure>
<h4 id="4-D-Delete-：删除-1"><a href="#4-D-Delete-：删除-1" class="headerlink" title="4. D(Delete)：删除"></a>4. D(Delete)：删除</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span>  if <span class="keyword">exists</span> 表名 ;</span><br></pre></td></tr></table></figure>

<h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><h4 id="1-添加数据："><a href="#1-添加数据：" class="headerlink" title="1. 添加数据："></a>1. 添加数据：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法：</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(列名<span class="number">1</span>,列名<span class="number">2</span>,...列名n) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...值n);</span><br><span class="line"><span class="comment">-- 注意：</span></span><br><span class="line">	<span class="number">1.</span> 列名和值要一一对应。</span><br><span class="line">	<span class="number">2.</span> 如果表名后，不定义列名，则默认给所有列添加值</span><br><span class="line">		<span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...值n);</span><br><span class="line">	<span class="number">3.</span> 除了数字类型，其他类型需要使用引号(单双都可以)引起来</span><br></pre></td></tr></table></figure>
<h4 id="2-删除数据："><a href="#2-删除数据：" class="headerlink" title="2. 删除数据："></a>2. 删除数据：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法：</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件]</span><br><span class="line"><span class="comment">-- 注意：</span></span><br><span class="line">	<span class="number">1.</span> 如果不加条件，则删除表中所有记录。</span><br><span class="line">	<span class="number">2.</span> 如果要删除所有记录</span><br><span class="line">		<span class="number">1.</span> <span class="keyword">delete</span> <span class="keyword">from</span> 表名; <span class="comment">-- 不推荐使用。有多少条记录就会执行多少次删除操作</span></span><br><span class="line">		<span class="number">2.</span> <span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名; <span class="comment">-- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。</span></span><br></pre></td></tr></table></figure>
<h4 id="3-修改数据："><a href="#3-修改数据：" class="headerlink" title="3. 修改数据："></a>3. 修改数据：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法：</span></span><br><span class="line">update 表名 <span class="keyword">set</span> 列名<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span>, 列名<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span>,... [<span class="keyword">where</span> 条件];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：</span></span><br><span class="line">	<span class="number">1.</span> 如果不加任何条件，则会将表中所有记录全部修改。</span><br></pre></td></tr></table></figure>

<h2 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h2><h3 id="1-语法格式"><a href="#1-语法格式" class="headerlink" title="1. 语法格式"></a>1. 语法格式</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 语法：</span></span><br><span class="line">	<span class="keyword">select</span></span><br><span class="line">		字段列表</span><br><span class="line">	<span class="keyword">from</span></span><br><span class="line">		表名列表</span><br><span class="line">	<span class="keyword">where</span></span><br><span class="line">		条件列表</span><br><span class="line">	<span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">		分组字段</span><br><span class="line">	<span class="keyword">having</span></span><br><span class="line">		分组之后的条件</span><br><span class="line">	<span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">		排序</span><br><span class="line">	limit</span><br><span class="line">		分页限定</span><br></pre></td></tr></table></figure>



<h3 id="2-基础查询"><a href="#2-基础查询" class="headerlink" title="2. 基础查询"></a>2. 基础查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 多个字段的查询</span></span><br><span class="line"><span class="keyword">select</span> 字段名<span class="number">1</span>，字段名<span class="number">2.</span>.. <span class="keyword">from</span> 表名；</span><br><span class="line"><span class="comment">-- 注意：如果查询所有字段，则可以使用*来替代字段列表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 去除重复：distinct</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 计算列</span></span><br><span class="line">	一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）</span><br><span class="line">	ifnull(表达式<span class="number">1</span>,表达式<span class="number">2</span>)：<span class="keyword">null</span>参与的运算，计算结果都为<span class="keyword">null</span></span><br><span class="line">		表达式<span class="number">1</span>：哪个字段需要判断是否为<span class="keyword">null</span></span><br><span class="line">		如果该字段为<span class="keyword">null</span>后的替换值。</span><br><span class="line"><span class="comment">-- 4. 起别名：</span></span><br><span class="line">	<span class="keyword">as</span>：<span class="keyword">as</span>也可以省略</span><br></pre></td></tr></table></figure>

<h3 id="3-条件查询"><a href="#3-条件查询" class="headerlink" title="3. 条件查询"></a>3. 条件查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. where子句后跟条件</span></span><br><span class="line"><span class="comment">-- 2. 运算符</span></span><br><span class="line">	<span class="operator">*</span> <span class="operator">&gt;</span> 、<span class="operator">&lt;</span> 、<span class="operator">&lt;=</span> 、<span class="operator">&gt;=</span> 、<span class="operator">=</span> 、<span class="operator">&lt;&gt;</span></span><br><span class="line">	<span class="operator">*</span> BETWEEN...AND  </span><br><span class="line">	<span class="operator">*</span> <span class="keyword">IN</span>( 集合) </span><br><span class="line">	<span class="operator">*</span> <span class="keyword">LIKE</span>：模糊查询</span><br><span class="line">		占位符：</span><br><span class="line">			_:单个任意字符</span><br><span class="line">			<span class="operator">%</span>:多个任意字符</span><br><span class="line">	<span class="operator">*</span> <span class="keyword">IS</span> <span class="keyword">NULL</span>  </span><br><span class="line">	<span class="operator">*</span> <span class="keyword">and</span> 或 <span class="operator">&amp;&amp;</span></span><br><span class="line">	<span class="operator">*</span> <span class="keyword">or</span>  或 <span class="operator">||</span> </span><br><span class="line">	<span class="operator">*</span> <span class="keyword">not</span> 或 <span class="operator">!</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">-- 查询年龄大于20岁</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询年龄等于20岁</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询年龄不等于20岁</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">!=</span> <span class="number">20</span>;</span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询年龄大于等于20 小于等于30</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="operator">&amp;&amp;</span>  age <span class="operator">&lt;=</span><span class="number">30</span>;</span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="keyword">AND</span>  age <span class="operator">&lt;=</span><span class="number">30</span>;</span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询年龄22岁，18岁，25岁的信息</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">22</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">18</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">25</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IN</span> (<span class="number">22</span>,<span class="number">18</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询英语成绩为null</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english <span class="operator">=</span> <span class="keyword">NULL</span>; <span class="comment">-- 不对的。null值不能使用 = （!=） 判断</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询英语成绩不为null</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english  <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询姓马的有哪些？ like</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;马%&#x27;</span>;</span><br><span class="line">		<span class="comment">-- 查询姓名第二个字是化的人</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> &quot;_化%&quot;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询姓名是3个字的人</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;___&#x27;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询姓名中包含德的人</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;%德%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-排序查询"><a href="#4-排序查询" class="headerlink" title="4. 排序查询"></a>4. 排序查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法：order by 子句</span></span><br><span class="line">	<span class="operator">*</span> <span class="keyword">order</span> <span class="keyword">by</span> 排序字段<span class="number">1</span> 排序方式<span class="number">1</span> ，  排序字段<span class="number">2</span> 排序方式<span class="number">2.</span>..</span><br><span class="line"></span><br><span class="line">	<span class="operator">*</span> 排序方式：</span><br><span class="line">		<span class="operator">*</span> <span class="keyword">ASC</span>：升序，默认的。</span><br><span class="line">		<span class="operator">*</span> <span class="keyword">DESC</span>：降序。</span><br><span class="line"></span><br><span class="line">	<span class="operator">*</span> 注意：</span><br><span class="line">		<span class="operator">*</span> 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</span><br></pre></td></tr></table></figure>

<h3 id="5-聚合函数"><a href="#5-聚合函数" class="headerlink" title="5. 聚合函数"></a>5. 聚合函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 聚合函数：将一列数据作为一个整体，进行纵向的计算。</span></span><br><span class="line">	<span class="number">1.</span> count：计算个数</span><br><span class="line">		<span class="number">1.</span> 一般选择非空的列：主键</span><br><span class="line">		<span class="number">2.</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">	<span class="number">2.</span> max：计算最大值</span><br><span class="line">	<span class="number">3.</span> min：计算最小值</span><br><span class="line">	<span class="number">4.</span> sum：计算和</span><br><span class="line">	<span class="number">5.</span> avg：计算平均值</span><br><span class="line">	<span class="operator">*</span> 注意：聚合函数的计算，排除<span class="keyword">null</span>值。</span><br><span class="line">		解决方案：</span><br><span class="line">			<span class="number">1.</span> 选择不包含非空的列进行计算</span><br><span class="line">			<span class="number">2.</span> IFNULL函数</span><br></pre></td></tr></table></figure>

<h3 id="6-分组查询"><a href="#6-分组查询" class="headerlink" title="6. 分组查询"></a>6. 分组查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 分组查询:</span></span><br><span class="line">	<span class="number">1.</span> 语法：<span class="keyword">group</span> <span class="keyword">by</span> 分组字段；</span><br><span class="line">	<span class="number">2.</span> 注意：</span><br><span class="line">		<span class="number">1.</span> 分组之后查询的字段：分组字段、聚合函数</span><br><span class="line">		<span class="number">2.</span> <span class="keyword">where</span> 和 <span class="keyword">having</span> 的区别？</span><br><span class="line">			<span class="number">1.</span> <span class="keyword">where</span> 在分组之前进行限定，如果不满足条件，则不参与分组。<span class="keyword">having</span>在分组之后进行限定，如果不满足结果，则不会被查询出来</span><br><span class="line">			<span class="number">2.</span> <span class="keyword">where</span> 后不可以跟聚合函数，<span class="keyword">having</span>可以进行聚合函数的判断。</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 按照性别分组。分别查询男、女同学的平均分</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> sex , <span class="built_in">AVG</span>(math) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">-- 按照性别分组。分别查询男、女同学的平均分,人数</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">SELECT</span> sex , <span class="built_in">AVG</span>(math),<span class="built_in">COUNT</span>(id) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组</span></span><br><span class="line">		<span class="keyword">SELECT</span> sex , <span class="built_in">AVG</span>(math),<span class="built_in">COUNT</span>(id) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> math <span class="operator">&gt;</span> <span class="number">70</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人</span></span><br><span class="line">		<span class="keyword">SELECT</span> sex , <span class="built_in">AVG</span>(math),<span class="built_in">COUNT</span>(id) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> math <span class="operator">&gt;</span> <span class="number">70</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(id) <span class="operator">&gt;</span> <span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">SELECT</span> sex , <span class="built_in">AVG</span>(math),<span class="built_in">COUNT</span>(id) 人数 <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> math <span class="operator">&gt;</span> <span class="number">70</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex <span class="keyword">HAVING</span> 人数 <span class="operator">&gt;</span> <span class="number">2</span>;	</span><br></pre></td></tr></table></figure>

<h3 id="7-分页查询"><a href="#7-分页查询" class="headerlink" title="7. 分页查询"></a>7. 分页查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 分页查询</span></span><br><span class="line">	<span class="number">1.</span> 语法：limit 开始的索引,每页查询的条数;</span><br><span class="line">	<span class="number">2.</span> 公式：开始的索引 <span class="operator">=</span> （当前的页码 <span class="operator">-</span> <span class="number">1</span>） <span class="operator">*</span> 每页显示的条数</span><br><span class="line">		<span class="comment">-- 每页显示3条记录 </span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LIMIT <span class="number">0</span>,<span class="number">3</span>; <span class="comment">-- 第1页</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LIMIT <span class="number">3</span>,<span class="number">3</span>; <span class="comment">-- 第2页</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LIMIT <span class="number">6</span>,<span class="number">3</span>; <span class="comment">-- 第3页</span></span><br><span class="line"></span><br><span class="line">	<span class="number">3.</span> limit 是一个MySQL&quot;方言&quot;</span><br></pre></td></tr></table></figure>

<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p><strong>概念：</strong> 对表中的数据进行限定，保证数据的正确性、有效性和完整性。</p>
<p><strong>分类：</strong></p>
<ol>
<li>主键约束：<strong>primary key</strong></li>
<li>非空约束：<strong>not null</strong></li>
<li>唯一约束：<strong>unique</strong></li>
<li>外键约束：<strong>foreign key</strong></li>
</ol>
<p><strong>非空约束：not null</strong>，某一列的值不能为null</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建表时添加约束</span></span><br><span class="line">		<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(</span><br><span class="line">			id <span class="type">INT</span>,</span><br><span class="line">			NAME <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="comment">-- name为非空</span></span><br><span class="line">		);</span><br><span class="line"><span class="comment">-- 2. 创建表完后，添加非空约束</span></span><br><span class="line">		<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu MODIFY NAME <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 删除name的非空约束</span></span><br><span class="line">		<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu MODIFY NAME <span class="type">VARCHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p><strong>唯一约束： unique</strong>，某一列的值不能重复</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 注意：</span></span><br><span class="line">		<span class="operator">*</span> 唯一约束可以有<span class="keyword">NULL</span>值，但是只能有一条记录为<span class="keyword">null</span></span><br><span class="line"><span class="comment">-- 2. 在创建表时，添加唯一约束</span></span><br><span class="line">		<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(</span><br><span class="line">			id <span class="type">INT</span>,</span><br><span class="line">			phone_number <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span> <span class="comment">-- 手机号</span></span><br><span class="line">		);</span><br><span class="line"><span class="comment">-- 3. 删除唯一约束</span></span><br><span class="line">		<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">DROP</span> INDEX phone_number;</span><br><span class="line"><span class="comment">-- 4. 在表创建完后，添加唯一约束</span></span><br><span class="line">		<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu MODIFY phone_number <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>;</span><br></pre></td></tr></table></figure>

<p><strong>主键约束：primary key</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 注意：</span></span><br><span class="line">		<span class="number">1.</span> 含义：非空且唯一</span><br><span class="line">		<span class="number">2.</span> 一张表只能有一个字段为主键</span><br><span class="line">		<span class="number">3.</span> 主键就是表中记录的唯一标识</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 在创建表时，添加主键约束</span></span><br><span class="line">		<span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">			id <span class="type">int</span> <span class="keyword">primary</span> key,<span class="comment">-- 给id添加主键约束</span></span><br><span class="line">			name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 删除主键</span></span><br><span class="line">		<span class="comment">-- 错误 alter table stu modify id int ;</span></span><br><span class="line">		<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 创建完表后，添加主键</span></span><br><span class="line">		<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu MODIFY id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. 自动增长：</span></span><br><span class="line">		<span class="number">1.</span>概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长</span><br><span class="line"></span><br><span class="line">		<span class="number">2.</span>在创建表时，添加主键约束，并且完成主键自增长</span><br><span class="line">            <span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">                id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,<span class="comment">-- 给id添加主键约束</span></span><br><span class="line">                name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">            );</span><br><span class="line">		<span class="number">3.</span> 删除自动增长</span><br><span class="line">			<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu MODIFY id <span class="type">INT</span>;</span><br><span class="line">		<span class="number">4.</span> 添加自动增长</span><br><span class="line">			<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu MODIFY id <span class="type">INT</span> AUTO_INCREMENT;</span><br></pre></td></tr></table></figure>

<p><strong>外键约束：foreign key</strong>,让表于表产生关系，从而保证数据的正确性</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 在创建表时，可以添加外键</span></span><br><span class="line">		<span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">			....</span><br><span class="line">			外键列</span><br><span class="line">			<span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key (外键列名称) <span class="keyword">references</span> 主表名称(主表列名称)</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 删除外键</span></span><br><span class="line">		<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 创建表之后，添加外键</span></span><br><span class="line">		<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名称) <span class="keyword">REFERENCES</span> 主表名称(主表列名称);</span><br><span class="line"><span class="comment">-- 4. 级联操作</span></span><br><span class="line">		<span class="number">1.</span> 添加级联操作</span><br><span class="line">			<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 </span><br><span class="line">			<span class="keyword">FOREIGN</span> KEY (外键字段名称) <span class="keyword">REFERENCES</span> 主表名称(主表列名称) <span class="keyword">ON</span> UPDATE CASCADE <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE;</span><br><span class="line">		<span class="number">2.</span> 分类：</span><br><span class="line">			<span class="number">1.</span> 级联更新：<span class="keyword">ON</span> UPDATE CASCADE </span><br><span class="line">			<span class="number">2.</span> 级联删除：<span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE 		</span><br></pre></td></tr></table></figure>

<h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><h3 id="1-多表之间的关系"><a href="#1-多表之间的关系" class="headerlink" title="1. 多表之间的关系"></a>1. 多表之间的关系</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 分类：</span></span><br><span class="line">	</span><br><span class="line">	<span class="number">1.</span> 一对一(了解)：</span><br><span class="line">		<span class="operator">*</span> 如：人和身份证</span><br><span class="line">		<span class="operator">*</span> 分析：一个人只有一个身份证，一个身份证只能对应一个人</span><br><span class="line">	<span class="number">2.</span> 一对多(多对一)：</span><br><span class="line">		<span class="operator">*</span> 如：部门和员工</span><br><span class="line">		<span class="operator">*</span> 分析：一个部门有多个员工，一个员工只能对应一个部门</span><br><span class="line">	<span class="number">3.</span> 多对多：</span><br><span class="line">		<span class="operator">*</span> 如：学生和课程</span><br><span class="line">		<span class="operator">*</span> 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择</span><br><span class="line">	</span><br><span class="line"><span class="comment">-- 2. 实现关系：</span></span><br><span class="line">	<span class="number">1.</span> 一对多(多对一)：</span><br><span class="line">		<span class="operator">*</span> 如：部门和员工</span><br><span class="line">		<span class="operator">*</span> 实现方式：在多的一方建立外键，指向一的一方的主键。</span><br><span class="line">	<span class="number">2.</span> 多对多：</span><br><span class="line">		<span class="operator">*</span> 如：学生和课程</span><br><span class="line">		<span class="operator">*</span> 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键</span><br><span class="line">	<span class="number">3.</span> 一对一(了解)：</span><br><span class="line">		<span class="operator">*</span> 如：人和身份证</span><br><span class="line">		<span class="operator">*</span> 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 案例</span></span><br><span class="line">	<span class="comment">/*  </span></span><br><span class="line"><span class="comment">		创建旅游线路分类表 tab_category</span></span><br><span class="line"><span class="comment">		cid 旅游线路分类主键，自动增长</span></span><br><span class="line"><span class="comment">		cname 旅游线路分类名称非空，唯一，字符串 100</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_category (</span><br><span class="line">		cid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">		cname <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span></span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- 创建旅游线路表 tab_route</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		rid 旅游线路主键，自动增长</span></span><br><span class="line"><span class="comment">		rname 旅游线路名称非空，唯一，字符串 100</span></span><br><span class="line"><span class="comment">		price 价格</span></span><br><span class="line"><span class="comment">		rdate 上架时间，日期类型</span></span><br><span class="line"><span class="comment">		cid 外键，所属分类</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_route(</span><br><span class="line">		rid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">		rname <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">		price <span class="keyword">DOUBLE</span>,</span><br><span class="line">		rdate <span class="type">DATE</span>,</span><br><span class="line">		cid <span class="type">INT</span>,</span><br><span class="line">		<span class="keyword">FOREIGN</span> KEY (cid) <span class="keyword">REFERENCES</span> tab_category(cid)</span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- 创建用户表 tab_user</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		uid 用户主键，自增长</span></span><br><span class="line"><span class="comment">		username 用户名长度 100，唯一，非空</span></span><br><span class="line"><span class="comment">		password 密码长度 30，非空</span></span><br><span class="line"><span class="comment">		name 真实姓名长度 100</span></span><br><span class="line"><span class="comment">		birthday 生日</span></span><br><span class="line"><span class="comment">		sex 性别，定长字符串 1</span></span><br><span class="line"><span class="comment">		telephone 手机号，字符串 11</span></span><br><span class="line"><span class="comment">		email 邮箱，字符串长度 100</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_user (</span><br><span class="line">		uid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">		username <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">		PASSWORD <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">		NAME <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">		birthday <span class="type">DATE</span>,</span><br><span class="line">		sex <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">		telephone <span class="type">VARCHAR</span>(<span class="number">11</span>),</span><br><span class="line">		email <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">	);</span><br><span class="line">	<span class="comment">-- 创建收藏表 tab_favorite</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		rid 旅游线路 id，外键</span></span><br><span class="line"><span class="comment">		date 收藏时间</span></span><br><span class="line"><span class="comment">		uid 用户 id，外键</span></span><br><span class="line"><span class="comment">		rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_favorite (</span><br><span class="line">		rid <span class="type">INT</span>, <span class="comment">-- 线路id</span></span><br><span class="line">		<span class="type">DATE</span> DATETIME,</span><br><span class="line">		uid <span class="type">INT</span>, <span class="comment">-- 用户id</span></span><br><span class="line">		<span class="comment">-- 创建复合主键</span></span><br><span class="line">		<span class="keyword">PRIMARY</span> KEY(rid,uid), <span class="comment">-- 联合主键</span></span><br><span class="line">		<span class="keyword">FOREIGN</span> KEY (rid) <span class="keyword">REFERENCES</span> tab_route(rid),</span><br><span class="line">		<span class="keyword">FOREIGN</span> KEY(uid) <span class="keyword">REFERENCES</span> tab_user(uid)</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>

<h3 id="2-数据库设计的范式"><a href="#2-数据库设计的范式" class="headerlink" title="2.数据库设计的范式"></a>2.数据库设计的范式</h3><ul>
<li><p>概念：**设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求</p>
</li>
<li><p>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p>
</li>
<li><p>目前关系数据库有六种范式：<strong>第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）</strong>。</p>
</li>
<li><p>分类：</p>
<ol>
<li>第一范式（1NF）：每一列都是不可分割的原子数据项</li>
<li>第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）<ul>
<li>几个概念：<pre><code>1. **函数依赖：**A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A
    例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数
2. **完全函数依赖：**A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。
    例如：（学号，课程名称） --&gt; 分数
3. **部分函数依赖：**A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。
    例如：（学号，课程名称） -- &gt; 姓名
4. **传递函数依赖：**A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A
    例如：学号--&gt;系名，系名--&gt;系主任
5. **码：**如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码
    例如：该表中码为：（学号，课程名称）
    **主属性：**码属性组中的所有属性
    **非主属性：**除过码属性组的属性
</code></pre>
</li>
</ul>
</li>
<li>第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</li>
</ol>
</li>
</ul>
<h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><ol>
<li>命令行：<ul>
<li>备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径</li>
<li>还原：<pre><code>  1. 登录数据库
  2. 创建数据库
  3. 使用数据库
  4. 执行文件。source 文件路径
</code></pre>
</li>
</ul>
</li>
<li>图形化工具：</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法设计</title>
    <url>/p/a8930426.html</url>
    <content><![CDATA[<h3 id="P53习题"><a href="#P53习题" class="headerlink" title="P53习题"></a>P53习题</h3><p><strong>(1)将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两个链表</strong></p>
<p>  <strong>的存储空间，不另外占用其他的存储空间。表中不允许有重复的数据。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType  data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//下一个节点地址</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line">LinkList pa, pb, pc, q, r, t;</span><br><span class="line">LinkList La, Lb, Lc; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IintList</span> <span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	L = <span class="keyword">new</span> LNode;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span></span>&#123; <span class="comment">// 合并链表La和Lb，合并后的新表使用头指针Lc指向 </span></span><br><span class="line">	pa=La-&gt;next;</span><br><span class="line">	pb=Lb-&gt;next;<span class="comment">//pa和pb分别是链表La和Lb的工作指针，初始化为相应链表的第一个结点</span></span><br><span class="line">	</span><br><span class="line">	Lc = pc =La; <span class="comment">//用La的头结点作为Lc的头结点</span></span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line">	    <span class="keyword">if</span>(pa-&gt;data&lt;pb-&gt;data)&#123;</span><br><span class="line">	        pc-&gt;next=pa;</span><br><span class="line">	        pc=pa;</span><br><span class="line">	        pa=pa-&gt;next;</span><br><span class="line">	    &#125;	<span class="comment">//取较小者La中的元素，将pa链接在pc的后面，pa的指针后移</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pa-&gt;data&gt;pb-&gt;data)&#123;</span><br><span class="line">			pc-&gt;next=pb;</span><br><span class="line">	        pc=pb;</span><br><span class="line">	        pb=pb-&gt;next;</span><br><span class="line">		&#125;   <span class="comment">//取较小者Lb中的元素，将pb链接在pc的后面，pb的指针后移</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">	        pc-&gt;next = pa;</span><br><span class="line">			pc = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">			q = pb-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> pb;</span><br><span class="line">			pb = q;   </span><br><span class="line">		&#125;	<span class="comment">//相等时取La中的元素，删除Lb中的元素 </span></span><br><span class="line">	&#125;</span><br><span class="line">   pc-&gt;next = pa ? pa : pb;  </span><br><span class="line">   <span class="keyword">delete</span> Lb;          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, n;</span><br><span class="line">	<span class="built_in">IintList</span>(La); </span><br><span class="line">	<span class="built_in">IintList</span>(Lb);</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入La表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="comment">// 尾插法</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向La顺序表赋值：&quot;</span>);</span><br><span class="line">	r = La;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">		pa = <span class="keyword">new</span> LNode; </span><br><span class="line">		cin&gt;&gt;pa-&gt;data;</span><br><span class="line"></span><br><span class="line">		pa-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next = pa;</span><br><span class="line">        r = pa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;La的数据为: &quot;</span>);</span><br><span class="line">	<span class="comment">//链表遍历 </span></span><br><span class="line">	pa = La-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pa)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pa-&gt;data);</span><br><span class="line">		pa = pa-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n输入Lb表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="comment">// 尾插法</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向Lb顺序表赋值：&quot;</span>);</span><br><span class="line">	r = Lb;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;n; i++)&#123;</span><br><span class="line">		pb = <span class="keyword">new</span> LNode;  </span><br><span class="line">		cin&gt;&gt;pb-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pb;</span><br><span class="line">		r = pb;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Lb的数据为：&quot;</span>);</span><br><span class="line">	<span class="comment">//链表遍历</span></span><br><span class="line">	pb = Lb-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pb)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pb-&gt;data);</span><br><span class="line">		pb = pb-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">MergeList</span>(La, Lb, Lc);</span><br><span class="line">	<span class="comment">//链表遍历</span></span><br><span class="line">	t = La-&gt;next;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;合并后链表为：&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;data);</span><br><span class="line">		t = t-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)将两个非递减的有序链表合并为一个非递增的有序链表。要求结果链表仍使用原来两个链表的存储空间,不另外占用其他的存储空间。表中允许有重复的数据。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span>	<span class="comment">//下一个节点地址</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line">LinkList pa, pb, pc, q, r, t;</span><br><span class="line">LinkList La, Lb, Lc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IintList</span> <span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	L = <span class="keyword">new</span> LNode;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span></span>&#123; <span class="comment">//合并链表La和Lb，合并后的新表使用头指针Lc指向</span></span><br><span class="line">    pa=La-&gt;next;</span><br><span class="line">    pb=Lb-&gt;next; <span class="comment">//pa和pb分别是链表La和Lb的工作指针，初始化为相应链表的第一个结点</span></span><br><span class="line">    </span><br><span class="line">    Lc = pc =La; <span class="comment">//用La的头结点作为Lc的头结点</span></span><br><span class="line">    Lc-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(pa || pb)&#123;<span class="comment">//只要存在一个非空表，用q指向待摘取的元素 </span></span><br><span class="line">    	<span class="keyword">if</span>(!pa)&#123;</span><br><span class="line">    		q = pb;</span><br><span class="line">    		pb = pb-&gt;next;</span><br><span class="line">		&#125; <span class="comment">//La表为空，用q指向pb，pb指针后移</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!pb)&#123;</span><br><span class="line">			q = pb;</span><br><span class="line">			pa = pa-&gt;next; </span><br><span class="line">		&#125; <span class="comment">//Lb表为空，用q指向pa，pa指针后移</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pa-&gt;data&lt;=pb-&gt;data)&#123;</span><br><span class="line">			q = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">		&#125; <span class="comment">//取较小者（包括等于）La中的元素，用q指向pa，pa指针后移 </span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">	        q = pb;</span><br><span class="line">			pb = pb-&gt;next;</span><br><span class="line">		&#125; <span class="comment">//取较小者Lb中的元素，用q指向pb，pb指针后移 </span></span><br><span class="line">		q-&gt;next = Lc-&gt;next;</span><br><span class="line">		Lc-&gt;next = q; <span class="comment">//将q指向的结点插在Lc表的表头结点之后 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> Lb; <span class="comment">//释放Lb的头结点 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line">	<span class="built_in">IintList</span>(La); </span><br><span class="line">	<span class="built_in">IintList</span>(Lb);</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入La表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向La顺序表赋值：&quot;</span>);</span><br><span class="line">	<span class="comment">//尾插法 </span></span><br><span class="line">	r = La; </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">		pa = <span class="keyword">new</span> LNode; </span><br><span class="line">		cin&gt;&gt;pa-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pa-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pa;</span><br><span class="line">		r = pa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;La的数据为: &quot;</span>);</span><br><span class="line">	<span class="comment">//链表La遍历 </span></span><br><span class="line">	pa = La-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pa)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pa-&gt;data);</span><br><span class="line">		pa = pa-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n输入Lb表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向Lb顺序表赋值：&quot;</span>);</span><br><span class="line">	<span class="comment">//尾插法</span></span><br><span class="line">	r = Lb; </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;n; i++)&#123;</span><br><span class="line">		pb = <span class="keyword">new</span> LNode;  </span><br><span class="line">		cin&gt;&gt;pb-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pb;</span><br><span class="line">		r = pb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Lb的数据为：&quot;</span>);</span><br><span class="line">	<span class="comment">//链表Lb的遍历 </span></span><br><span class="line">	pb = Lb-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pb)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pb-&gt;data);</span><br><span class="line">		pb = pb-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">MergeList</span>(La, Lb, Lc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;合并后链表为：&quot;</span>);</span><br><span class="line">	<span class="comment">//链表遍历</span></span><br><span class="line">	t = La-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;data);</span><br><span class="line">		t = t-&gt;next;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(3)已知两个链表A和B分别表示两个集合，其元素递增排列。 请设计一个算法，用于求出A与B的交集，并存放在A链表中。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType  data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//下一个节点地址</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line">LinkList pa, pb, pc, u, r, t;</span><br><span class="line">LinkList La, Lb, Lc; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IintList</span> <span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	L = <span class="keyword">new</span> LNode;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mix</span><span class="params">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span></span>&#123;</span><br><span class="line">    pa = La-&gt;next;</span><br><span class="line">    pb = Lb-&gt;next;	<span class="comment">//pa和pb分别是链表La和Lb的工作指针，初始化为相应链表的第一个结点</span></span><br><span class="line">    </span><br><span class="line">    Lc = pc =La; <span class="comment">//用La的头结点作为Lc的头结点</span></span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(pa-&gt;data == pb-&gt;data)&#123;	<span class="comment">//交集并入结果表中 </span></span><br><span class="line">    		pc-&gt;next = pa;</span><br><span class="line">			pc = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">			u = pb;</span><br><span class="line">			pb = pb-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> u; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pa-&gt;data&lt;pb-&gt;data)&#123;</span><br><span class="line">			u = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> u;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			u = pb;</span><br><span class="line">			pb = pb-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> u;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(pa)&#123;</span><br><span class="line">		u = pa;</span><br><span class="line">		pa = pa-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> u;</span><br><span class="line">	&#125; <span class="comment">//释放结点空间 </span></span><br><span class="line">	<span class="keyword">while</span>(pb)&#123;</span><br><span class="line">		u = pb;</span><br><span class="line">		pb = pb-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> u;</span><br><span class="line">	&#125; <span class="comment">//释放结点空间 </span></span><br><span class="line">	pc-&gt;next = <span class="literal">NULL</span>; <span class="comment">//置链表尾标记 </span></span><br><span class="line">	<span class="keyword">delete</span> Lb; <span class="comment">//释放Lb的头结点 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, n;</span><br><span class="line">	<span class="built_in">IintList</span>(La); </span><br><span class="line">	<span class="built_in">IintList</span>(Lb);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入La表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向La顺序表赋值：&quot;</span>);</span><br><span class="line">	<span class="comment">//尾插法</span></span><br><span class="line">    r = La;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">		pa = <span class="keyword">new</span> LNode; </span><br><span class="line">		cin&gt;&gt;pa-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pa-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pa;</span><br><span class="line">		r = pa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;La的数据为: &quot;</span>);</span><br><span class="line">	<span class="comment">//链表La的遍历 </span></span><br><span class="line">	pa = La-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pa)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,pa-&gt;data);</span><br><span class="line">		pa = pa-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n输入Lb表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向Lb顺序表赋值：&quot;</span>);</span><br><span class="line">	<span class="comment">//尾插法 </span></span><br><span class="line">	r = Lb;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;n; i++)&#123;</span><br><span class="line">		pb = <span class="keyword">new</span> LNode;  </span><br><span class="line">		cin&gt;&gt;pb-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pb;</span><br><span class="line">		r = pb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Lb的数据为：&quot;</span>);</span><br><span class="line">	<span class="comment">//链表Lb的遍历 </span></span><br><span class="line">	pb = Lb-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pb)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pb-&gt;data);</span><br><span class="line">		pb = pb-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Mix</span>(La,Lb,Lc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n合并后链表为：&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	t = La-&gt;next;	</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;data);</span><br><span class="line">		t = t-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="P85习题"><a href="#P85习题" class="headerlink" title="P85习题"></a>P85习题</h3><p><strong>(2)回文是指正读反读均相同的字符序列，如：“abba ”和 “abdba ” 均是回文，但“good ” 不是回文。<br>  试写一个算法判定给定的字符序列是否为回文。（提示：将一半字符入栈）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;String.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个栈 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *base;</span><br><span class="line">	<span class="keyword">char</span> *top;</span><br><span class="line">	<span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化栈 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">	S.base=<span class="keyword">new</span> <span class="keyword">char</span>[MAX];</span><br><span class="line">	<span class="keyword">if</span>(!S.base)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	S.top=S.base;</span><br><span class="line">	S.stacksize=MAX;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==S.base)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//栈空 </span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈非空 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断栈是否满</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top-S.base==S.stacksize)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//栈满 </span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈空 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,<span class="keyword">char</span> e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsFull</span>(S))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈满，无法入栈 </span></span><br><span class="line">	&#125;</span><br><span class="line">	*S.top++=e;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,<span class="keyword">char</span> &amp;e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsEmpty</span>(S))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈空，无法出栈 </span></span><br><span class="line">	&#125;</span><br><span class="line">	e=*--S.top;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsHuiWen2</span><span class="params">(SqStack &amp;S,<span class="keyword">char</span> str[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">int</span> m=len/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="built_in">Push</span>(S,str[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(S))&#123;</span><br><span class="line">			<span class="keyword">char</span> e;</span><br><span class="line">			<span class="built_in">Pop</span>(S,e);</span><br><span class="line">			temp=e;</span><br><span class="line">			<span class="keyword">if</span>(temp!=str[i])&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(len%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">		i=i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(S))&#123;</span><br><span class="line">			<span class="keyword">char</span> e;</span><br><span class="line">			<span class="built_in">Pop</span>(S,e);</span><br><span class="line">			temp=e;</span><br><span class="line">			<span class="keyword">if</span>(temp!=str[i])&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	SqStack S;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">InitStack</span>(S))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;初始化成功!\n&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;初始化失败!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入字符串:&quot;</span>);</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsHuiWen2</span>(S,str))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;是回文串!\n&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;不是回文串!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**(3)设从键盘输入一整数的序列：a1,a2,a3,…an,试编写算法实现：<br>   用栈结构存储输入的整数，当ai≠-1时，将ai进栈；当ai=-1时，输入栈顶整数并出栈。<br>   算法应对异常情况（入栈满等）给出相应的信息。 **</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TRUE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> FALSE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STACK_MAXSIZE = <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *base;</span><br><span class="line">    <span class="keyword">int</span> *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_Stack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base=<span class="keyword">new</span> <span class="keyword">int</span> [STACK_MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!S.base) <span class="keyword">return</span>;</span><br><span class="line">    S.top=S.base;</span><br><span class="line">    S.stacksize=STACK_MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Push_Stack</span><span class="params">(SqStack &amp;s, <span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.top - s.base == s.stacksize)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;\nerror:栈满&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		*s.top = e;</span><br><span class="line">		s.top ++;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">Pop_Stack</span><span class="params">(SqStack &amp;s, <span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.top == s.base)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;\n栈空，无法执行出栈操作&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		s.top--;</span><br><span class="line">		e = *s.top;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Page85.2.(3)</span></span><br><span class="line">	<span class="keyword">int</span> input_num, pop_num;</span><br><span class="line">	SqStack s;</span><br><span class="line"> </span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;\n输入整数序列：&quot;</span>;</span><br><span class="line">	<span class="built_in">Init_Stack</span>(s);</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;input_num;</span><br><span class="line">		<span class="keyword">if</span>(input_num == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">Pop_Stack</span>(s, pop_num))</span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;pop_num;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Push_Stack</span>(s, input_num);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(s.top - s.base &lt;= s.stacksize);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;PAUSE&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P109习题"><a href="#P109习题" class="headerlink" title="P109习题"></a>P109习题</h3><p><strong>(1)写一个算法统计在输入字符串中各个不同字符出现的频度并将结果存入文件（字符串中的合法字符串为A~Z这26个字母和0 ~ 9这10个数字)。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">charCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,digit_num[<span class="number">10</span>],cap_num[<span class="number">26</span>];</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">		digit_num[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">26</span>; j++)</span><br><span class="line">		cap_num[j]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((ch = <span class="built_in">getchar</span>())!= <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span>(ch)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>..<span class="number">.&#x27;</span>Z<span class="number">&#x27;</span>:</span><br><span class="line">				j=ch<span class="number">-65</span>;</span><br><span class="line">				cap_num[j]++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>..<span class="number">.&#x27;9&#x27;</span>:</span><br><span class="line">				i=ch<span class="number">-48</span>;</span><br><span class="line">				digit_num[i]++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请输入合法字符（A~Z或0~9）！&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fp = <span class="built_in">fopen</span>(<span class="string">&quot;charCount.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;数字 %d 的个数为 %d ;\n&quot;</span>,i,digit_num[i]);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fprintf</span>(fp,<span class="string">&quot;数字 %d 的个数为 %d ;\n&quot;</span>,i,digit_num[i]) ==<span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;ERROR:结果写入文件charCount.txt失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">26</span>; j++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;字母 %c 的个数为 %d ;\n&quot;</span>,j+<span class="number">65</span>,cap_num[j]);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fprintf</span>(fp,<span class="string">&quot;字母 %c 的个数为 %d ;\n&quot;</span>,j+<span class="number">65</span>,cap_num[j]) == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;ERROR:结果写入文件charCount.txt失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n已将字符频度统计结果写入文件charCount.txt\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入一字符串，以#号结束输入：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">charCount</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）写一个递归算法来实现字符串逆序存储，要求不另设串存储空间</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">(<span class="keyword">char</span> A[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//利用静态变量存储数组下标</span></span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">invert</span>(A);</span><br><span class="line">        A[i++]=ch;<span class="comment">//先存的放到后边</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> A[<span class="number">100</span>];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入一个字符串（以‘#’为结束标志，不包括‘#’）&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">invert</span>(A);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;逆置后为：&quot;</span>&lt;&lt;A;<span class="comment">//char型数组可以利用数组名直接输出，int型则会输出其首地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P147习题"><a href="#P147习题" class="headerlink" title="P147习题"></a>P147习题</h3><p><strong>（1）统计二叉树的叶结点个数。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历顺序建立二叉树为：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreatBiTree</span>(T);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;中序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;后序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PostOrderTraverse</span>(T);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;该二叉树叶子结点个数为：&quot;</span>&lt;&lt;<span class="built_in">LeafCount</span>(T)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序建立二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历:若结点不为空就输出，遍历左子树，然后遍历右子树；</span></span><br><span class="line"><span class="comment">//若为空就不输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历:若结点不为空就遍历左子树，输出根结点数据，再遍历右子树；</span></span><br><span class="line"><span class="comment">//为空就不输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历:若结点不为空就遍历左子树，然后遍历右子树，输出根结点数据；</span></span><br><span class="line"><span class="comment">//若为空就不输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//叶子结点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; T-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LeafCount</span>(T-&gt;lchild)+<span class="built_in">LeafCount</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)判断两棵树是否相等</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitBiTree</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEqual</span><span class="params">(BiTree T1,BiTree T2)</span></span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiTree T1,T2;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历顺序建立二叉树T1为：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreatBiTree</span>(T1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;T1先序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T1);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历顺序建立二叉树T2为：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreatBiTree</span>(T2);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;T2先序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T2);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsEqual</span>(T1,T2))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;T1和T2相等&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">IsEqual</span>(T1,T2))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;T1和T2不相等&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序建立二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span> &amp;&amp; ch!=<span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序遍历:若结点不为空就输出，遍历左子树，然后遍历右子树；</span></span><br><span class="line"><span class="comment">//         若为空就不输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两棵树是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEqual</span><span class="params">(BiTree T1,BiTree T2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((T1==<span class="literal">NULL</span>) &amp;&amp; (T1==<span class="literal">NULL</span>))&#123;<span class="comment">//根结点都为空相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((T1==<span class="literal">NULL</span>)!=(T1==<span class="literal">NULL</span>))&#123;<span class="comment">//根结点一个为空，</span></span><br><span class="line">                                    <span class="comment">//一个不为空不相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(T1-&gt;data!=T2-&gt;data)&#123;<span class="comment">//根结点数据不等就不相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结点不空有数据</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">IsEqual</span>(T1-&gt;lchild,T2-&gt;lchild)</span><br><span class="line">            &amp;&amp; <span class="built_in">IsEqual</span>(T1-&gt;rchild,T2-&gt;rchild));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(6)用按层次顺序遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义结点 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">ElemType</span>;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MAX];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序建立二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span> &amp;&amp; ch!=<span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化循环队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front = Q.rear=<span class="number">0</span>;<span class="comment">//队头和队尾相等即为空队列 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进队 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,BiTree bt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>) % MAX == Q.front)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队列满了无法入队&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear = (Q.rear+<span class="number">1</span>) % MAX;</span><br><span class="line">		Q.data[Q.rear] = bt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队 </span></span><br><span class="line"><span class="function">BiTree <span class="title">OutQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    BiTree bt;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队列空了无法出队&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.front = (Q.front+<span class="number">1</span>) % MAX;</span><br><span class="line">        bt = Q.data[Q.front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断空队 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EmptyQueue</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front==Q.rear);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次顺序遍历:先进先出符合队列，先让第一层结点入队，然后依次入队；</span></span><br><span class="line"><span class="comment">//依次出队就为层次顺序遍历</span></span><br><span class="line"><span class="comment">//度为1的结点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Level</span><span class="params">(BiTree bt)</span></span>&#123;</span><br><span class="line">	BiTree p;</span><br><span class="line">	SqQueue Q;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(bt)&#123;</span><br><span class="line">		<span class="built_in">InitQueue</span>(Q);</span><br><span class="line">		<span class="built_in">EnQueue</span>(Q, bt);</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">EmptyQueue</span>(Q))&#123;</span><br><span class="line">			p=<span class="built_in">OutQueue</span>(Q);</span><br><span class="line">			cout&lt;&lt;p-&gt;data;</span><br><span class="line">			<span class="keyword">if</span>((p-&gt;lchild &amp;&amp; !p-&gt;rchild) ||(!p-&gt;lchild &amp;&amp; p-&gt;rchild))&#123;</span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;lchild)&#123;</span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,p-&gt;lchild);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild)&#123;</span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,p-&gt;rchild);</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历顺序建立二叉树为：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreatBiTree</span>(T);</span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;层次遍历后,度为1的结点个数为：&quot;</span>&lt;&lt;<span class="built_in">Level</span>(T)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
