<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java集合知识点总结</title>
    <url>/p/1dfa12bb.html</url>
    <content><![CDATA[<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h3 id="数组（ArraryList）"><a href="#数组（ArraryList）" class="headerlink" title="数组（ArraryList）"></a>数组（ArraryList）</h3><p>数组是一种<strong>查询修改快</strong>的模型（对比链表）  </p>
<h3 id="链表（LinkedList）"><a href="#链表（LinkedList）" class="headerlink" title="链表（LinkedList）"></a>链表（LinkedList）</h3><p>链表是一种<strong>增删快</strong>的模型（对比数组）</p>
<p>特有功能：</p>
<p>addFist，addLast，getFirst，getLast，removeFirst，removeLast</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set集合特点</p>
<ul>
<li><p>不包含重复元素的集合</p>
</li>
<li><p>没有带索引的方法，不能用普通for循环遍历</p>
</li>
</ul>
<p>HashSet：对集合的迭代顺序不作任何保证</p>
<h3 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h3><p>哈希值：是JDK根据对象的<strong>地址</strong>或者<strong>字符串</strong>或者<strong>数字</strong>算出来的int类型的<strong>数值</strong></p>
<p>Object类中有一个方法可以获取对象的哈希值</p>
<ul>
<li>public int hashCode(): 返回对象的哈希值</li>
</ul>
<p>对象的哈希值特点</p>
<ul>
<li>同一个对象多次调用hashCode()返回的哈希值是相同的</li>
<li>默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同</li>
</ul>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet集合特点</p>
<ul>
<li>底层数据结构是哈希表</li>
<li>对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致</li>
<li>没有带索引的方法，所以不能使用普通的for循环遍历</li>
<li>由于是Set集合，所以是不包含重复元素的集合</li>
</ul>
<p>HashSet集合保证元素唯一性源码分析</p>
<p><img src="http://image.xiaoke6.cn/images/bloghash.png"></p>
<p>HashSet集合存储元素：</p>
<ul>
<li>要保证元素唯一性，需要重写<strong>hashCode()和equals()</strong></li>
</ul>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet集合特点</p>
<ul>
<li>哈希表和链表实现的Set接口，具有可预测的迭代次序</li>
<li>由链表保证元素有序，也就是说元素的存储和取出顺序是一致的</li>
<li>由哈希表保证元素唯一，也就是说没有重复的元素</li>
</ul>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet集合特点</p>
<ul>
<li><p>元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法</p>
<p>TreeSet(): 根据其元素的自然排序进行排序</p>
<p>TreeSet(Comparator comparator): 根据指定的比较器进行排序</p>
</li>
<li><p>没有带索引的方法，所以不能使用普通的for循环遍历</p>
</li>
<li><p>由于是Set集合，所以不包含重复元素的集合</p>
</li>
</ul>
<p>自然排序Comparable的使用</p>
<ul>
<li>用TreeSet集合存储自定义对象，无参构造方法使用的是<strong>自然排序</strong>对元素进行排序的</li>
<li>自然排序，就是让元素所属的类实现Comparable接口，重写comparaTo()方法</li>
<li>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return -1; //-1按照降序，1按照升序，0重复元素不添加</span></span><br><span class="line">        <span class="comment">// 按照年龄从小到大排序,年龄相同，按照姓名字母顺序排序</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="keyword">this</span>.age - s.age;</span><br><span class="line">        <span class="keyword">int</span> num2 = num==<span class="number">0</span>?<span class="keyword">this</span>.name.compareTo(s.name):num;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>比较器排序Comparator的使用</p>
<ul>
<li>用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的</li>
<li>比较器排序，就是让集合构造方法接受Comparator的实现类对象，重写compare(T o1, T o2)方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;Student&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按照年龄从小到大排序,年龄相同，按照姓名字母顺序排序</span></span><br><span class="line">        <span class="comment">//this.age - s.age</span></span><br><span class="line">        <span class="comment">//s1,s1</span></span><br><span class="line">        <span class="keyword">int</span> num = s1.getAge() - s2.getAge();</span><br><span class="line">        <span class="keyword">int</span> num2 = num==<span class="number">0</span>? s1.getName().compareTo(s2.getName()):num;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map集合遍历</p>
<p><strong>方法一：增强for循环中使用entry来遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：在for-each循环中遍历keys或values</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//遍历map中的键</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + key);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//遍历map中的值</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Value = &quot;</span> + value);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：使用Iterator遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> </span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line"> </span><br><span class="line">    Map.Entry&lt;Integer, Integer&gt; entry = entries.next();</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法四：通过键找值遍历（效率低）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line"> </span><br><span class="line">    Integer value = map.get(key);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + key + <span class="string">&quot;, Value = &quot;</span> + value);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>如果仅需要键(keys)或值(values)使用方法二。如果你使用的语言版本低于java 5，或是打算在遍历时删除entries，必须使用方法三。否则使用方法一(键值都要)</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/p/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构算法设计</title>
    <url>/p/a8930426.html</url>
    <content><![CDATA[<h3 id="P53习题"><a href="#P53习题" class="headerlink" title="P53习题"></a>P53习题</h3><p><strong>(1)将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两个链表</strong></p>
<p>  <strong>的存储空间，不另外占用其他的存储空间。表中不允许有重复的数据。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType  data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//下一个节点地址</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line">LinkList pa, pb, pc, q, r, t;</span><br><span class="line">LinkList La, Lb, Lc; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IintList</span> <span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	L = <span class="keyword">new</span> LNode;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span></span>&#123; <span class="comment">// 合并链表La和Lb，合并后的新表使用头指针Lc指向 </span></span><br><span class="line">	pa=La-&gt;next;</span><br><span class="line">	pb=Lb-&gt;next;<span class="comment">//pa和pb分别是链表La和Lb的工作指针，初始化为相应链表的第一个结点</span></span><br><span class="line">	</span><br><span class="line">	Lc = pc =La; <span class="comment">//用La的头结点作为Lc的头结点</span></span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line">	    <span class="keyword">if</span>(pa-&gt;data&lt;pb-&gt;data)&#123;</span><br><span class="line">	        pc-&gt;next=pa;</span><br><span class="line">	        pc=pa;</span><br><span class="line">	        pa=pa-&gt;next;</span><br><span class="line">	    &#125;	<span class="comment">//取较小者La中的元素，将pa链接在pc的后面，pa的指针后移</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pa-&gt;data&gt;pb-&gt;data)&#123;</span><br><span class="line">			pc-&gt;next=pb;</span><br><span class="line">	        pc=pb;</span><br><span class="line">	        pb=pb-&gt;next;</span><br><span class="line">		&#125;   <span class="comment">//取较小者Lb中的元素，将pb链接在pc的后面，pb的指针后移</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">	        pc-&gt;next = pa;</span><br><span class="line">			pc = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">			q = pb-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> pb;</span><br><span class="line">			pb = q;   </span><br><span class="line">		&#125;	<span class="comment">//相等时取La中的元素，删除Lb中的元素 </span></span><br><span class="line">	&#125;</span><br><span class="line">   pc-&gt;next = pa ? pa : pb;  </span><br><span class="line">   <span class="keyword">delete</span> Lb;          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, n;</span><br><span class="line">	<span class="built_in">IintList</span>(La); </span><br><span class="line">	<span class="built_in">IintList</span>(Lb);</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入La表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="comment">// 尾插法</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向La顺序表赋值：&quot;</span>);</span><br><span class="line">	r = La;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">		pa = <span class="keyword">new</span> LNode; </span><br><span class="line">		cin&gt;&gt;pa-&gt;data;</span><br><span class="line"></span><br><span class="line">		pa-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next = pa;</span><br><span class="line">        r = pa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;La的数据为: &quot;</span>);</span><br><span class="line">	<span class="comment">//链表遍历 </span></span><br><span class="line">	pa = La-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pa)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pa-&gt;data);</span><br><span class="line">		pa = pa-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n输入Lb表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="comment">// 尾插法</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向Lb顺序表赋值：&quot;</span>);</span><br><span class="line">	r = Lb;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;n; i++)&#123;</span><br><span class="line">		pb = <span class="keyword">new</span> LNode;  </span><br><span class="line">		cin&gt;&gt;pb-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pb;</span><br><span class="line">		r = pb;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Lb的数据为：&quot;</span>);</span><br><span class="line">	<span class="comment">//链表遍历</span></span><br><span class="line">	pb = Lb-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pb)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pb-&gt;data);</span><br><span class="line">		pb = pb-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">MergeList</span>(La, Lb, Lc);</span><br><span class="line">	<span class="comment">//链表遍历</span></span><br><span class="line">	t = La-&gt;next;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;合并后链表为：&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;data);</span><br><span class="line">		t = t-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)将两个非递减的有序链表合并为一个非递增的有序链表。要求结果链表仍使用原来两个链表的存储空间,不另外占用其他的存储空间。表中允许有重复的数据。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span>	<span class="comment">//下一个节点地址</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line">LinkList pa, pb, pc, q, r, t;</span><br><span class="line">LinkList La, Lb, Lc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IintList</span> <span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	L = <span class="keyword">new</span> LNode;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span></span>&#123; <span class="comment">//合并链表La和Lb，合并后的新表使用头指针Lc指向</span></span><br><span class="line">    pa=La-&gt;next;</span><br><span class="line">    pb=Lb-&gt;next; <span class="comment">//pa和pb分别是链表La和Lb的工作指针，初始化为相应链表的第一个结点</span></span><br><span class="line">    </span><br><span class="line">    Lc = pc =La; <span class="comment">//用La的头结点作为Lc的头结点</span></span><br><span class="line">    Lc-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(pa || pb)&#123;<span class="comment">//只要存在一个非空表，用q指向待摘取的元素 </span></span><br><span class="line">    	<span class="keyword">if</span>(!pa)&#123;</span><br><span class="line">    		q = pb;</span><br><span class="line">    		pb = pb-&gt;next;</span><br><span class="line">		&#125; <span class="comment">//La表为空，用q指向pb，pb指针后移</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!pb)&#123;</span><br><span class="line">			q = pb;</span><br><span class="line">			pa = pa-&gt;next; </span><br><span class="line">		&#125; <span class="comment">//Lb表为空，用q指向pa，pa指针后移</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pa-&gt;data&lt;=pb-&gt;data)&#123;</span><br><span class="line">			q = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">		&#125; <span class="comment">//取较小者（包括等于）La中的元素，用q指向pa，pa指针后移 </span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">	        q = pb;</span><br><span class="line">			pb = pb-&gt;next;</span><br><span class="line">		&#125; <span class="comment">//取较小者Lb中的元素，用q指向pb，pb指针后移 </span></span><br><span class="line">		q-&gt;next = Lc-&gt;next;</span><br><span class="line">		Lc-&gt;next = q; <span class="comment">//将q指向的结点插在Lc表的表头结点之后 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> Lb; <span class="comment">//释放Lb的头结点 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line">	<span class="built_in">IintList</span>(La); </span><br><span class="line">	<span class="built_in">IintList</span>(Lb);</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入La表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向La顺序表赋值：&quot;</span>);</span><br><span class="line">	<span class="comment">//尾插法 </span></span><br><span class="line">	r = La; </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">		pa = <span class="keyword">new</span> LNode; </span><br><span class="line">		cin&gt;&gt;pa-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pa-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pa;</span><br><span class="line">		r = pa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;La的数据为: &quot;</span>);</span><br><span class="line">	<span class="comment">//链表La遍历 </span></span><br><span class="line">	pa = La-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pa)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pa-&gt;data);</span><br><span class="line">		pa = pa-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n输入Lb表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向Lb顺序表赋值：&quot;</span>);</span><br><span class="line">	<span class="comment">//尾插法</span></span><br><span class="line">	r = Lb; </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;n; i++)&#123;</span><br><span class="line">		pb = <span class="keyword">new</span> LNode;  </span><br><span class="line">		cin&gt;&gt;pb-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pb;</span><br><span class="line">		r = pb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Lb的数据为：&quot;</span>);</span><br><span class="line">	<span class="comment">//链表Lb的遍历 </span></span><br><span class="line">	pb = Lb-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pb)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pb-&gt;data);</span><br><span class="line">		pb = pb-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">MergeList</span>(La, Lb, Lc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;合并后链表为：&quot;</span>);</span><br><span class="line">	<span class="comment">//链表遍历</span></span><br><span class="line">	t = La-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;data);</span><br><span class="line">		t = t-&gt;next;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(3)已知两个链表A和B分别表示两个集合，其元素递增排列。 请设计一个算法，用于求出A与B的交集，并存放在A链表中。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType  data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//下一个节点地址</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line">LinkList pa, pb, pc, u, r, t;</span><br><span class="line">LinkList La, Lb, Lc; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IintList</span> <span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	L = <span class="keyword">new</span> LNode;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mix</span><span class="params">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span></span>&#123;</span><br><span class="line">    pa = La-&gt;next;</span><br><span class="line">    pb = Lb-&gt;next;	<span class="comment">//pa和pb分别是链表La和Lb的工作指针，初始化为相应链表的第一个结点</span></span><br><span class="line">    </span><br><span class="line">    Lc = pc =La; <span class="comment">//用La的头结点作为Lc的头结点</span></span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(pa-&gt;data == pb-&gt;data)&#123;	<span class="comment">//交集并入结果表中 </span></span><br><span class="line">    		pc-&gt;next = pa;</span><br><span class="line">			pc = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">			u = pb;</span><br><span class="line">			pb = pb-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> u; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pa-&gt;data&lt;pb-&gt;data)&#123;</span><br><span class="line">			u = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> u;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			u = pb;</span><br><span class="line">			pb = pb-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> u;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(pa)&#123;</span><br><span class="line">		u = pa;</span><br><span class="line">		pa = pa-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> u;</span><br><span class="line">	&#125; <span class="comment">//释放结点空间 </span></span><br><span class="line">	<span class="keyword">while</span>(pb)&#123;</span><br><span class="line">		u = pb;</span><br><span class="line">		pb = pb-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> u;</span><br><span class="line">	&#125; <span class="comment">//释放结点空间 </span></span><br><span class="line">	pc-&gt;next = <span class="literal">NULL</span>; <span class="comment">//置链表尾标记 </span></span><br><span class="line">	<span class="keyword">delete</span> Lb; <span class="comment">//释放Lb的头结点 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, n;</span><br><span class="line">	<span class="built_in">IintList</span>(La); </span><br><span class="line">	<span class="built_in">IintList</span>(Lb);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入La表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向La顺序表赋值：&quot;</span>);</span><br><span class="line">	<span class="comment">//尾插法</span></span><br><span class="line">    r = La;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">		pa = <span class="keyword">new</span> LNode; </span><br><span class="line">		cin&gt;&gt;pa-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pa-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pa;</span><br><span class="line">		r = pa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;La的数据为: &quot;</span>);</span><br><span class="line">	<span class="comment">//链表La的遍历 </span></span><br><span class="line">	pa = La-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pa)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,pa-&gt;data);</span><br><span class="line">		pa = pa-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n输入Lb表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向Lb顺序表赋值：&quot;</span>);</span><br><span class="line">	<span class="comment">//尾插法 </span></span><br><span class="line">	r = Lb;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;n; i++)&#123;</span><br><span class="line">		pb = <span class="keyword">new</span> LNode;  </span><br><span class="line">		cin&gt;&gt;pb-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pb;</span><br><span class="line">		r = pb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Lb的数据为：&quot;</span>);</span><br><span class="line">	<span class="comment">//链表Lb的遍历 </span></span><br><span class="line">	pb = Lb-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pb)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pb-&gt;data);</span><br><span class="line">		pb = pb-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Mix</span>(La,Lb,Lc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n合并后链表为：&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	t = La-&gt;next;	</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;data);</span><br><span class="line">		t = t-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="P85习题"><a href="#P85习题" class="headerlink" title="P85习题"></a>P85习题</h3><p><strong>(2)回文是指正读反读均相同的字符序列，如：“abba ”和 “abdba ” 均是回文，但“good ” 不是回文。<br>  试写一个算法判定给定的字符序列是否为回文。（提示：将一半字符入栈）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;String.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个栈 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *base;</span><br><span class="line">	<span class="keyword">char</span> *top;</span><br><span class="line">	<span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化栈 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">	S.base=<span class="keyword">new</span> <span class="keyword">char</span>[MAX];</span><br><span class="line">	<span class="keyword">if</span>(!S.base)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	S.top=S.base;</span><br><span class="line">	S.stacksize=MAX;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==S.base)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//栈空 </span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈非空 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断栈是否满</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top-S.base==S.stacksize)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//栈满 </span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈空 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,<span class="keyword">char</span> e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsFull</span>(S))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈满，无法入栈 </span></span><br><span class="line">	&#125;</span><br><span class="line">	*S.top++=e;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,<span class="keyword">char</span> &amp;e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsEmpty</span>(S))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈空，无法出栈 </span></span><br><span class="line">	&#125;</span><br><span class="line">	e=*--S.top;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsHuiWen2</span><span class="params">(SqStack &amp;S,<span class="keyword">char</span> str[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">int</span> m=len/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="built_in">Push</span>(S,str[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(S))&#123;</span><br><span class="line">			<span class="keyword">char</span> e;</span><br><span class="line">			<span class="built_in">Pop</span>(S,e);</span><br><span class="line">			temp=e;</span><br><span class="line">			<span class="keyword">if</span>(temp!=str[i])&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(len%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">		i=i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(S))&#123;</span><br><span class="line">			<span class="keyword">char</span> e;</span><br><span class="line">			<span class="built_in">Pop</span>(S,e);</span><br><span class="line">			temp=e;</span><br><span class="line">			<span class="keyword">if</span>(temp!=str[i])&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	SqStack S;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">InitStack</span>(S))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;初始化成功!\n&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;初始化失败!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入字符串:&quot;</span>);</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsHuiWen2</span>(S,str))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;是回文串!\n&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;不是回文串!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**(3)设从键盘输入一整数的序列：a1,a2,a3,…an,试编写算法实现：<br>   用栈结构存储输入的整数，当ai≠-1时，将ai进栈；当ai=-1时，输入栈顶整数并出栈。<br>   算法应对异常情况（入栈满等）给出相应的信息。 **</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TRUE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> FALSE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STACK_MAXSIZE = <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *base;</span><br><span class="line">    <span class="keyword">int</span> *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_Stack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base=<span class="keyword">new</span> <span class="keyword">int</span> [STACK_MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!S.base) <span class="keyword">return</span>;</span><br><span class="line">    S.top=S.base;</span><br><span class="line">    S.stacksize=STACK_MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Push_Stack</span><span class="params">(SqStack &amp;s, <span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.top - s.base == s.stacksize)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;\nerror:栈满&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		*s.top = e;</span><br><span class="line">		s.top ++;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">Pop_Stack</span><span class="params">(SqStack &amp;s, <span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.top == s.base)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;\n栈空，无法执行出栈操作&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		s.top--;</span><br><span class="line">		e = *s.top;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Page85.2.(3)</span></span><br><span class="line">	<span class="keyword">int</span> input_num, pop_num;</span><br><span class="line">	SqStack s;</span><br><span class="line"> </span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;\n输入整数序列：&quot;</span>;</span><br><span class="line">	<span class="built_in">Init_Stack</span>(s);</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;input_num;</span><br><span class="line">		<span class="keyword">if</span>(input_num == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">Pop_Stack</span>(s, pop_num))</span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;pop_num;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Push_Stack</span>(s, input_num);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(s.top - s.base &lt;= s.stacksize);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;PAUSE&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P109习题"><a href="#P109习题" class="headerlink" title="P109习题"></a>P109习题</h3><p><strong>(1)写一个算法统计在输入字符串中各个不同字符出现的频度并将结果存入文件（字符串中的合法字符串为A~Z这26个字母和0 ~ 9这10个数字)。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">charCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,digit_num[<span class="number">10</span>],cap_num[<span class="number">26</span>];</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">		digit_num[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">26</span>; j++)</span><br><span class="line">		cap_num[j]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((ch = <span class="built_in">getchar</span>())!= <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span>(ch)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>..<span class="number">.&#x27;</span>Z<span class="number">&#x27;</span>:</span><br><span class="line">				j=ch<span class="number">-65</span>;</span><br><span class="line">				cap_num[j]++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>..<span class="number">.&#x27;9&#x27;</span>:</span><br><span class="line">				i=ch<span class="number">-48</span>;</span><br><span class="line">				digit_num[i]++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请输入合法字符（A~Z或0~9）！&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fp = <span class="built_in">fopen</span>(<span class="string">&quot;charCount.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;数字 %d 的个数为 %d ;\n&quot;</span>,i,digit_num[i]);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fprintf</span>(fp,<span class="string">&quot;数字 %d 的个数为 %d ;\n&quot;</span>,i,digit_num[i]) ==<span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;ERROR:结果写入文件charCount.txt失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">26</span>; j++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;字母 %c 的个数为 %d ;\n&quot;</span>,j+<span class="number">65</span>,cap_num[j]);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fprintf</span>(fp,<span class="string">&quot;字母 %c 的个数为 %d ;\n&quot;</span>,j+<span class="number">65</span>,cap_num[j]) == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;ERROR:结果写入文件charCount.txt失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n已将字符频度统计结果写入文件charCount.txt\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入一字符串，以#号结束输入：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">charCount</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）写一个递归算法来实现字符串逆序存储，要求不另设串存储空间</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">(<span class="keyword">char</span> A[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//利用静态变量存储数组下标</span></span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">invert</span>(A);</span><br><span class="line">        A[i++]=ch;<span class="comment">//先存的放到后边</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> A[<span class="number">100</span>];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入一个字符串（以‘#’为结束标志，不包括‘#’）&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">invert</span>(A);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;逆置后为：&quot;</span>&lt;&lt;A;<span class="comment">//char型数组可以利用数组名直接输出，int型则会输出其首地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P147习题"><a href="#P147习题" class="headerlink" title="P147习题"></a>P147习题</h3><p><strong>（1）统计二叉树的叶结点个数。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历顺序建立二叉树为：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreatBiTree</span>(T);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;中序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;后序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PostOrderTraverse</span>(T);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;该二叉树叶子结点个数为：&quot;</span>&lt;&lt;<span class="built_in">LeafCount</span>(T)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序建立二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历:若结点不为空就输出，遍历左子树，然后遍历右子树；</span></span><br><span class="line"><span class="comment">//若为空就不输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历:若结点不为空就遍历左子树，输出根结点数据，再遍历右子树；</span></span><br><span class="line"><span class="comment">//为空就不输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历:若结点不为空就遍历左子树，然后遍历右子树，输出根结点数据；</span></span><br><span class="line"><span class="comment">//若为空就不输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//叶子结点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; T-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LeafCount</span>(T-&gt;lchild)+<span class="built_in">LeafCount</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)判断两棵树是否相等</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitBiTree</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEqual</span><span class="params">(BiTree T1,BiTree T2)</span></span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiTree T1,T2;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历顺序建立二叉树T1为：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreatBiTree</span>(T1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;T1先序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T1);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历顺序建立二叉树T2为：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreatBiTree</span>(T2);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;T2先序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T2);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsEqual</span>(T1,T2))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;T1和T2相等&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">IsEqual</span>(T1,T2))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;T1和T2不相等&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序建立二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span> &amp;&amp; ch!=<span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序遍历:若结点不为空就输出，遍历左子树，然后遍历右子树；</span></span><br><span class="line"><span class="comment">//         若为空就不输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两棵树是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEqual</span><span class="params">(BiTree T1,BiTree T2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((T1==<span class="literal">NULL</span>) &amp;&amp; (T1==<span class="literal">NULL</span>))&#123;<span class="comment">//根结点都为空相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((T1==<span class="literal">NULL</span>)!=(T1==<span class="literal">NULL</span>))&#123;<span class="comment">//根结点一个为空，</span></span><br><span class="line">                                    <span class="comment">//一个不为空不相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(T1-&gt;data!=T2-&gt;data)&#123;<span class="comment">//根结点数据不等就不相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结点不空有数据</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">IsEqual</span>(T1-&gt;lchild,T2-&gt;lchild)</span><br><span class="line">            &amp;&amp; <span class="built_in">IsEqual</span>(T1-&gt;rchild,T2-&gt;rchild));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(6)用按层次顺序遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义结点 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">ElemType</span>;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MAX];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序建立二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span> &amp;&amp; ch!=<span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化循环队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front = Q.rear=<span class="number">0</span>;<span class="comment">//队头和队尾相等即为空队列 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进队 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,BiTree bt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>) % MAX == Q.front)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队列满了无法入队&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear = (Q.rear+<span class="number">1</span>) % MAX;</span><br><span class="line">		Q.data[Q.rear] = bt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队 </span></span><br><span class="line"><span class="function">BiTree <span class="title">OutQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    BiTree bt;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队列空了无法出队&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.front = (Q.front+<span class="number">1</span>) % MAX;</span><br><span class="line">        bt = Q.data[Q.front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断空队 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EmptyQueue</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front==Q.rear);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次顺序遍历:先进先出符合队列，先让第一层结点入队，然后依次入队；</span></span><br><span class="line"><span class="comment">//依次出队就为层次顺序遍历</span></span><br><span class="line"><span class="comment">//度为1的结点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Level</span><span class="params">(BiTree bt)</span></span>&#123;</span><br><span class="line">	BiTree p;</span><br><span class="line">	SqQueue Q;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(bt)&#123;</span><br><span class="line">		<span class="built_in">InitQueue</span>(Q);</span><br><span class="line">		<span class="built_in">EnQueue</span>(Q, bt);</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">EmptyQueue</span>(Q))&#123;</span><br><span class="line">			p=<span class="built_in">OutQueue</span>(Q);</span><br><span class="line">			cout&lt;&lt;p-&gt;data;</span><br><span class="line">			<span class="keyword">if</span>((p-&gt;lchild &amp;&amp; !p-&gt;rchild) ||(!p-&gt;lchild &amp;&amp; p-&gt;rchild))&#123;</span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;lchild)&#123;</span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,p-&gt;lchild);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild)&#123;</span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,p-&gt;rchild);</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历顺序建立二叉树为：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreatBiTree</span>(T);</span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;层次遍历后,度为1的结点个数为：&quot;</span>&lt;&lt;<span class="built_in">Level</span>(T)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
