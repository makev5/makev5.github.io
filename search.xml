<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Junit单元测试、反射、注解</title>
    <url>/p/abb177c7.html</url>
    <content><![CDATA[<h3 id="Junit单元测试："><a href="#Junit单元测试：" class="headerlink" title="Junit单元测试："></a>Junit单元测试：</h3><h4 id="测试分类："><a href="#测试分类：" class="headerlink" title="测试分类："></a>测试分类：</h4><ol>
<li><strong>黑盒测试：</strong>不需要写代码，给输入值，看程序是否能够输出期望的值。</li>
<li><strong>白盒测试：</strong>需要写代码的。关注程序具体的执行流程。</li>
</ol>
<h4 id="Junit使用：白盒测试"><a href="#Junit使用：白盒测试" class="headerlink" title="Junit使用：白盒测试"></a>Junit使用：白盒测试</h4><h5 id="1-定义一个测试类-测试用例"><a href="#1-定义一个测试类-测试用例" class="headerlink" title="1. 定义一个测试类(测试用例)"></a>1. 定义一个测试类(测试用例)</h5><ul>
<li>测试类名：被测试的类名Test        CalculatorTest</li>
<li>包名：xxx.xxx.xx.test                    com.make.test</li>
</ul>
<h5 id="2-定义测试方法：可以独立运行"><a href="#2-定义测试方法：可以独立运行" class="headerlink" title="2. 定义测试方法：可以独立运行"></a>2. 定义测试方法：可以独立运行</h5><ul>
<li>方法名：test测试的方法名        testAdd()  </li>
<li>返回值：void</li>
<li>参数列表：空参</li>
</ul>
<h5 id="3-给方法加-Test"><a href="#3-给方法加-Test" class="headerlink" title="3. 给方法加@Test"></a>3. 给方法加@Test</h5><h5 id="4-导入junit依赖环境"><a href="#4-导入junit依赖环境" class="headerlink" title="4. 导入junit依赖环境"></a>4. 导入junit依赖环境</h5><ul>
<li><p>判定结果：</p>
<ul>
<li><p>红色：失败</p>
</li>
<li><p>绿色：成功</p>
</li>
<li><p>一般我们会使用断言操作来处理结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Assert.assertEquals(期望的结果,运算的结果);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>补充：</p>
<ul>
<li>@Before: 修饰的方法会在测试方法之前被自动执行</li>
<li>@After:  修饰的方法会在测试方法执行之后自动被执行</li>
</ul>
</li>
</ul>
<h3 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h3><ul>
<li>框架：半成品软件。可以在框架的基础上进行软件开发，简化编码</li>
<li>反射：将类的各个组成部分封装为其他对象，这就是反射机制<ul>
<li>好处：<ol>
<li>可以在程序运行过程中，操作这些对象。</li>
<li>可以解耦，提高程序的可扩展性。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="Class对象功能："><a href="#Class对象功能：" class="headerlink" title="Class对象功能："></a>Class对象功能：</h4><ul>
<li><p>获取功能：</p>
<ol>
<li>获取成员变量们</li>
</ol>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Field[] getFields()</td>
<td align="center">获取所有public修饰的成员变量</td>
</tr>
<tr>
<td align="center">Field getField(String name)</td>
<td align="center">获取指定名称的public修饰的成员变量</td>
</tr>
<tr>
<td align="center">Field[] getDeclaredFields()</td>
<td align="center">获取所有的成员变量，不考虑修饰符</td>
</tr>
<tr>
<td align="center">Field getDeclaredField(String name)</td>
<td align="center">获取指定名称的成员变量，不考虑修饰符</td>
</tr>
</tbody></table>
<ol start="2">
<li>获取构造方法们</li>
</ol>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Constructor&lt;?&gt;[] getConstructors()</td>
<td align="center">获取所有public修饰的构造方法</td>
</tr>
<tr>
<td align="center">Constructor<T> getConstructor(类&lt;?&gt;… parameterTypes)</td>
<td align="center">获取指定名称的public修饰的构造方法</td>
</tr>
<tr>
<td align="center">Constructor<T> getDeclaredConstructor(类&lt;?&gt;… parameterTypes)</td>
<td align="center">获取所有的构造方法，不考虑修饰符</td>
</tr>
<tr>
<td align="center">Constructor&lt;?&gt;[] getDeclaredConstructors()</td>
<td align="center">获取指定名称的构造方法，不考虑修饰符</td>
</tr>
</tbody></table>
<ol start="3">
<li>获取成员方法们</li>
</ol>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Method[] getMethods()</td>
<td align="center">获取所有public修饰的成员方法</td>
</tr>
<tr>
<td align="center">Method getMethod(String name, 类&lt;?&gt;… parameterTypes)</td>
<td align="center">获取指定名称的public修饰的成员方法</td>
</tr>
<tr>
<td align="center">Method[] getDeclaredMethods()</td>
<td align="center">获取所有的成员方法，不考虑修饰符</td>
</tr>
<tr>
<td align="center">Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes)</td>
<td align="center">获取指定名称的成员方法，不考虑修饰符</td>
</tr>
</tbody></table>
<ol start="4">
<li>获取全类名    </li>
</ol>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String getName()</td>
<td align="center">获取方法名</td>
</tr>
</tbody></table>
</li>
<li><p>Field：成员变量</p>
<ul>
<li><p>操作：</p>
<ol>
<li><p>设置值</p>
<ul>
<li>void set(Object obj, Object value)  </li>
</ul>
</li>
<li><p>获取值</p>
<ul>
<li>get(Object obj) </li>
</ul>
</li>
<li><p>忽略访问权限修饰符的安全检查</p>
<ul>
<li><strong>setAccessible(true): 暴力反射</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Constructor:构造方法</p>
<ul>
<li>创建对象：<ul>
<li>T newInstance(Object… initargs)  </li>
<li>如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</li>
</ul>
</li>
</ul>
</li>
<li><p>Method：方法对象</p>
<ul>
<li><p>执行方法：</p>
<ul>
<li>Object invoke(Object obj, Object… args)  </li>
</ul>
</li>
<li><p>获取方法名称：</p>
<ul>
<li>String getName:获取方法名</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h3><ul>
<li><p>概念：说明程序的。给计算机看的</p>
</li>
<li><p>注释：用文字描述程序的。给程序员看的</p>
</li>
<li><p>定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p>
</li>
<li><p>概念描述：</p>
<ul>
<li>JDK1.5之后的新特性</li>
<li>说明程序的</li>
<li>使用注解：@注解名称</li>
</ul>
</li>
<li><p>作用分类：<br>  ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】<br>  ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】<br>  ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</p>
</li>
<li><p>JDK中预定义的一些注解</p>
<ul>
<li>@Override    ：检测被该注解标注的方法是否是继承自父类(接口)的</li>
<li>@Deprecated：该注解标注的内容，表示已过时</li>
<li>@SuppressWarnings：压制警告。一般传递参数all  @SuppressWarnings(“all”)</li>
</ul>
</li>
<li><p>自定义注解</p>
<ul>
<li><p>格式：<br>  元注解<br>  public @interface 注解名称{</p>
<pre><code>  属性列表;
</code></pre>
<p>  }</p>
</li>
<li><p>本质：注解本质上就是一个接口，该接口默认继承Annotation接口</p>
<ul>
<li>public interface MyAnno extends java.lang.annotation.Annotation {}</li>
</ul>
</li>
<li><p>属性：接口中的抽象方法</p>
<ul>
<li><p>要求：</p>
<ol>
<li><p>属性的返回值类型有下列取值</p>
<ul>
<li>基本数据类型</li>
<li>String</li>
<li>枚举</li>
<li>注解</li>
<li>以上类型的数组</li>
</ul>
</li>
<li><p>定义了属性，在使用时需要给属性赋值</p>
<ol>
<li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</li>
<li>如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</li>
<li>数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li><p>元注解：用于描述注解的注解</p>
<ul>
<li>@Target：描述注解能够作用的位置<ul>
<li>ElementType取值：<ul>
<li>TYPE：可以作用于类上</li>
<li>METHOD：可以作用于方法上</li>
<li>FIELD：可以作用于成员变量上</li>
</ul>
</li>
</ul>
</li>
<li>@Retention：描述注解被保留的阶段<ul>
<li>@Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</li>
</ul>
</li>
<li>@Documented：描述注解是否被抽取到api文档中</li>
<li>@Inherited：描述注解是否被子类继承</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>在程序使用(解析)注解：获取注解中定义的属性值</p>
<ol>
<li><p>获取注解定义的位置的对象  （Class，Method,Field）</p>
</li>
<li><p>获取指定的注解</p>
<ul>
<li>getAnnotation(Class)<br>//其实就是在内存中生成了一个该注解接口的子类实现对象</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProImpl</span> <span class="keyword">implements</span> <span class="title">Pro</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">className</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;cn.make.annotation.Demo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;show&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用注解中的抽象方法获取配置的属性值</p>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Junit</tag>
        <tag>反射</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>IO流基本知识总结</title>
    <url>/p/42f7140.html</url>
    <content><![CDATA[<h2 id="Java-IO流学习总结"><a href="#Java-IO流学习总结" class="headerlink" title="Java IO流学习总结"></a>Java IO流学习总结</h2><h2 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h2><ul>
<li>根据处理数据类型的不同分为：<strong>字符流</strong>和<strong>字节流</strong></li>
<li>根据数据流向不同分为：<strong>输入流</strong>和<strong>输出流</strong></li>
</ul>
<h3 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h3><p>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 字节流和字符流的区别：</p>
<ul>
<li>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li>
<li>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</li>
</ul>
<p>结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。</p>
<h3 id="输入流和输出流"><a href="#输入流和输出流" class="headerlink" title="输入流和输出流"></a>输入流和输出流</h3><p>以程序本身考虑：</p>
<ul>
<li><p>读操作：使用输入流</p>
</li>
<li><p>写操作：使用输出流</p>
</li>
</ul>
<p>程序中需要根据待传输数据的不同特性而使用不同的流。</p>
<h2 id="Java-IO流对象"><a href="#Java-IO流对象" class="headerlink" title="Java IO流对象"></a>Java IO流对象</h2><h3 id="1-输入字节流InputStream"><a href="#1-输入字节流InputStream" class="headerlink" title="1. 输入字节流InputStream"></a><strong>1. 输入字节流InputStream</strong></h3><ul>
<li>InputStream：这个抽象类是表示字节输入流的所有类的超类</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次读一个</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;.\\fos.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read=fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一次读一个字节数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;.\\fos.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(bytes, <span class="number">0</span> , len));</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BufferedInputStream(InputStream in)：字节缓冲输入流</li>
</ul>
<h3 id="2-输出字节流OutputStream"><a href="#2-输出字节流OutputStream" class="headerlink" title="2.输出字节流OutputStream"></a><strong>2.输出字节流OutputStream</strong></h3><ul>
<li>OutputStream：这个抽象类是表示字节输出流的所有类的超类</li>
</ul>
<p>   字节流写数据的3种方式</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void write(int b)</td>
<td align="center">将指定的字节写入该输出流中</td>
</tr>
<tr>
<td align="center">void write(byte[] b)</td>
<td align="center">写 <code>b.length</code>字节从指定的字节数组的输出流</td>
</tr>
<tr>
<td align="center">void write(byte[] b, int off, int len)</td>
<td align="center">写 <code>len</code>字节指定字节数组中的偏移 <code>off</code>开始到输出流</td>
</tr>
</tbody></table>
<ul>
<li>BufferedOutputStream(OutputStream in)：字节缓冲输出流</li>
</ul>
<h3 id="3-字符输入流Reader"><a href="#3-字符输入流Reader" class="headerlink" title="3. 字符输入流Reader"></a><strong>3. 字符输入流Reader</strong></h3><ul>
<li><p>InputStreamReader：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">InputStreamReader(InputStream in)</td>
<td align="center">创建一个inputstreamreader使用默认字符集</td>
</tr>
<tr>
<td align="center">InputStreamReader(InputStream in, Charset cs)</td>
<td align="center">创建一个inputstreamreader使用给定的字符集</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;.\\osw.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch=isr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>) ch);</span><br><span class="line">&#125;</span><br><span class="line">isr.close();</span><br></pre></td></tr></table></figure></li>
<li><p>字符流读数据的2种方式</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int read()</td>
<td align="center">一次读一个字符数据</td>
</tr>
<tr>
<td align="center">int read(char[] cbuf)</td>
<td align="center">一次读一个字符数组数据</td>
</tr>
</tbody></table>
</li>
<li><p>FileReader：InputStreamReader的简化版，如果需要涉及字符编码，不适合</p>
</li>
<li><p>BufferedReader：字符缓冲输入流</p>
<ul>
<li>特有功能：public String readLine(): 读一行文字。结果包含行的内容的字符串，不包含任何行终止字符，如果流得结尾已经到达，则为null</li>
</ul>
</li>
</ul>
<h3 id="4-字符输出流Writer"><a href="#4-字符输出流Writer" class="headerlink" title="4. 字符输出流Writer"></a><strong>4. 字符输出流Writer</strong></h3><ul>
<li><p>OutputStreamWriter：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OutputStreamWriter(OutputStream out)</td>
<td align="center">创建一个outputstreamwriter使用默认的字符编码</td>
</tr>
<tr>
<td align="center">OutputStreamWriter(OutputStream out, Charset cs)</td>
<td align="center">创建一个outputstreamwriter使用给定的字符集</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;.\\osw.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">osw.write(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">osw.close();</span><br></pre></td></tr></table></figure></li>
<li><p>字符流写数据的5种方式</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void write(int c)</td>
<td align="center">写一个字符</td>
</tr>
<tr>
<td align="center">void write(char[] cbuf)</td>
<td align="center">写一个字符数组</td>
</tr>
<tr>
<td align="center">void write(char[] cbuf,  int off, int len)</td>
<td align="center">写一个字符的一部分</td>
</tr>
<tr>
<td align="center">void write(String str)</td>
<td align="center">写一个字符串</td>
</tr>
<tr>
<td align="center">void write(String str,  int off, int len)</td>
<td align="center">写一个字符串的一部分</td>
</tr>
</tbody></table>
</li>
<li><p>FileWriter：OutputStreamWriter的简化版，如果需要涉及字符编码，不适合。</p>
</li>
<li><p>BufferedWriter：字符缓冲输出流</p>
<ul>
<li><p>特有功能：void newLine():  写一行行分隔符，行分隔符字符串由系统属性定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//根据数据源创建字符缓冲输入流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;.\\1.java&quot;</span>));</span><br><span class="line">        <span class="comment">//根据目的地创建字符缓冲输出流对象</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;.\\copy.java&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读写数据，复制文件</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="5-File类"><a href="#5-File类" class="headerlink" title="5. File类"></a><strong>5. File类</strong></h3><h4 id="5-1-三个构造方法"><a href="#5-1-三个构造方法" class="headerlink" title="5.1 三个构造方法"></a><strong>5.1 三个构造方法</strong></h4><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">File(String pathname)</td>
<td align="center">通过将给定的路径名字符串转换为抽象路径名来创建新的File实例</td>
</tr>
<tr>
<td align="center">File(String parent, String child)</td>
<td align="center">从父路径名字符串和子路径名字符串创建新的File实例</td>
</tr>
<tr>
<td align="center">File(File parent, String child)</td>
<td align="center">从父抽象路径名和子路径名字符串创建新的File实例</td>
</tr>
</tbody></table>
<h4 id="5-2-File类创建功能"><a href="#5-2-File类创建功能" class="headerlink" title="5.2 File类创建功能"></a><strong>5.2 File类创建功能</strong></h4><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public boolean createNewFile()</td>
<td align="center">自动创建一个新的空文件命名的抽象路径名的当且仅当该文件不存在</td>
</tr>
<tr>
<td align="center">public boolean mkdir()</td>
<td align="center">创建该目录下的抽象路径名命名</td>
</tr>
<tr>
<td align="center">public boolean mkdirs()</td>
<td align="center">创建该目录下的抽象路径名命名，包括任何必要的但不存在父目录</td>
</tr>
</tbody></table>
<h4 id="5-3-File类的删除功能"><a href="#5-3-File类的删除功能" class="headerlink" title="5.3 File类的删除功能"></a><strong>5.3 File类的删除功能</strong></h4><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public boolean delete()</td>
<td align="center">删除由此抽象路径名表示的文件或目录</td>
</tr>
</tbody></table>
<p>删除目录时注意事项：</p>
<ul>
<li><p>如果一个目录中有内容（目录或文件），不能直接删除。应该先删除目录中的内容，最后才能删除目录</p>
<h4 id="5-4-File类判断和获取功能"><a href="#5-4-File类判断和获取功能" class="headerlink" title="5.4 File类判断和获取功能"></a><strong>5.4 File类判断和获取功能</strong></h4></li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public boolean isDirectory()</td>
<td align="center">测试文件是否通过这种抽象路径名表示是一个目录</td>
</tr>
<tr>
<td align="center">public boolean isFile()</td>
<td align="center">测试文件是否通过这种抽象路径名表示的是一种正常的文件</td>
</tr>
<tr>
<td align="center">public boolean exists()</td>
<td align="center">检查文件或目录是否存在这种抽象路径名</td>
</tr>
<tr>
<td align="center">public String getAbsolutePath()</td>
<td align="center">返回此抽象路径名的绝对路径名的字符串</td>
</tr>
<tr>
<td align="center">public String getPath()</td>
<td align="center">转换这个抽象路径名为路径名的字符串</td>
</tr>
<tr>
<td align="center">public String getName()</td>
<td align="center">返回的名称的文件或目录的路径名表示的抽象</td>
</tr>
<tr>
<td align="center">public String[] list()</td>
<td align="center">返回的字符串在该目录下的抽象路径名的文件和目录命名为数组</td>
</tr>
<tr>
<td align="center">public File[] listFiles()</td>
<td align="center">返回表示抽象路径名的目录中的文件的路径名表示抽象的数组</td>
</tr>
</tbody></table>
<h4 id="5-5-递归"><a href="#5-5-递归" class="headerlink" title="5.5 递归"></a><strong>5.5 递归</strong></h4><p>递归解决问题要找到两个内容：</p>
<ul>
<li>递归出口：否则会出现内存溢出</li>
<li>递归规则：与原问题相似的规模较小的问题</li>
</ul>
<h2 id="IO流小结"><a href="#IO流小结" class="headerlink" title="IO流小结"></a>IO流小结</h2><p><img src="http://image.xiaoke6.cn/image/blog2012031413373126.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合知识点总结</title>
    <url>/p/1dfa12bb.html</url>
    <content><![CDATA[<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="数组ArraryList"><a href="#数组ArraryList" class="headerlink" title="数组ArraryList"></a>数组ArraryList</h3><p>数组是一种<strong>查询修改快</strong>的模型（对比链表）  </p>
<h3 id="链表LinkedList"><a href="#链表LinkedList" class="headerlink" title="链表LinkedList"></a>链表LinkedList</h3><p>链表是一种<strong>增删快</strong>的模型（对比数组）</p>
<p>特有功能：addFist，addLast，getFirst，getLast，removeFirst，removeLast</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Set集合特点"><a href="#Set集合特点" class="headerlink" title="Set集合特点"></a>Set集合特点</h3><ul>
<li><p>不包含重复元素的集合</p>
</li>
<li><p>没有带索引的方法，不能用普通for循环遍历</p>
</li>
</ul>
<p>HashSet：对集合的迭代顺序不作任何保证</p>
<h3 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h3><p>哈希值：是JDK根据对象的<strong>地址</strong>或者<strong>字符串</strong>或者<strong>数字</strong>算出来的int类型的<strong>数值</strong></p>
<p>Object类中有一个方法可以获取对象的哈希值</p>
<ul>
<li>public int hashCode(): 返回对象的哈希值</li>
</ul>
<p>对象的哈希值特点</p>
<ul>
<li>同一个对象多次调用hashCode()返回的哈希值是相同的</li>
<li>默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同</li>
</ul>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet集合特点</p>
<ul>
<li>底层数据结构是哈希表</li>
<li>对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致</li>
<li>没有带索引的方法，所以不能使用普通的for循环遍历</li>
<li>由于是Set集合，所以是不包含重复元素的集合</li>
</ul>
<p>HashSet集合保证元素唯一性源码分析</p>
<p><img src="http://image.xiaoke6.cn/images/bloghash.png"></p>
<p>HashSet集合存储元素：</p>
<ul>
<li>要保证元素唯一性，需要重写<strong>hashCode()和equals()</strong></li>
</ul>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet集合特点</p>
<ul>
<li>哈希表和链表实现的Set接口，具有可预测的迭代次序</li>
<li>由链表保证元素有序，也就是说元素的存储和取出顺序是一致的</li>
<li>由哈希表保证元素唯一，也就是说没有重复的元素</li>
</ul>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet集合特点</p>
<ul>
<li><p>元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法</p>
<p>TreeSet(): 根据其元素的自然排序进行排序</p>
<p>TreeSet(Comparator comparator): 根据指定的比较器进行排序</p>
</li>
<li><p>没有带索引的方法，所以不能使用普通的for循环遍历</p>
</li>
<li><p>由于是Set集合，所以不包含重复元素的集合</p>
</li>
</ul>
<p>自然排序Comparable的使用</p>
<ul>
<li>用TreeSet集合存储自定义对象，无参构造方法使用的是<strong>自然排序</strong>对元素进行排序的</li>
<li>自然排序，就是让元素所属的类实现Comparable接口，重写comparaTo()方法</li>
<li>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return -1; //-1按照降序，1按照升序，0重复元素不添加</span></span><br><span class="line">        <span class="comment">// 按照年龄从小到大排序,年龄相同，按照姓名字母顺序排序</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="keyword">this</span>.age - s.age;</span><br><span class="line">        <span class="keyword">int</span> num2 = num==<span class="number">0</span>?<span class="keyword">this</span>.name.compareTo(s.name):num;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>比较器排序Comparator的使用</p>
<ul>
<li>用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的</li>
<li>比较器排序，就是让集合构造方法接受Comparator的实现类对象，重写compare(T o1, T o2)方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;Student&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按照年龄从小到大排序,年龄相同，按照姓名字母顺序排序</span></span><br><span class="line">        <span class="comment">//this.age - s.age</span></span><br><span class="line">        <span class="comment">//s1,s1</span></span><br><span class="line">        <span class="keyword">int</span> num = s1.getAge() - s2.getAge();</span><br><span class="line">        <span class="keyword">int</span> num2 = num==<span class="number">0</span>? s1.getName().compareTo(s2.getName()):num;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>




<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><strong>Map集合遍历</strong></p>
<p><strong>方法一：增强for循环中使用entry来遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：在for-each循环中遍历keys或values</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//遍历map中的键</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + key);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//遍历map中的值</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Value = &quot;</span> + value);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：使用Iterator遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> </span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line"> </span><br><span class="line">    Map.Entry&lt;Integer, Integer&gt; entry = entries.next();</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法四：通过键找值遍历（效率低）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line"> </span><br><span class="line">    Integer value = map.get(key);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + key + <span class="string">&quot;, Value = &quot;</span> + value);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>如果仅需要键(keys)或值(values)使用方法二。如果你使用的语言版本低于java 5，或是打算在遍历时删除entries，必须使用方法三。否则使用方法一(键值都要)</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC基础知识总结</title>
    <url>/p/205988e7.html</url>
    <content><![CDATA[<h2 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h2><ol>
<li><p>概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库</p>
</li>
<li><p>JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p>
</li>
<li><p>快速入门：</p>
</li>
</ol>
<ul>
<li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</li>
</ul>
<ol>
<li>复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</li>
<li>右键–&gt;Add As Library</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 导入驱动jar包</span></span><br><span class="line"><span class="comment">//2.注册驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">//3.获取数据库连接对象</span></span><br><span class="line">Connection conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/db&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="comment">//4.定义sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;update account set balance = 500 where id = 1&quot;</span>;</span><br><span class="line"><span class="comment">//5.获取执行sql的对象 Statement</span></span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line"><span class="comment">//6.执行sql</span></span><br><span class="line"><span class="keyword">int</span> count = stmt.executeUpdate(sql);</span><br><span class="line"><span class="comment">//7.处理结果</span></span><br><span class="line">System.out.println(count);</span><br><span class="line"><span class="comment">//8.释放资源</span></span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure>

<h3 id="1-DriverManager：驱动管理对象"><a href="#1-DriverManager：驱动管理对象" class="headerlink" title="1. DriverManager：驱动管理对象"></a>1. DriverManager：驱动管理对象</h3><ul>
<li><p>功能：</p>
<ol>
<li><p><strong>注册驱动：</strong>告诉程序该使用哪一个数据库驱动jar</p>
<pre><code>     static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 
     写代码使用：  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
     通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块
</code></pre>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>获取数据库连接：</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法：static Connection getConnection(String url, String user, String password) </span></span><br><span class="line">	* 参数：</span><br><span class="line">		* url：指定连接的路径</span><br><span class="line">			* 语法：jdbc:mysql:<span class="comment">//ip地址(域名):端口号/数据库名称</span></span><br><span class="line">			* 例子：jdbc:mysql:<span class="comment">//localhost:3306/db3</span></span><br><span class="line">			* 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是<span class="number">3306</span>，则url可以简写为：jdbc:mysql:<span class="comment">///数据库名称</span></span><br><span class="line">		* user：用户名</span><br><span class="line">		* password：密码</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="2-Connection：数据库连接对象"><a href="#2-Connection：数据库连接对象" class="headerlink" title="2. Connection：数据库连接对象"></a>2. Connection：数据库连接对象</h3><ul>
<li>功能：<ol>
<li>获取执行sql 的对象<ul>
<li>Statement createStatement()</li>
<li>PreparedStatement prepareStatement(String sql)  </li>
</ul>
</li>
<li>管理事务：<ul>
<li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</li>
<li>提交事务：commit() </li>
<li>回滚事务：rollback() </li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="3-Statement：执行sql的对象"><a href="#3-Statement：执行sql的对象" class="headerlink" title="3. Statement：执行sql的对象"></a>3. Statement：执行sql的对象</h3><ol>
<li><p>执行sql</p>
<pre><code>     1. boolean execute(String sql) ：可以执行任意的sql 了解 
     2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句
         返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。
     3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句
 2. 练习：
     1. account表 添加一条记录
     2. account表 修改记录
     3. account表 删除一条记录
</code></pre>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  代码：</span></span><br><span class="line">		Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 注册驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2. 定义sql</span></span><br><span class="line">            String sql = <span class="string">&quot;insert into account values(null,&#x27;王五&#x27;,3000)&quot;</span>;</span><br><span class="line">            <span class="comment">//3.获取Connection对象</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///db&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">            <span class="comment">//4.获取执行sql的对象 Statement</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">//5.执行sql</span></span><br><span class="line">            <span class="keyword">int</span> count = stmt.executeUpdate(sql);<span class="comment">//影响的行数</span></span><br><span class="line">            <span class="comment">//6.处理结果</span></span><br><span class="line">            System.out.println(count);</span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;添加成功！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;添加失败！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//stmt.close();</span></span><br><span class="line">            <span class="comment">//7. 释放资源</span></span><br><span class="line">            <span class="comment">//避免空指针异常</span></span><br><span class="line">            <span class="keyword">if</span>(stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-ResultSet：结果集对象-封装查询结果"><a href="#4-ResultSet：结果集对象-封装查询结果" class="headerlink" title="4. ResultSet：结果集对象,封装查询结果"></a>4. ResultSet：结果集对象,封装查询结果</h3><ul>
<li>boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true<pre><code>  * getXxx(参数):获取数据
      * Xxx：代表数据类型   如： int getInt() ,    String getString()
      * 参数：
          1. int：代表列的编号,从1开始   如： getString(1)
          2. String：代表列名称。 如： getDouble(&quot;balance&quot;)
</code></pre>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 注意：</span><br><span class="line">	* 使用步骤：</span><br><span class="line">		<span class="number">1.</span> 游标向下移动一行</span><br><span class="line">		<span class="number">2.</span> 判断是否有数据</span><br><span class="line">		<span class="number">3.</span> 获取数据</span><br><span class="line"></span><br><span class="line">	   <span class="comment">//循环判断游标是否是最后一行末尾。</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            <span class="comment">//获取数据</span></span><br><span class="line">            <span class="keyword">int</span> id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">            String name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="keyword">double</span> balance = rs.getDouble(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(id + <span class="string">&quot;---&quot;</span> + name + <span class="string">&quot;---&quot;</span> + balance);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-PreparedStatement：执行sql的对象"><a href="#5-PreparedStatement：执行sql的对象" class="headerlink" title="5. PreparedStatement：执行sql的对象"></a>5. PreparedStatement：执行sql的对象</h3><ol>
<li><p>SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题</p>
<pre><code> 1. 输入用户随便，输入密码：a&#39; or &#39;a&#39; = &#39;a
 2. sql：select * from user where username = &#39;fhdsjkf&#39; and password = &#39;a&#39; or &#39;a&#39; = &#39;a&#39; 
</code></pre>
</li>
<li><p>解决sql注入问题：使用PreparedStatement对象来解决</p>
</li>
<li><p>预编译的SQL：参数使用?作为占位符</p>
</li>
<li><p>步骤：</p>
<ol>
<li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</li>
<li>注册驱动</li>
<li>获取数据库连接对象 Connection</li>
<li>定义sql<ul>
<li>注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;</li>
</ul>
</li>
<li>获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql) </li>
<li>给?赋值：<pre><code>* 方法： setXxx(参数1,参数2)
    * 参数1：?的位置编号 从1 开始
    * 参数2：?的值
</code></pre>
</li>
<li>执行sql，接受返回结果，不需要传递sql语句</li>
<li>处理结果</li>
<li>释放资源</li>
</ol>
</li>
<li><p>注意：后期都会使用PreparedStatement来完成增删改查的所有操作</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题</span><br><span class="line">	<span class="number">1.</span> 输入用户随便，输入密码：a<span class="string">&#x27; or &#x27;</span>a<span class="string">&#x27; = &#x27;</span>a</span><br><span class="line">	<span class="number">2.</span> sql：select * from user where username = <span class="string">&#x27;fhdsjkf&#x27;</span> and password = <span class="string">&#x27;a&#x27;</span> or <span class="string">&#x27;a&#x27;</span> = <span class="string">&#x27;a&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 解决sql注入问题：使用PreparedStatement对象来解决</span><br><span class="line"><span class="number">3.</span> 预编译的SQL：参数使用?作为占位符</span><br><span class="line"><span class="number">4.</span> 步骤：</span><br><span class="line">	<span class="number">1.</span> 导入驱动jar包 mysql-connector-java-<span class="number">5.1</span><span class="number">.37</span>-bin.jar</span><br><span class="line">	<span class="number">2.</span> 注册驱动</span><br><span class="line">	<span class="number">3.</span> 获取数据库连接对象 Connection</span><br><span class="line">	<span class="number">4.</span> 定义sql</span><br><span class="line">		* 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;</span><br><span class="line">	<span class="number">5.</span> 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql) </span><br><span class="line">	<span class="number">6.</span> 给？赋值：</span><br><span class="line">		* 方法： setXxx(参数<span class="number">1</span>,参数<span class="number">2</span>)</span><br><span class="line">			* 参数<span class="number">1</span>：? 的位置编号 从<span class="number">1</span> 开始</span><br><span class="line">			* 参数<span class="number">2</span>：? 的值</span><br><span class="line">	<span class="number">7.</span> 执行sql，接受返回结果，不需要传递sql语句</span><br><span class="line">	<span class="number">8.</span> 处理结果</span><br><span class="line">	<span class="number">9.</span> 释放资源</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 注意：后期都会使用PreparedStatement来完成增删改查的所有操作</span><br><span class="line">	<span class="number">1.</span> 可以防止SQL注入</span><br><span class="line">	<span class="number">2.</span> 效率更高</span><br></pre></td></tr></table></figure>

<h2 id="JDBC工具类-：-JDBCUtils"><a href="#JDBC工具类-：-JDBCUtils" class="headerlink" title="JDBC工具类 ： JDBCUtils"></a>JDBC工具类 ： JDBCUtils</h2><ul>
<li><p>目的：简化书写</p>
</li>
<li><p>分析：</p>
<ol>
<li>注册驱动也抽取</li>
<li>抽取一个方法获取连接对象<ul>
<li>需求：不想传递参数（麻烦），还得保证工具类的通用性。</li>
<li>解决：配置文件<br>  jdbc.properties<pre><code>  url=
  user=
  password=
</code></pre>
  ​    driver=</li>
</ul>
</li>
<li>抽取一个方法释放资源</li>
</ol>
</li>
<li><p>代码实现：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line">    <span class="comment">// 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">  		<span class="comment">//读取资源文件，获取值。</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//1. 创建Properties集合类。</span></span><br><span class="line">              Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">              <span class="comment">//获取src路径下的文件的方式---&gt;ClassLoader 类加载器</span></span><br><span class="line">              ClassLoader classLoader = JDBCUtils.class.getClassLoader();</span><br><span class="line">              URL res  = classLoader.getResource(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">              String path = res.getPath();</span><br><span class="line">              </span><br><span class="line">              <span class="comment">//2. 加载文件</span></span><br><span class="line">              pro.load(<span class="keyword">new</span> FileReader(path));</span><br><span class="line"></span><br><span class="line">              <span class="comment">//3. 获取数据，赋值</span></span><br><span class="line">              url = pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">              user = pro.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">              password = pro.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">              driver = pro.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">              <span class="comment">//4. 注册驱动</span></span><br><span class="line">              Class.forName(driver);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连接对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 释放资源</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt,Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs,Statement stmt, Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">if</span>( stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;         </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>练习：</p>
<ul>
<li><p>需求：</p>
<ol>
<li>通过键盘录入用户名和密码</li>
<li>判断用户是否登录成功<ul>
<li>select * from user where username = “” and password = “”;</li>
<li>如果这个sql有查询结果，则成功，反之，则失败</li>
</ul>
</li>
</ol>
</li>
<li><p>步骤：</p>
<ol>
<li><p>创建数据库表 user<br> CREATE TABLE USER(</p>
<pre><code> id INT PRIMARY KEY AUTO_INCREMENT,
 username VARCHAR(32),
 PASSWORD VARCHAR(32)
</code></pre>
<p> );</p>
<p> INSERT INTO USER VALUES(NULL,’zhangsan’,’123’);<br> INSERT INTO USER VALUES(NULL,’lisi’,’234’);</p>
</li>
<li><p>代码实现：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.键盘录入，接受用户名和密码</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">        String username = sc.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">        String password = sc.nextLine();</span><br><span class="line">        <span class="comment">//2.调用方法</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">new</span> JDBCDemo().login(username, password);</span><br><span class="line">        <span class="comment">//3.判断结果，输出不同语句</span></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="comment">//登录成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *登录方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String username ,String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(username == <span class="keyword">null</span> || password == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接数据库判断是否登录成功</span></span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt =  <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//1.获取连接</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn =  JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//2.定义sql</span></span><br><span class="line">            String sql = <span class="string">&quot;select * from user where username = &#x27;&quot;</span>+username+<span class="string">&quot;&#x27; and password = &#x27;&quot;</span>+password+<span class="string">&quot;&#x27; &quot;</span>;</span><br><span class="line">            <span class="comment">//3.获取执行sql的对象</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">//4.执行查询</span></span><br><span class="line">            rs = stmt.executeQuery(sql);</span><br><span class="line">            <span class="keyword">return</span> rs.next();<span class="comment">//如果有下一行，则返回true</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(rs,stmt,conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><ol>
<li><p><strong>概念：</strong>其实就是一个容器(集合)，存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</p>
</li>
<li><p>好处：</p>
<ol>
<li>节约资源</li>
<li>用户访问高效</li>
</ol>
</li>
<li><p>实现：</p>
<ol>
<li><p>标准接口：<strong>DataSource</strong>   <strong>javax.sql</strong>包下的</p>
<ol>
<li>方法：<ul>
<li>获取连接：getConnection()</li>
<li>归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接</li>
</ul>
</li>
</ol>
</li>
<li><p>一般我们不去实现它，有数据库厂商来实现</p>
<ol>
<li>C3P0：数据库连接池技术</li>
<li>Druid：数据库连接池实现技术，由阿里巴巴提供的</li>
</ol>
</li>
</ol>
</li>
<li><p>C3P0：数据库连接池技术</p>
<ul>
<li>步骤：<ol>
<li>导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，<ul>
<li>不要忘记导入数据库驱动jar包</li>
</ul>
</li>
<li>定义配置文件：<ul>
<li>名称： c3p0.properties 或者 c3p0-config.xml</li>
<li>路径：直接将文件放在src目录下即可。</li>
</ul>
</li>
<li>创建核心对象 数据库连接池对象 ComboPooledDataSource</li>
<li>获取连接： getConnection</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建数据库连接池对象</span></span><br><span class="line">DataSource ds  = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"><span class="comment">//2. 获取连接对象</span></span><br><span class="line">Connection conn = ds.getConnection();</span><br></pre></td></tr></table></figure></li>
<li><p>Druid：数据库连接池实现技术，由阿里巴巴提供的</p>
<ol>
<li>步骤：<ol>
<li>导入jar包 druid-1.0.9.jar</li>
<li>定义配置文件：<ul>
<li>是properties形式的</li>
<li>可以叫任意名称，可以放在任意目录下</li>
</ul>
</li>
<li>加载配置文件。Properties</li>
<li>获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory</li>
<li>获取连接：getConnection</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.加载配置文件</span></span><br><span class="line">Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">pro.load(is);</span><br><span class="line"><span class="comment">//4.获取连接池对象</span></span><br><span class="line">DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"><span class="comment">//5.获取连接</span></span><br><span class="line">Connection conn = ds.getConnection();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义工具类<pre><code>1. 定义一个类 JDBCUtils
      2. 提供静态代码块加载配置文件，初始化连接池对象
      3. 提供方法
          1. 获取连接方法：通过数据库连接池获取连接
          2. 释放资源
          3. 获取连接池的方法
</code></pre>
</li>
</ol>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.定义成员变量 DataSource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载配置文件</span></span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line">            <span class="comment">//2.获取DataSource</span></span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 释放资源</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt,Connection conn)</span></span>&#123;</span><br><span class="line">        close(<span class="keyword">null</span>,stmt,conn);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs , Statement stmt, Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();<span class="comment">//归还连接</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取连接池方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	    </span><br></pre></td></tr></table></figure>

<h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><ul>
<li><p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p>
</li>
<li><p>步骤：</p>
<ol>
<li><p>导入jar包</p>
</li>
<li><p>创建JdbcTemplate对象。依赖于数据源DataSource</p>
<ul>
<li>JdbcTemplate template = new JdbcTemplate(ds);</li>
</ul>
</li>
<li><p>调用JdbcTemplate的方法来完成CRUD的操作</p>
<ul>
<li>update():执行DML语句。增、删、改语句</li>
<li>queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合<ul>
<li>注意：这个方法查询的结果集长度只能是1</li>
</ul>
</li>
<li>queryForList():查询结果将结果集封装为list集合<ul>
<li>注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</li>
</ul>
</li>
<li>query():查询结果，将结果封装为JavaBean对象<ul>
<li>query的参数：RowMapper<ul>
<li>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</li>
<li>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</li>
</ul>
</li>
</ul>
</li>
<li>queryForObject：查询结果，将结果封装为对象<ul>
<li>一般用于聚合函数的查询</li>
</ul>
</li>
</ul>
</li>
<li><p>练习：    * 需求：</p>
<ol>
<li>修改1号数据的 salary 为 10000</li>
<li>添加一条记录</li>
<li>删除刚才添加的记录</li>
<li>查询id为1的记录，将其封装为Map集合</li>
<li>查询所有记录，将其封装为List</li>
<li>查询所有记录，将其封装为Emp对象的List集合</li>
<li>查询总记录数    </li>
</ol>
</li>
</ol>
</li>
</ul>
<p>​                    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//1. 获取JDBCTemplate对象</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 修改1号数据的 salary 为 10000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;			</span><br><span class="line">    	<span class="comment">//2. 定义sql</span></span><br><span class="line">        String sql = <span class="string">&quot;update emp set salary = 10000 where id = 1001&quot;</span>;</span><br><span class="line">    	<span class="comment">//3. 执行sql</span></span><br><span class="line">        <span class="keyword">int</span> count = template.update(sql);</span><br><span class="line">    	System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">				</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 2. 添加一条记录</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	String sql = <span class="string">&quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;</span>;</span><br><span class="line">    	<span class="keyword">int</span> count = template.update(sql, <span class="number">1015</span>, <span class="string">&quot;郭靖&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    	System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">				</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 3.删除刚才添加的记录</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	String sql = <span class="string">&quot;delete from emp where id = ?&quot;</span>;</span><br><span class="line">    	<span class="keyword">int</span> count = template.update(sql, <span class="number">1015</span>);</span><br><span class="line">    	System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">				</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 4.查询id为1001的记录，将其封装为Map集合</span></span><br><span class="line"><span class="comment">	 * 注意：这个方法查询的结果集长度只能是1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	String sql = <span class="string">&quot;select * from emp where id = ? or id = ?&quot;</span>;</span><br><span class="line">    	Map&lt;String, Object&gt; map = template.queryForMap(sql, <span class="number">1001</span>,<span class="number">1002</span>);</span><br><span class="line">    	System.out.println(map);</span><br><span class="line">    	<span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">        	System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">				</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 6. 查询所有记录，将其封装为Emp对象的List集合</span></span><br><span class="line"><span class="comment">	 */</span>				</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	String sql = <span class="string">&quot;select * from emp&quot;</span>;</span><br><span class="line">   		List&lt;Emp&gt; list = template.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));</span><br><span class="line">    	<span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">        	System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">				</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 7. 查询总记录数</span></span><br><span class="line"><span class="comment">	 */</span>				</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">       String sql = <span class="string">&quot;select count(id) from emp&quot;</span>;</span><br><span class="line">       Long total = template.queryForObject(sql, Long.class);</span><br><span class="line">   	   System.out.println(total);</span><br><span class="line">   &#125;				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>​                       </p>
<h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><ol>
<li><p>事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</p>
</li>
<li><p>操作：</p>
<ol>
<li>开启事务</li>
<li>提交事务</li>
<li>回滚事务</li>
</ol>
</li>
<li><p>使用Connection对象来管理事务</p>
<ul>
<li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务<ul>
<li>在执行sql之前开启事务</li>
</ul>
</li>
<li>提交事务：commit() <ul>
<li>当所有sql都执行完提交事务</li>
</ul>
</li>
<li>回滚事务：rollback() <ul>
<li>在catch中回滚事务</li>
</ul>
</li>
</ul>
</li>
<li><p>代码：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt1 = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取连接</span></span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//开启事务</span></span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.定义sql</span></span><br><span class="line">            <span class="comment">//2.1 张三 - 500</span></span><br><span class="line">            String sql1 = <span class="string">&quot;update account set balance = balance - ? where id = ?&quot;</span>;</span><br><span class="line">            <span class="comment">//2.2 李四 + 500</span></span><br><span class="line">            String sql2 = <span class="string">&quot;update account set balance = balance + ? where id = ?&quot;</span>;</span><br><span class="line">            <span class="comment">//3.获取执行sql对象</span></span><br><span class="line">            pstmt1 = conn.prepareStatement(sql1);</span><br><span class="line">            pstmt2 = conn.prepareStatement(sql2);</span><br><span class="line">            <span class="comment">//4. 设置参数</span></span><br><span class="line">            pstmt1.setDouble(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">            pstmt1.setInt(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            pstmt2.setDouble(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">            pstmt2.setInt(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//5.执行sql</span></span><br><span class="line">            pstmt1.executeUpdate();</span><br><span class="line">            <span class="comment">// 手动制造异常</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            pstmt2.executeUpdate();</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//事务回滚</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    conn.rollback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(pstmt1,conn);</span><br><span class="line">            JDBCUtils.close(pstmt2,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基础知识</title>
    <url>/p/965a836c.html</url>
    <content><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ol>
<li><p>概念： redis是一款高性能的NOSQL系列的非关系型数据库</p>
</li>
<li><p>Redis支持的键值数据类型如下：</p>
<ol>
<li>字符串类型 string</li>
<li>哈希类型 hash</li>
<li>列表类型 list</li>
<li>集合类型 set</li>
<li>有序集合类型 sortedset</li>
</ol>
</li>
<li><p>redis的应用场景</p>
<ul>
<li>缓存（数据查询、短连接、新闻内容、商品内容等等）</li>
<li>聊天室的在线好友列表</li>
<li>任务队列。（秒杀、抢购、12306等等）</li>
<li>应用排行榜</li>
<li>网站访问统计</li>
<li>数据过期处理（可以精确到毫秒）</li>
<li>分布式集群架构中的session分离</li>
</ul>
</li>
<li><p>下载安装</p>
<ul>
<li>官网：<a href="https://redis.io/">https://redis.io</a></li>
<li>中文网：<a href="http://www.redis.net.cn/">http://www.redis.net.cn/</a></li>
<li>解压直接可以使用：<ul>
<li>redis.windows.conf：配置文件</li>
<li>redis-cli.exe：redis的客户端</li>
<li>redis-server.exe：redis服务器端</li>
</ul>
</li>
</ul>
</li>
<li><p>命令操作</p>
<ol>
<li><p>redis的数据结构：</p>
<ul>
<li>redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构</li>
<li>value的数据结构：<pre><code>  1) 字符串类型 string
  2) 哈希类型 hash ： map格式  
  3) 列表类型 list ： linkedlist格式。支持重复元素
  4) 集合类型 set  ： 不允许重复元素
  5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序
</code></pre>
</li>
</ul>
</li>
<li><p>字符串类型 string</p>
<ol>
<li>存储： set key value<br> 127.0.0.1:6379&gt; set username zhangsan<br> OK</li>
<li>获取： get key<br> 127.0.0.1:6379&gt; get username<br> “zhangsan”</li>
<li>删除： del key<br> 127.0.0.1:6379&gt; del age<br> (integer) 1</li>
</ol>
</li>
<li><p>哈希类型 hash</p>
<ol>
<li>存储： hset key field value<br> 127.0.0.1:6379&gt; hset myhash username lisi<br> (integer) 1<br> 127.0.0.1:6379&gt; hset myhash password 123<br> (integer) 1</li>
<li>获取： <ul>
<li>hget key field: 获取指定的field对应的值<br>  127.0.0.1:6379&gt; hget myhash username<br>  “lisi”</li>
<li>hgetall key：获取所有的field和value<br>  127.0.0.1:6379&gt; hgetall myhash<ol>
<li>“username”</li>
<li>“lisi”</li>
<li>“password”</li>
<li>“123”</li>
</ol>
</li>
</ul>
</li>
<li>删除： hdel key field<br> 127.0.0.1:6379&gt; hdel myhash username<br> (integer) 1</li>
</ol>
</li>
<li><p>列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<ol>
<li><p>添加：</p>
<p>​    lpush key value: 将元素加入列表左表</p>
<p>​    rpush key value：将元素加入列表右边</p>
<p>​       127.0.0.1:6379&gt; lpush myList a<br>​        (integer) 1<br>​       127.0.0.1:6379&gt; lpush myList b<br>​       (integer) 2<br>​       127.0.0.1:6379&gt; rpush myList c<br>​       (integer) 3</p>
</li>
<li><p> 获取：</p>
</li>
</ol>
<p>   ​    lrange key start end ：范围获取</p>
<p>   ​      127.0.0.1:6379&gt; lrange myList 0 -1<br>   ​        1) “b”<br>   ​        2) “a”<br>   ​        3) “c”</p>
<ol start="3">
<li><p>删除：</p>
<ul>
<li>lpop key： 删除列表最左边的元素，并将元素返回</li>
<li>rpop key： 删除列表最右边的元素，并将元素返回</li>
</ul>
</li>
</ol>
</li>
<li><p>集合类型 set ： 不允许重复元素</p>
<ol>
<li><p>存储：sadd key value</p>
<p>127.0.0.1:6379&gt; sadd myset a</p>
<p>(integer) 1</p>
<p>127.0.0.1:6379&gt; sadd myset a</p>
<p>(integer) 0</p>
</li>
<li><p>获取：smembers key:获取set集合中所有元素</p>
<p> 127.0.0.1:6379&gt; smembers myset</p>
<p> 1）srem”a”</p>
</li>
<li><p>删除：srem key value:删除set集合中的某个元素</p>
<p> 127.0.0.1:6379&gt; srem myset a</p>
<p> (integer) 1</p>
</li>
</ol>
</li>
<li><p>有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<ol>
<li><p>存储：zadd key score value</p>
<p>127.0.0.1:6379&gt; zadd mysort 60 zhangsan<br>(integer) 1</p>
<p>127.0.0.1:6379&gt; zadd mysort 50 lisi<br>(integer) 1<br>127.0.0.1:6379&gt; zadd mysort 80 wangwu<br>(integer) 1</p>
</li>
<li><p>获取：zrange key start end [withscores]</p>
<p>127.0.0.1:6379&gt; zrange mysort 0 -1</p>
<p>1）”lisi”</p>
<p>2）”zhangsan”</p>
<p>3）”wangwu”</p>
</li>
<li><p>删除：zrem key value</p>
<p>127.0.0.1:6379&gt; zrem mysort lisi<br>(integer) 1</p>
</li>
</ol>
</li>
<li><p>通用命令</p>
<ol>
<li>keys * : 查询所有的键</li>
<li>type key ： 获取键对应的value的类型</li>
<li>del key：删除指定的key value</li>
</ol>
</li>
</ol>
</li>
<li><p>持久化</p>
<ol>
<li><p>redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。</p>
</li>
<li><p>redis持久化机制：</p>
<ol>
<li><p>RDB：默认方式，不需要进行配置，默认就使用这种机制</p>
<ul>
<li><p>在一定的间隔时间中，检测key的变化情况，然后持久化数据</p>
</li>
<li><p>编辑redis.windwos.conf文件        </p>
</li>
</ul>
<p>​      #after 900 sec (15 min) if at least 1 key changed<br>​      save 900 1<br>​      #after 300 sec (5 min) if at least 10 keys changed<br>​       save 300 10<br>​       #after 60 sec if at least 10000 keys changed<br>​       save 60 10000</p>
<ol start="2">
<li>重新启动redis服务器，并指定配置文件名称</li>
</ol>
</li>
<li><p>AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据</p>
<ul>
<li>编辑redis.windwos.conf文件</li>
</ul>
<p>​        #appendfsync always ： 每一次操作都进行持久化<br>​        appendfsync everysec ： 每隔一秒进行一次持久化<br>​        #appendfsync no     ： 不进行持久化</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Java客户端 Jedis</p>
<ul>
<li><p>Jedis: 一款java操作redis数据库的工具.</p>
</li>
<li><p>使用步骤：</p>
<ol>
<li><p>下载jedis的jar包</p>
</li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//2. 操作</span></span><br><span class="line">jedis.set(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"><span class="comment">//3. 关闭连接</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Jedis操作各种redis中的数据结构</p>
<ol>
<li>字符串类型 string</li>
<li>哈希类型 hash ： map格式  </li>
<li>列表类型 list ： linkedlist格式。支持重复元素</li>
<li>集合类型 set  ： 不允许重复元素</li>
<li>有序集合类型 sortedset：不允许重复元素，且元素有顺序</li>
</ol>
</li>
<li><p>jedis连接池： JedisPool</p>
<ul>
<li><p>使用：</p>
<ol>
<li><p>创建JedisPool连接池对象</p>
</li>
<li><p>调用方法 getResource()方法获取Jedis连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0.创建一个配置对象</span></span><br><span class="line">JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">config.setMaxTotal(<span class="number">50</span>);</span><br><span class="line">config.setMaxIdle(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建Jedis连接池对象</span></span><br><span class="line">JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config,<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取连接</span></span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line"><span class="comment">//3. 使用</span></span><br><span class="line">jedis.set(<span class="string">&quot;hehe&quot;</span>,<span class="string">&quot;heihei&quot;</span>);</span><br><span class="line"><span class="comment">//4. 关闭 归还到连接池中</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>连接池工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">			    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line">			</span><br><span class="line">			    <span class="keyword">static</span>&#123;</span><br><span class="line">			        <span class="comment">//读取配置文件</span></span><br><span class="line">			        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jedis.properties&quot;</span>);</span><br><span class="line">			        <span class="comment">//创建Properties对象</span></span><br><span class="line">			        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">			        <span class="comment">//关联文件</span></span><br><span class="line">			        <span class="keyword">try</span> &#123;</span><br><span class="line">			            pro.load(is);</span><br><span class="line">			        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			            e.printStackTrace();</span><br><span class="line">			        &#125;</span><br><span class="line">			        <span class="comment">//获取数据，设置到JedisPoolConfig中</span></span><br><span class="line">			        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">			        config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="string">&quot;maxTotal&quot;</span>)));</span><br><span class="line">			        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="string">&quot;maxIdle&quot;</span>)));</span><br><span class="line">			</span><br><span class="line">			        <span class="comment">//初始化JedisPool</span></span><br><span class="line">			        jedisPool = <span class="keyword">new</span> JedisPool(config,pro.getProperty(<span class="string">&quot;host&quot;</span>),Integer.parseInt(pro.getProperty(<span class="string">&quot;port&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">			     * 获取连接方法</span></span><br><span class="line"><span class="comment">			     */</span></span><br><span class="line">			    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">			        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">			    &#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat、Servlet、Jsp基础知识</title>
    <url>/p/3acd2f08.html</url>
    <content><![CDATA[<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ul>
<li><p>Tomcat：web服务器软件</p>
<ol>
<li>下载：<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></li>
<li>安装：解压压缩包即可。<ul>
<li>注意：安装目录建议不要有中文和空格</li>
</ul>
</li>
<li>卸载：删除目录就行了</li>
<li>启动：</li>
</ol>
<ul>
<li>bin/startup.bat ,双击运行该文件即可</li>
<li>访问：浏览器输入：<a href="http://localhost:8080/">http://localhost:8080</a> </li>
<li>可能遇到的问题：<ol>
<li>黑窗口一闪而过：<ul>
<li>原因： 没有正确配置JAVA_HOME环境变量</li>
<li>解决方案：正确配置JAVA_HOME环境变量</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol start="5">
<li><p>关闭：</p>
<ol>
<li>正常关闭：<ul>
<li>bin/shutdown.bat</li>
<li>ctrl+c</li>
</ul>
</li>
<li>强制关闭：<ul>
<li>点击启动窗口的×</li>
</ul>
</li>
</ol>
</li>
<li><p>配置:</p>
<ul>
<li><p>部署项目的方式：</p>
<ol>
<li><p>直接将项目放到webapps目录下即可。</p>
<ul>
<li>/hello：项目的访问路径–&gt;虚拟目录</li>
<li>简化部署：将项目打成一个war包，再将war包放置到webapps目录下。<ul>
<li>war包会自动解压缩</li>
</ul>
</li>
</ul>
</li>
<li><p>配置conf/server.xml文件<br> 在<Host>标签体中配置</p>
 <Context docBase="D:\hello" path="/hehe" />
 * docBase:项目存放的路径
 * path：虚拟目录</li>
<li><p>在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写</p>
 <Context docBase="D:\hello" />
 * 虚拟目录：xml文件的名称</li>
</ol>
</li>
<li><p>静态项目和动态项目：</p>
<ul>
<li>目录结构<ul>
<li>java动态项目的目录结构：<br>  – 项目的根目录<pre><code>  -- WEB-INF目录：
      -- web.xml：web项目的核心配置文件
      -- classes目录：放置字节码文件的目录
      -- lib目录：放置依赖的jar包
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><ol>
<li><p>被创建：执行init方法，只执行一次</p>
<ul>
<li><p>Servlet什么时候被创建？</p>
<p>默认情况下，第一次被访问时，Servlet被创建</p>
</li>
<li><p>可以配置执行Servlet的创建时机。在<servlet>标签下配置</p>
<ol>
<li>第一次被访问时创建<load-on-startup>的值为负数</li>
<li>在服务器启动时创建<load-on-startup>的值为0或正整数</li>
</ol>
</li>
<li><p>Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的</p>
</li>
<li><p>多个用户同时访问时，可能存在线程安全问题。</p>
</li>
<li><p>尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值</p>
</li>
</ul>
</li>
<li><p>提供服务：执行service方法，执行多次</p>
<ul>
<li>每次访问Servlet时，Service方法都会被调用一次</li>
</ul>
</li>
<li><p>被销毁：执行destroy方法，只执行一次</p>
<ul>
<li><p>Servlet被销毁时执行。服务器关闭时，Servlet被销毁</p>
</li>
<li><p>只有服务器正常关闭时，才会执行destroy方法。</p>
</li>
<li><p>destroy方法在Servlet被销毁之前执行，一般用于释放资源</p>
</li>
</ul>
</li>
<li><p>Servlet3.0：</p>
<ul>
<li><p>好处：支持注解配置。可以不需要web.xml了。</p>
</li>
<li><p>步骤：</p>
<ol>
<li>创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml</li>
<li>定义一个类，实现Servlet接口</li>
<li>复写方法</li>
<li>在类上使用@WebServlet注解，进行配置<ul>
<li>@WebServlet(“资源路径”)</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="Servlet的体系结构"><a href="#Servlet的体系结构" class="headerlink" title="Servlet的体系结构"></a>Servlet的体系结构</h3><p>Servlet – 接口<br>        |<br>GenericServlet – 抽象类<br>        |<br>HttpServlet  – 抽象类</p>
<ul>
<li><p>GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象。将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可</p>
</li>
<li><p>HttpServlet：对http协议的一种封装，简化操作</p>
<ol>
<li>定义类继承HttpServlet</li>
<li>复写doGet/doPost方法</li>
</ol>
</li>
</ul>
<h3 id="RequestHttp协议："><a href="#RequestHttp协议：" class="headerlink" title="RequestHttp协议："></a>RequestHttp协议：</h3><ul>
<li><p>概念：Hyper Text Transfer Protocol 超文本传输协议</p>
<ul>
<li><p>传输协议：定义了，客户端和服务器端通信时，发送数据的格式</p>
</li>
<li><p>特点：</p>
<ol>
<li>基于TCP/IP的高级协议</li>
<li>默认端口号:80</li>
<li>基于请求/响应模型的:一次请求对应一次响应</li>
<li>无状态的：每次请求之间相互独立，不能交互数据</li>
</ol>
</li>
<li><p>历史版本：</p>
<ul>
<li>1.0：每一次请求响应都会建立新的连接</li>
<li>1.1：复用连接</li>
</ul>
</li>
</ul>
</li>
<li><p>请求消息数据格式</p>
<ol>
<li><p>请求行<br> 请求方式 请求url 请求协议/版本<br> GET /login.html    HTTP/1.1</p>
<ul>
<li>请求方式：<ul>
<li>HTTP协议有7中请求方式，常用的有2种<ul>
<li>GET：<ol>
<li>请求参数在请求行中，在url后。</li>
<li>请求的url长度有限制的</li>
<li>不太安全</li>
</ol>
</li>
<li>POST：<ol>
<li>请求参数在请求体中</li>
<li>请求的url长度没有限制的</li>
<li>相对安全</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>请求头：客户端浏览器告诉服务器一些信息<br> 请求头名称: 请求头值</p>
<ul>
<li><p>常见的请求头：</p>
<ol>
<li><p>User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息</p>
<ul>
<li>可以在服务器端获取该头的信息，解决浏览器的兼容性问题</li>
</ul>
</li>
<li><p>Referer：<a href="http://localhost/login.html">http://localhost/login.html</a></p>
<ul>
<li>告诉服务器，我(当前请求)从哪里来？<ul>
<li>作用：<ol>
<li>防盗链：</li>
<li>统计工作：</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>请求空行<br> 空行，就是用于分割POST请求的请求头，和请求体的。</p>
</li>
<li><p>请求体(正文)：</p>
<ul>
<li>封装POST请求消息的请求参数的</li>
<li>字符串格式：</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">POST /login.html	HTTP/<span class="number">1.1</span></span><br><span class="line"><span class="attr">Host</span>: localhost</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">6.1</span>; Win64; x64; rv:<span class="number">60.0</span>) Gecko/<span class="number">20100101</span> Firefox/<span class="number">60.0</span></span><br><span class="line"><span class="attr">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,*<span class="comment">/*;q=0.8</span></span><br><span class="line"><span class="comment">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span></span><br><span class="line"><span class="comment">Accept-Encoding: gzip, deflate</span></span><br><span class="line"><span class="comment">Referer: http://localhost/login.html</span></span><br><span class="line"><span class="comment">Connection: keep-alive</span></span><br><span class="line"><span class="comment">Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">username=zhangsan	</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Request："><a href="#Request：" class="headerlink" title="Request："></a>Request：</h3><ol>
<li><p>request对象和response对象的原理</p>
<ol>
<li>request和response对象是由服务器创建的。我们来使用它们</li>
<li>request对象是来获取请求消息，response对象是来设置响应消息</li>
</ol>
</li>
<li><p>request对象继承体系结构：<br> ServletRequest        –    接口</p>
<pre><code> |    继承
</code></pre>
<p> HttpServletRequest    – 接口</p>
<pre><code> |    实现
</code></pre>
<p> org.apache.catalina.connector.RequestFacade 类(tomcat)</p>
</li>
<li><p>request功能：</p>
<ol>
<li><p>获取请求消息数据</p>
<ol>
<li><p>获取请求行数据</p>
<ul>
<li><p>GET /demo?name=zhangsan HTTP/1.1</p>
</li>
<li><p>方法：</p>
<ol>
<li><p>获取请求方式 ：GET</p>
<ul>
<li>String getMethod()  </li>
</ul>
</li>
<li><p><strong>获取虚拟目录：/day14</strong></p>
<ul>
<li><strong>String getContextPath()</strong></li>
</ul>
</li>
<li><p>获取Servlet路径: /demo1</p>
<ul>
<li>String getServletPath()</li>
</ul>
</li>
<li><p>获取get方式请求参数：name=zhangsan</p>
<ul>
<li>String getQueryString()</li>
</ul>
</li>
<li><p><strong>获取请求URI：/demo</strong></p>
<ul>
<li><p><strong>String getRequestURI():        /demo1</strong></p>
</li>
<li><p><strong>StringBuffer getRequestURL()  :<a href="http://localhost/day14/demo">http://localhost/day14/demo</a></strong></p>
</li>
<li><p><strong>URL:统一资源定位符 ： <a href="http://localhost/demo">http://localhost/demo</a>    中华人民共和国</strong></p>
</li>
<li><p><strong>URI：统一资源标识符 : /demo                    共和国</strong></p>
</li>
</ul>
</li>
<li><p>获取协议及版本：HTTP/1.1</p>
<ul>
<li>String getProtocol()</li>
</ul>
</li>
<li><p>获取客户机的IP地址：</p>
<ul>
<li>String getRemoteAddr()</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>获取请求头数据</p>
<ul>
<li>方法：<ul>
<li><strong>String getHeader(String name):通过请求头的名称获取请求头的值</strong></li>
<li>Enumeration<String> getHeaderNames():获取所有的请求头名称</li>
</ul>
</li>
</ul>
</li>
<li><p>获取请求体数据:</p>
<ul>
<li>请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数</li>
<li>步骤：<ol>
<li>获取流对象<ul>
<li> BufferedReader getReader()：获取字符输入流，只能操作字符数据</li>
<li>ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据<ul>
<li>在文件上传知识点后讲解</li>
</ul>
</li>
</ul>
</li>
<li>再从流对象中拿数据</li>
</ol>
</li>
</ul>
</li>
<li><p>其他功能：</p>
<pre><code> 1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数
     **1. String getParameter(String name):根据参数名称获取参数值    username=zs&amp;password=123**
     **2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game**
     **3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称**
     **4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合**
  2. 中文乱码问题：
  -  get方式：tomcat 8 已经将get方式乱码问题解决了
  - post方式：会乱码
    - 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;);
</code></pre>
</li>
<li><p>请求转发：一种在服务器内部的资源跳转方式</p>
<ol>
<li><p>步骤：</p>
<ol>
<li><strong>通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)</strong></li>
<li><strong>使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response)</strong> </li>
</ol>
</li>
<li><p>特点：</p>
<ol>
<li><p>浏览器地址栏路径不发生变化</p>
</li>
<li><p>只能转发到当前服务器内部资源中。</p>
</li>
<li><p>转发是一次请求</p>
</li>
<li><p>共享数据：</p>
<ul>
<li>域对象：一个有作用范围的对象，可以在范围内共享数据</li>
<li>request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据</li>
<li>方法：<ol>
<li>void setAttribute(String name,Object obj):存储数据</li>
<li>Object getAttitude(String name):通过键获取值</li>
<li>void removeAttribute(String name):通过键移除键值对</li>
</ol>
</li>
</ul>
</li>
<li><p>获取ServletContext：</p>
<ul>
<li>ServletContext getServletContext()</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="ResponseHttp协议："><a href="#ResponseHttp协议：" class="headerlink" title="ResponseHttp协议："></a>ResponseHttp协议：</h3><ol>
<li>请求消息：客户端发送给服务器端的数据<ul>
<li>数据格式：<ol>
<li>请求行</li>
<li>请求头</li>
<li>请求空行</li>
<li>请求体</li>
</ol>
</li>
</ul>
</li>
<li>响应消息：服务器端发送给客户端的数据<ul>
<li>数据格式：<ol>
<li><p>响应行</p>
<ol>
<li>组成：协议/版本 响应状态码 状态码描述</li>
<li>响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。<ol>
<li>状态码都是3位数字 </li>
<li>分类：<ol>
<li>1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码</li>
<li>2xx：成功。代表：200</li>
<li>3xx：重定向。代表：302(重定向)，304(访问缓存)</li>
<li>4xx：客户端错误。<ul>
<li>代表：<ul>
<li>404（请求路径没有对应的资源） </li>
<li>405：请求方式没有对应的doXxx方法</li>
</ul>
</li>
</ul>
</li>
<li>5xx：服务器端错误。代表：500(服务器内部出现异常)</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>响应头：</p>
<pre><code> 1. 格式：头名称： 值
 2. 常见的响应头：
     1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式
     2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据
         * 值：
             * in-line:默认值,在当前页面内打开
             * attachment;filename=xxx：以附件形式打开响应体。文件下载
</code></pre>
<ol start="3">
<li>响应空行</li>
<li>响应体:传输的数据</li>
</ol>
<ul>
<li>响应字符串格式<br>  HTTP/1.1 200 OK<br>  Content-Type: text/html;charset=UTF-8<br>  Content-Length: 101<br>  Date: Wed, 06 Jun 2018 07:08:42 GMT  <html>
  
<pre><code>&lt;head&gt;
  &lt;title&gt;$Title$&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
hello , response
&lt;/body&gt;
</code></pre>
  </html></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="Response："><a href="#Response：" class="headerlink" title="Response："></a>Response：</h3><ul>
<li><p>功能：设置响应消息</p>
<ol>
<li><p>设置响应行</p>
<ol>
<li>格式：HTTP/1.1 200 ok</li>
<li>设置状态码：setStatus(int sc) </li>
</ol>
</li>
<li><p>设置响应头：setHeader(String name, String value) </p>
</li>
<li><p>设置响应体：</p>
<ul>
<li><p>使用步骤：</p>
<ol>
<li><p>获取输出流</p>
<ul>
<li><p>字符输出流：PrintWriter getWriter()</p>
</li>
<li><p>字节输出流：ServletOutputStream getOutputStream()</p>
</li>
</ul>
</li>
<li><p>使用输出流，将数据输出到客户端浏览器</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>案例：</p>
<ol>
<li>完成重定向<ul>
<li><p>重定向：资源跳转的方式</p>
</li>
<li><p>代码实现：<br>   //1. 设置状态码为302<br>  response.setStatus(302);<br>  //2.设置响应头location<br>  response.setHeader(“location”,  request.getContextPath() + “/responseDemo2”);</p>
<p> //简单的重定向方法<br> response.sendRedirect(request.getContextPath() + “/responseDemo2”);</p>
</li>
<li><p>重定向的特点:redirect</p>
<ol>
<li>地址栏发生变化</li>
<li> 重定向可以访问其他站点(服务器)的资源</li>
<li> 重定向是两次请求。不能使用request对象来共享数据</li>
</ol>
</li>
<li><p>转发的特点：forward</p>
<ol>
<li>转发地址栏路径不变</li>
<li>转发只能访问当前服务器下的资源</li>
<li>转发是一次请求，可以使用request对象来共享数据</li>
</ol>
</li>
<li><p>forward 和  redirect 区别</p>
</li>
<li><p>路径写法：</p>
<pre><code>  1. 路径分类
      1. 相对路径：通过相对路径不可以确定唯一资源
          * 如：./index.html
          * 不以/开头，以.开头路径
      * 规则：找到当前资源和目标资源之间的相对位置关系
        - ./：当前目录
        - ../:后退一级目录
      2. 绝对路径：通过绝对路径可以确定唯一资源
      - 如：http://localhost/JavaWeb/responseDemo2        /JavaWeb/responseDemo2
      - 以/开头的路径
      - 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出
        - 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)
          - 建议虚拟目录动态获取：request.getContextPath()
          - &lt;a&gt; , &lt;form&gt; 重定向...
        - 给服务器使用：不需要加虚拟目录
          - 转发路径
  
  2. 服务器输出字符数据到浏览器
      * 步骤：
          1. 获取字符输出流
          2. 输出数据
      
  * 注意：
  
       - 乱码问题：
  
         1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1
  
         2. 设置该流的默认编码
  
         3. 告诉浏览器响应体使用的编码
  
            <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单的形式，设置编码，是在获取流之前设置</span></span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);		</span><br></pre></td></tr></table></figure>
  
  3. 服务器输出字节数据到浏览器
      * 步骤：
          1. 获取字节输出流
          2. 输出数据
  
  4. 验证码
      1. 本质：图片
      2. 目的：防止恶意表单注册
</code></pre>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="ServletContext对象："><a href="#ServletContext对象：" class="headerlink" title="ServletContext对象："></a>ServletContext对象：</h3><ol>
<li><p>概念：代表整个web应用，可以和程序的容器(服务器)来通信</p>
</li>
<li><p>获取：</p>
<ol>
<li>通过request对象获取<br> request.getServletContext();</li>
<li>通过HttpServlet获取<br> this.getServletContext();</li>
</ol>
</li>
<li><p>功能：</p>
</li>
<li><p>获取MIME类型：</p>
<ul>
<li>MIME类型:在互联网通信过程中定义的一种文件数据类型<ul>
<li>格式： 大类型/小类型   text/html        image/jpeg</li>
</ul>
</li>
<li>获取：String getMimeType(String file)  </li>
</ul>
</li>
<li><p>域对象：共享数据</p>
<ol>
<li>setAttribute(String name,Object value)</li>
<li>getAttribute(String name)</li>
<li>removeAttribute(String name)</li>
</ol>
<ul>
<li>ServletContext对象范围：所有用户所有请求的数据</li>
</ul>
</li>
<li><p>获取文件的真实(服务器)路径</p>
</li>
</ol>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法：String getRealPath(String path)  </span></span><br><span class="line">String b = context.getRealPath(<span class="string">&quot;/b.txt&quot;</span>);<span class="comment">//web目录下资源访问</span></span><br><span class="line"></span><br><span class="line">String c = context.getRealPath(<span class="string">&quot;/WEB-INF/c.txt&quot;</span>);<span class="comment">//WEB-INF目录下的资源访问</span></span><br><span class="line"></span><br><span class="line">String a = context.getRealPath(<span class="string">&quot;/WEB-INF/classes/a.txt&quot;</span>);<span class="comment">//src目录下的资源访问</span></span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a>Cookie：</h3><ol>
<li><p>概念：客户端会话技术，将数据保存到客户端</p>
</li>
<li><p>快速入门：</p>
<ul>
<li>使用步骤：<ol>
<li>创建Cookie对象，绑定数据<ul>
<li>new Cookie(String name, String value) </li>
</ul>
</li>
<li>发送Cookie对象<ul>
<li>response.addCookie(Cookie cookie) </li>
</ul>
</li>
<li>获取Cookie，拿到数据<ul>
<li>Cookie[]  request.getCookies()  </li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>实现原理</p>
<ul>
<li>基于响应头set-cookie和请求头cookie实现</li>
</ul>
</li>
<li><p>cookie的细节</p>
<ol>
<li><p>一次可不可以发送多个cookie?</p>
<p>可以，可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可</p>
</li>
<li><p>cookie在浏览器中保存多长时间？</p>
<p>默认情况下，当浏览器关闭后，Cookie数据被销毁。</p>
<p><strong>setMaxAge(int seconds)</strong></p>
<pre><code>    1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效
    2. 负数：默认值
    3. 零：删除cookie信息
</code></pre>
</li>
<li><p>cookie能不能存中文？</p>
<p>在tomcat 8 之前 cookie中不能直接存储中文数据。需要将中文数据转码—一般采用URL编码(%E3)</p>
<p>在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析</p>
</li>
<li><p>cookie共享问题？</p>
</li>
<li><p>假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？</p>
</li>
</ol>
</li>
</ol>
<ol start="4">
<li><p>cookie共享问题？</p>
<ol>
<li><p>假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？</p>
<ul>
<li><p>默认情况下cookie不能共享。</p>
</li>
<li><p>setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录</p>
</li>
<li><p>如果要共享，则可以将path设置为”/“</p>
</li>
</ul>
</li>
<li><p>不同的tomcat服务器间cookie共享问题？</p>
<ul>
<li>setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享</li>
<li>setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享</li>
</ul>
</li>
</ol>
</li>
<li><p>Cookie的特点和作用</p>
<ol>
<li><p>cookie存储数据在客户端浏览器</p>
</li>
<li><p>浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)</p>
</li>
<li><p>作用：</p>
<ul>
<li><p>cookie一般用于存出少量的不太敏感的数据</p>
</li>
<li><p>在不登录的情况下，完成服务器对客户端的身份识别</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="Session："><a href="#Session：" class="headerlink" title="Session："></a>Session：</h3><ol>
<li><p>概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</p>
</li>
<li><p>快速入门：</p>
<ol>
<li>获取HttpSession对象：<br> HttpSession session = request.getSession();</li>
<li>使用HttpSession对象：<br> Object getAttribute(String name)<br> void setAttribute(String name, Object value)<br> void removeAttribute(String name)  </li>
</ol>
</li>
<li><p>原理</p>
<ul>
<li>Session的实现是依赖于Cookie的。</li>
</ul>
</li>
<li><p>细节：</p>
<ol>
<li><p>当客户端关闭后，服务器不关闭，两次获取session是否为同一个？</p>
<ul>
<li>默认情况下。不是。</li>
<li>如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。<br>   Cookie c = new Cookie(“JSESSIONID”,session.getId());<br>   c.setMaxAge(60*60);<br>   response.addCookie(c);</li>
</ul>
</li>
<li><p>客户端不关闭，服务器关闭后，两次获取的session是同一个吗？</p>
<ul>
<li>不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作<ul>
<li>session的钝化：<ul>
<li>在服务器正常关闭之前，将session对象系列化到硬盘上</li>
</ul>
</li>
<li>session的活化：<ul>
<li>在服务器启动后，将session文件转化为内存中的session对象即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>session什么时候被销毁？</p>
<ol>
<li>服务器关闭</li>
<li>session对象调用invalidate() 。</li>
<li>session默认失效时间 30分钟<br> 选择性配置修改     <session-config>
     <session-timeout>30</session-timeout>
 </session-config></li>
</ol>
</li>
</ol>
</li>
<li><p>session的特点</p>
<ol>
<li>session用于存储一次会话的多次请求的数据，存在服务器端</li>
<li>session可以存储任意类型，任意大小的数据</li>
</ol>
<ul>
<li>session与Cookie的区别：<ol>
<li>session存储数据在服务器端，Cookie在客户端</li>
<li>session没有数据大小限制，Cookie有</li>
<li>session数据安全，Cookie相对于不安全</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="Filter：过滤器"><a href="#Filter：过滤器" class="headerlink" title="Filter：过滤器"></a>Filter：过滤器</h2><ol>
<li><p>概念：</p>
<ul>
<li>生活中的过滤器：净水器,空气净化器，土匪、</li>
<li>web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。</li>
<li>过滤器的作用：<ul>
<li>一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤…</li>
</ul>
</li>
</ul>
</li>
<li><p>快速入门：</p>
<ol>
<li>步骤：<ol>
<li>定义一个类，实现接口Filter</li>
<li>复写方法</li>
<li>配置拦截路径<ol>
<li>web.xml</li>
<li>注解</li>
</ol>
</li>
</ol>
</li>
<li>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span><span class="comment">//访问所有资源之前，都会执行该过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterDemo1</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filterDemo1被执行了....&quot;</span>);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>过滤器细节：</p>
<ol>
<li>web.xml配置</li>
</ol>
   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.make.web.filter.FilterDemo1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!-- 拦截路径 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>过滤器执行流程</li>
<li>执行过滤器</li>
<li>执行放行后的资源</li>
<li>回来执行过滤器放行代码下边的代码</li>
<li>过滤器生命周期方法</li>
<li>init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源</li>
<li>doFilter:每一次请求被拦截资源时，会执行。执行多次</li>
<li>destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源</li>
<li>过滤器配置详解</li>
</ol>
<ul>
<li>拦截路径配置：<ol>
<li>具体资源路径： /index.jsp   只有访问index.jsp资源时，过滤器才会被执行</li>
<li>拦截目录： /user/*    访问/user下的所有资源时，过滤器都会被执行</li>
<li>后缀名拦截： *.jsp        访问所有后缀名为jsp资源时，过滤器都会被执行</li>
<li>拦截所有资源：/*        访问所有资源时，过滤器都会被执行</li>
</ol>
</li>
<li>拦截方式配置：资源被访问的方式<ul>
<li>注解配置：<ul>
<li>设置dispatcherTypes属性<ol>
<li>REQUEST：默认值。浏览器直接请求资源</li>
<li>FORWARD：转发访问资源</li>
<li>INCLUDE：包含访问资源</li>
<li>ERROR：错误跳转资源</li>
<li>ASYNC：异步访问资源</li>
</ol>
</li>
</ul>
</li>
<li>web.xml配置<ul>
<li>设置<dispatcher></dispatcher>标签即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="5">
<li>过滤器链(配置多个过滤器)</li>
</ol>
<ul>
<li>执行顺序：如果有两个过滤器：过滤器1和过滤器2<ol>
<li>过滤器1</li>
<li>过滤器2</li>
<li>资源执行</li>
<li>过滤器2</li>
<li>过滤器1 </li>
</ol>
</li>
<li>过滤器先后顺序问题：<ol>
<li>注解配置：按照类名的字符串比较规则比较，值小的先执行<ul>
<li>如： AFilter 和 BFilter，AFilter就先执行了。</li>
</ul>
</li>
<li>web.xml配置： <filter-mapping>谁定义在上边，谁先执行</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="Listener：监听器"><a href="#Listener：监听器" class="headerlink" title="Listener：监听器"></a>Listener：监听器</h2><ul>
<li><p>概念：web的三大组件之一。</p>
<ul>
<li>事件监听机制<ul>
<li>事件    ：一件事情</li>
<li>事件源 ：事件发生的地方</li>
<li>监听器 ：一个对象</li>
<li>注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码</li>
</ul>
</li>
</ul>
</li>
<li><p>ServletContextListener:监听ServletContext对象的创建和销毁</p>
<ul>
<li>方法：<ul>
<li>void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法</li>
<li>void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法</li>
</ul>
</li>
<li>步骤：<ol>
<li>定义一个类，实现ServletContextListener接口</li>
<li>复写方法</li>
<li>配置<ol>
<li>web.xml<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>cn.make.web.listener.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>指定初始化参数<context-param></li>
</ul>
</li>
<li>注解：<ul>
<li>@WebListener</li>
</ul>
<listener></li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="Jsp"><a href="#Jsp" class="headerlink" title="Jsp"></a>Jsp</h2><ol>
<li>概念：<ul>
<li>Java Server Pages： java服务器端页面<ul>
<li>可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码</li>
<li>用于简化书写！！！</li>
</ul>
</li>
</ul>
</li>
<li>原理<ul>
<li>JSP本质上就是一个Servlet</li>
</ul>
</li>
<li>JSP的脚本：JSP定义Java代码的方式<ol>
<li>&lt;%  代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。</li>
<li>&lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。</li>
<li>&lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。</li>
</ol>
</li>
<li>JSP的内置对象：<ul>
<li>在jsp页面中不需要获取和创建，可以直接使用的对象</li>
<li>jsp一共有9个内置对象。</li>
</ul>
</li>
</ol>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul>
<li>作用：用于配置JSP页面，导入资源文件<ul>
<li>格式：<br>  &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 … %&gt;</li>
<li>分类：<ol>
<li>page： 配置JSP页面的<ul>
<li>contentType：等同于response.setContentType()<ol>
<li>设置响应体的mime类型以及字符集</li>
<li>设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）</li>
</ol>
</li>
<li>import：导包</li>
<li>errorPage：当前页面发生异常后，会自动跳转到指定的错误页面</li>
<li>isErrorPage：标识当前也是是否是错误页面。<ul>
<li>true：是，可以使用内置对象exception</li>
<li>false：否。默认值。不可以使用内置对象exception</li>
</ul>
</li>
</ul>
</li>
<li>include： 页面包含的。导入页面的资源文件<ul>
<li>&lt;%@include file=”top.jsp”%&gt;</li>
</ul>
</li>
<li>taglib： 导入资源<ul>
<li>&lt;%@ taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;">http://java.sun.com/jsp/jstl/core&quot;</a> %&gt;</li>
<li>prefix：前缀，自定义的</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol>
<li>html注释：<pre><code> &lt;!-- --&gt;:只能注释html代码片段
</code></pre>
</li>
<li>jsp注释：推荐使用<pre><code> &lt;%-- --%&gt;：可以注释所有
</code></pre>
</li>
</ol>
<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><ul>
<li><p>在jsp页面中不需要创建，直接使用的对象</p>
<ul>
<li><p>一共有9个：</p>
<table>
<thead>
<tr>
<th align="center">变量名</th>
<th align="center">真实类型</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pageContext</td>
<td align="center">PageContext</td>
<td align="center">当前页面共享数据，还可以获取其他八个内置对象</td>
</tr>
<tr>
<td align="center">request</td>
<td align="center">HttpServletRequest</td>
<td align="center">一次请求访问的多个资源(转发)</td>
</tr>
<tr>
<td align="center">session</td>
<td align="center">HttpSession</td>
<td align="center">一次会话的多个请求间</td>
</tr>
<tr>
<td align="center">application</td>
<td align="center">ServletContext</td>
<td align="center">所有用户间共享数据</td>
</tr>
<tr>
<td align="center">response</td>
<td align="center">HttpServletResponse</td>
<td align="center">响应对象</td>
</tr>
<tr>
<td align="center">page</td>
<td align="center">Object</td>
<td align="center">当前页面(Servlet)的对象  this</td>
</tr>
<tr>
<td align="center">out</td>
<td align="center">JspWriter</td>
<td align="center">输出对象，数据输出到页面上</td>
</tr>
<tr>
<td align="center">config</td>
<td align="center">ServletConfig</td>
<td align="center">Servlet的配置对象</td>
</tr>
<tr>
<td align="center">exception</td>
<td align="center">Throwable</td>
<td align="center">异常对象</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h3><ol>
<li><p>概念：Expression Language 表达式语言</p>
</li>
<li><p>作用：替换和简化jsp页面中java代码的编写</p>
</li>
<li><p>语法：${表达式}</p>
</li>
<li><p>注意：</p>
<ul>
<li>jsp默认支持el表达式的。如果要忽略el表达式<ol>
<li>设置jsp中page指令中：isELIgnored=”true” 忽略当前jsp页面中所有的el表达式</li>
<li>${表达式} ：忽略当前这个el表达式</li>
</ol>
</li>
</ul>
</li>
<li><p>使用：</p>
<ol>
<li><p>运算：</p>
<ul>
<li>运算符：<ol>
<li>算数运算符： + - * /(div) %(mod)</li>
<li>比较运算符： &gt; &lt; &gt;= &lt;= == !=</li>
<li>逻辑运算符： &amp;&amp;(and) ||(or) !(not)</li>
<li>空运算符： empty<ul>
<li>功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0</li>
<li>${empty list}:判断字符串、集合、数组对象是否为null或者长度为0</li>
<li>${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>获取值</p>
<ol>
<li><p>el表达式只能从域对象中获取值</p>
</li>
<li><p>语法：</p>
<ol>
<li><p>${域名称.键名}：从指定域中获取指定键的值</p>
<ul>
<li>域名称：<ol>
<li>pageScope        –&gt; pageContext</li>
<li>requestScope     –&gt; request</li>
<li>sessionScope     –&gt; session</li>
<li>applicationScope –&gt; application（ServletContext）</li>
</ol>
</li>
<li>举例：在request域中存储了name=张三</li>
<li>获取：${requestScope.name}</li>
</ul>
</li>
<li><p>${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。</p>
</li>
<li><p>获取对象、List集合、Map集合的值</p>
<pre><code>1. 对象：$&#123;域名称.键名.属性名&#125;
            * 本质上会去调用对象的getter方法
2. List集合：$&#123;域名称.键名[索引]&#125;
3. Map集合：
- $&#123;域名称.键名.key名称&#125;
- $&#123;域名称.键名[&quot;key名称&quot;]&#125;
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
<li><p>隐式对象：</p>
<ul>
<li>el表达式中有11个隐式对象</li>
<li>pageContext：<ul>
<li>获取jsp其他八个内置对象<ul>
<li>${pageContext.request.contextPath}：动态获取虚拟目录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="JSTL标签"><a href="#JSTL标签" class="headerlink" title="JSTL标签"></a>JSTL标签</h3><ol>
<li><p>概念：JavaServer Pages Tag Library  JSP标准标签库</p>
<ul>
<li>是由Apache组织提供的开源的免费的jsp标签        &lt;标签&gt;</li>
</ul>
</li>
<li><p>作用：用于简化和替换jsp页面上的java代码        </p>
</li>
<li><p>使用步骤：</p>
<ol>
<li>导入jstl相关jar包</li>
<li>引入标签库：taglib指令：  &lt;%@ taglib %&gt;</li>
<li>使用标签</li>
</ol>
</li>
<li><p>常用的JSTL标签</p>
<ol>
<li>if:相当于java代码的if语句<ol>
<li>属性：<ul>
<li>test 必须属性，接受boolean表达式<ul>
<li>如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容</li>
<li>一般情况下，test属性值会结合el表达式一起使用</li>
</ul>
</li>
</ul>
</li>
<li>注意：<ul>
<li>c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签     </li>
</ul>
</li>
</ol>
</li>
<li>choose:相当于java代码的switch语句<ol>
<li>使用choose标签声明                     相当于switch声明</li>
<li>使用when标签做判断                     相当于case</li>
<li>使用otherwise标签做其他情况的声明        相当于default</li>
</ol>
</li>
<li>foreach:相当于java代码的for语句</li>
</ol>
</li>
</ol>
<h2 id="MVC开发模式"><a href="#MVC开发模式" class="headerlink" title="MVC开发模式"></a>MVC开发模式</h2><ol>
<li><p>jsp演变历史</p>
<ol>
<li>早期只有servlet，只能使用response输出标签数据，非常麻烦</li>
<li>后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作</li>
<li>再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性</li>
</ol>
</li>
<li><p>MVC：</p>
</li>
<li><p>M：Model，模型。JavaBean</p>
<ul>
<li>完成具体的业务操作，如：查询数据库，封装对象</li>
</ul>
</li>
<li><p>V：View，视图。JSP</p>
<ul>
<li>展示数据</li>
</ul>
</li>
<li><p>C：Controller，控制器。Servlet</p>
<ul>
<li>获取用户的输入</li>
<li>调用模型</li>
<li>将数据交给视图进行展示</li>
</ul>
</li>
</ol>
<ul>
<li>优缺点：<pre><code> 1. 优点：
 1. 耦合性低，方便维护，可以利于分工协作
 2. 重用性高
      2. 缺点：
 1. 使得项目架构变得复杂，对开发人员要求高
</code></pre>
</li>
</ul>
<h2 id="三层架构：软件设计架构"><a href="#三层架构：软件设计架构" class="headerlink" title="三层架构：软件设计架构"></a>三层架构：软件设计架构</h2><ol>
<li>界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互</li>
<li>业务逻辑层：处理业务逻辑的。</li>
<li>数据访问层：操作数据存储文件。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>Servlet</tag>
        <tag>Jsp</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程知识点总结</title>
    <url>/p/66e505b.html</url>
    <content><![CDATA[<h2 id="多线程知识总结"><a href="#多线程知识总结" class="headerlink" title="多线程知识总结"></a>多线程知识总结</h2><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>进程：是一个正在运行的程序</p>
<ul>
<li>是系统进行资源分配和调用的独立单位</li>
<li>每一个进程都有它自己的内存空间和系统资源</li>
</ul>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程：是进程中的单个顺序控制流，是一条执行的路径</p>
<ul>
<li>单线程：一个程序如果只有一条执行的路径，则成为单线程程序</li>
<li>多线程：一个程序如果有多条执行的路径，则成为多线程程序</li>
</ul>
<h2 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h2><h3 id="方式1：继承Thread类"><a href="#方式1：继承Thread类" class="headerlink" title="方式1：继承Thread类"></a>方式1：继承Thread类</h3><ul>
<li>定义一个类MyThread继承Thread类</li>
<li>在MyThread类中重写run()方法</li>
<li>创建MyThread类的对象</li>
<li>启动线程</li>
</ul>
<h3 id="方式2：实现Runnable接口"><a href="#方式2：实现Runnable接口" class="headerlink" title="方式2：实现Runnable接口"></a>方式2：实现Runnable接口</h3><ul>
<li>定义一个类MyRunnable实现Runnable接口</li>
<li>在MyRunnable类中重写run()方法</li>
<li>创建MyRunnable类的对象</li>
<li>创建Thread类的对象，把MyRunnable对象作为构造方法的参数</li>
<li>启动线程</li>
</ul>
<p>相比继承Thread类，实现Runnable接口的好处:</p>
<ul>
<li>避免了Java单继承的局限性</li>
<li>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</li>
</ul>
<p>线程两种调度模型：</p>
<ul>
<li><p>分时调度模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片</p>
</li>
<li><p>抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机一个，优先级高的线程获取的CPU时间片相对多一些</p>
<p>多线程程序的执行是有随机性的，因为谁抢到CPU使用权是不一定的。</p>
</li>
</ul>
<p>Thread类中设置和获取线程优先级的方法</p>
<ul>
<li><p>getPriority()：返回此线程的优先级</p>
</li>
<li><p>setPriority()：更改此线程的优先级</p>
<p>线程默认优先级是<strong>5</strong>；线程优先级的范围是：<strong>1-10</strong></p>
<p>线程优先级高仅仅表示获取的CPU时间片的几率高</p>
</li>
</ul>
<h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">static void sleep(long millis)</td>
<td align="center">使用当前正在执行的线程停留（暂停执行）指定的毫秒数</td>
</tr>
<tr>
<td align="center">void join()</td>
<td align="center">等待这个线程死亡</td>
</tr>
<tr>
<td align="center">void setDaemon(boolean on)</td>
<td align="center">将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出</td>
</tr>
</tbody></table>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xfnihao.cn%2Fupload%2F2020%2F4%2Fimage-3c19d0b1afc1478f8f9d4e8fd304265c.png&refer=http%3A%2F%2Fwww.xfnihao.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643890180&t=3d49254cf84beaacd778653a950edf46"></p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>同步代码块：锁多条语句操作共享数据，可以使用同步代码块实现</p>
<ul>
<li><p>格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>()&#123;</span><br><span class="line">	多条语句操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成1一把锁</p>
</li>
</ul>
<p>同步的好处和弊端：</p>
<ul>
<li>好处：解决了多线程的数据安全问题</li>
<li>弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很消耗资源的，无形中就会降低程序的运行效率</li>
</ul>
<p>同步方法：就是把synchronized关键字加到方法上</p>
<ul>
<li><p>格式</p>
<p>修饰符 synchronized 返回值类型 方法名(参数){ }</p>
</li>
</ul>
<p>同步方法的锁对象是什么呢？</p>
<ul>
<li>  <strong>this</strong></li>
</ul>
<p>同步静态方法：就是把synchronized关键字加到静态方法上</p>
<ul>
<li><p>格式：</p>
<p>修饰符 static synchronized 返回值类型 方法名(参数){ }</p>
</li>
</ul>
<p>同步静态方法的锁对象是什么呢？</p>
<ul>
<li><strong>类名.class</strong></li>
</ul>
<p>线程安全的类：StringBuffer、Vector、Hashtable</p>
<p><strong>StringBuffer</strong></p>
<ul>
<li><p>线程安全，可变的字符序列</p>
</li>
<li><p>从JDK 5开始，被StringBuilder替代。通常应该使用StringBuilder类，因为它支持所有相同的操作，但它的速度更快，因为它不进行同步</p>
</li>
</ul>
<p><strong>Vector</strong></p>
<ul>
<li>从java 2平台V1.2，该类改进了List接口，使其成为Java Collections  Framework成员。Vector是同步的。如果一个线程安全的实现是不需要的，建议使用ArrayList代替Vector</li>
</ul>
<p><strong>Hashtable</strong></p>
<ul>
<li><p>该类实现了一个哈希表，它将键映射到值。任何非null对象都可以用作键或者值</p>
</li>
<li><p>作为java 2平台V1.2，该类改进了Map接口，使其成为 Java Collections  Framework成员。Hashtable是同步的。如果一个线程安全的实现是不需要的，建议使用HashMap代替Hashtable</p>
</li>
</ul>
<h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p>Lock中提供了获得锁和释放锁的方法</p>
<ul>
<li>void lock()：获得锁</li>
<li>void unlock()：释放锁</li>
</ul>
<p>Lock是接口不能直接实例化，这里采取它的实现类ReentrantLock来实例化</p>
<p>ReentrantLock的构造方法</p>
<ul>
<li>ReentrantLock()：创建一个ReentrantLock的实例</li>
</ul>
<h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2><p>为了体现生产和消费过程中的等待和唤醒，Java就提供了几个方法供我们使用，这几个方法在Object类中</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void wait()</td>
<td align="center">导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法</td>
</tr>
<tr>
<td align="center">void notify()</td>
<td align="center">唤醒正在等待对象监视器的单个线程</td>
</tr>
<tr>
<td align="center">void notifyAll()</td>
<td align="center">唤醒正在等待对象监视器的所有线程</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程基础知识</title>
    <url>/p/76d9b2bc.html</url>
    <content><![CDATA[<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h3 id="三要素：ip-端口-协议"><a href="#三要素：ip-端口-协议" class="headerlink" title="三要素：ip+端口+协议"></a>三要素：ip+端口+协议</h3><p><strong>IP地址</strong></p>
<ul>
<li>要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号，也就是设备的标识</li>
<li>InetAddress的使</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">static InetAddress getByName(String host)</td>
<td align="center">确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址</td>
</tr>
<tr>
<td align="center">String getHostName()</td>
<td align="center">获取此IP地址的主机名</td>
</tr>
<tr>
<td align="center">String getHostAddress()</td>
<td align="center">返回文本显示中的IP地址字符串</td>
</tr>
</tbody></table>
<p><strong>端口</strong></p>
<ul>
<li>网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序。那么在网络通信时，如何区分这些应用程序呢？如果IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识</li>
<li>端口号：取值范围0<del>65535。其中0</del>1023之间的端口号用于一些知名的网络服务和应用，普通程序需要使用1024以上的端口号</li>
</ul>
<p><strong>协议</strong></p>
<ul>
<li>  通过计算机网络可以使多台计算机实现连接，位于一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要1遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议。它对数据的传输格式、传输速率、传输步骤等做了统一的规定，通信双方必须同时遵守才能完成数据交换。常见的协议有<strong>UDP协议和TCP协议</strong></li>
</ul>
<h3 id="UDP发送数据"><a href="#UDP发送数据" class="headerlink" title="UDP发送数据"></a>UDP发送数据</h3><p>发送数据的步骤</p>
<ol>
<li>创建发送端的Socket对象（DatagramSocket）</li>
<li>创建数据，并把数据打包</li>
<li>调用DatagramSocket对象的方法发送数据</li>
<li>关闭发送端</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// DatagramSocket()构建一个数据报套接字绑定到本地主机的任何可用的端口。</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DatagramPacket(byte[] buf, int length, InetAddress address, int port)</span></span><br><span class="line">        <span class="comment">// 指定主机上的指定端口发送数据包的长度 length数据报包结构。</span></span><br><span class="line">        <span class="keyword">byte</span>[] bys=<span class="string">&quot;hello 我来了&quot;</span>.getBytes();</span><br><span class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bys, bys.length, InetAddress.getByName(<span class="string">&quot;192.168.31.15&quot;</span>), <span class="number">10086</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// send(DatagramPacket p) 从这个套接字发送数据报包。</span></span><br><span class="line">        socket.send(dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭发送端</span></span><br><span class="line">        <span class="comment">// close() 关闭该数据报套接字。</span></span><br><span class="line">        socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UDP接收数据"><a href="#UDP接收数据" class="headerlink" title="UDP接收数据"></a>UDP接收数据</h3><p>接收数据的步骤</p>
<ol>
<li>创建接收端的Socket对象（DatagramSocket）</li>
<li>创建一个数据包，用于接收数据</li>
<li>调用DatagramSocket对象的方法接收数据</li>
<li>解析数据包，并在控制台显示</li>
<li>关闭接收端</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建接收端的Socket对象（DatagramSocket）</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建一个数据包，用于接收数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bys, bys.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 调用DatagramSocket对象的方法接收数据</span></span><br><span class="line">        socket.receive(dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 解析数据包，并在控制台显示</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = dp.getData();</span><br><span class="line">        <span class="keyword">int</span> len = dp.getLength();</span><br><span class="line">        String dataString = <span class="keyword">new</span> String(data,<span class="number">0</span>,len);</span><br><span class="line">        System.out.print(<span class="string">&quot;数据是：&quot;</span> + dataString);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 关闭接收端</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="TCP发送数据"><a href="#TCP发送数据" class="headerlink" title="TCP发送数据"></a>TCP发送数据</h3><p>发送数据的步骤</p>
<ol>
<li>创建客户端的Socket对象（Socket）</li>
<li>获取输出流，写数据</li>
<li>释放资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建客户端的Socket对象（Socket）</span></span><br><span class="line">        <span class="comment">// Socket(InetAddress address, int port) 创建一个流套接字，并将其与指定的IP地址中的指定端口号连接起来。</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;192.168.31.15&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 2. 获取输出流，写数据</span></span><br><span class="line">        <span class="comment">// OutputStream getOutputStream() 返回此套接字的输出流。</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;hello,tcp,我来了&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="TCP接收数据"><a href="#TCP接收数据" class="headerlink" title="TCP接收数据"></a>TCP接收数据</h3><p>接收数据的步骤</p>
<ol>
<li>创建服务器的Socket对象（ServerSocket）</li>
<li>监听客户端连接，返回一个Socket对象</li>
<li>获取输入流，读数据，并在控制台显示</li>
<li>释放资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建服务器的Socket对象（ServerSocket）</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">10000</span>);</span><br><span class="line">    	<span class="comment">//2.监听客户端连接，返回一个Socket对象</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">//3. 获取输入流，读数据，并在控制台显示</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bys);</span><br><span class="line">        String data = <span class="keyword">new</span> String(bys, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(<span class="string">&quot;数据是：&quot;</span> + data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        serverSocket.close();</span><br><span class="line">        socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql基础知识总结</title>
    <url>/p/fb3a921a.html</url>
    <content><![CDATA[<h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><ol>
<li><p>数据库的英文单词： DataBase 简称 ： DB</p>
</li>
<li><p>什么数据库？</p>
<ul>
<li>用于存储和管理数据的仓库</li>
</ul>
</li>
<li><p>数据库的特点：</p>
<ul>
<li><p>持久化存储数据的。其实数据库就是一个文件系统</p>
</li>
<li><p>方便存储和管理数据</p>
</li>
<li><p>使用了统一的方式操作数据库  –  SQL</p>
</li>
</ul>
</li>
</ol>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h3><p>​        <strong>Structured Query Language：</strong>结构化查询语言</p>
<p>其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。</p>
<h3 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h3><ol>
<li>SQL 语句可以单行或多行书写，以分号结尾。</li>
<li>可使用空格和缩进来增强语句的可读性。</li>
<li>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</li>
<li>三种注释<ul>
<li>单行注释： – 注释内容 或 # 注释内容(mysql 特有)</li>
<li>多行注释：/* 注释 */</li>
</ul>
</li>
</ol>
<h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><ol>
<li>**DDL(Data Definition Language)**数据定义语言<pre><code> 用来定义数据库对象：数据库，表，列等。关键字：**create**, **drop**,**alter** 等
</code></pre>
</li>
<li>**DML(Data Manipulation Language)**数据操作语言<pre><code>用来对数据库中表的数据进行增删改。关键字：**insert**, **delete**, **update** 等
</code></pre>
</li>
<li>**DQL(Data Query Language)**数据查询语言<pre><code>用来查询数据库中表的记录(数据)。关键字：**select**, **where** 等
</code></pre>
</li>
<li>**DCL(Data Control Language)**数据控制语言(了解)<pre><code>用来定义数据库的访问权限和安全级别，及创建用户。关键字：**GRANT**， **REVOKE** 等
</code></pre>
</li>
</ol>
<h2 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h2><h3 id="操作数据库：CRUD"><a href="#操作数据库：CRUD" class="headerlink" title="操作数据库：CRUD"></a>操作数据库：CRUD</h3><h4 id="1-C-Create-：创建"><a href="#1-C-Create-：创建" class="headerlink" title="1. C(Create)：创建"></a>1. C(Create)：创建</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建数据库：</span></span><br><span class="line"><span class="keyword">create</span> database 数据库名称;</span><br><span class="line"><span class="comment">-- 创建数据库，判断不存在，再创建：</span></span><br><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> 数据库名称;</span><br><span class="line"><span class="comment">-- 创建数据库，并指定字符集</span></span><br><span class="line"><span class="keyword">create</span> database 数据库名称 <span class="type">character</span> <span class="keyword">set</span> 字符集名</span><br></pre></td></tr></table></figure>

<h4 id="2-R-Retrieve-：查询"><a href="#2-R-Retrieve-：查询" class="headerlink" title="2. R(Retrieve)：查询"></a>2. R(Retrieve)：查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有数据库的名称:</span></span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"><span class="comment">-- 查询某个数据库的字符集:查询某个数据库的创建语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> database 数据库名称;</span><br></pre></td></tr></table></figure>
<h4 id="3-U-Update-：修改"><a href="#3-U-Update-：修改" class="headerlink" title="3. U(Update)：修改"></a>3. U(Update)：修改</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 修改数据库的字符集</span></span><br><span class="line"><span class="keyword">alter</span> database 数据库名称 <span class="type">character</span> <span class="keyword">set</span> 字符集名称;</span><br></pre></td></tr></table></figure>
<h4 id="4-D-Delete-：删除"><a href="#4-D-Delete-：删除" class="headerlink" title="4. D(Delete)：删除"></a>4. D(Delete)：删除</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除数据库</span></span><br><span class="line"><span class="keyword">drop</span> database 数据库名称;</span><br><span class="line"><span class="comment">-- 判断数据库存在，存在再删除</span></span><br><span class="line"><span class="keyword">drop</span> database if <span class="keyword">exists</span> 数据库名称;</span><br></pre></td></tr></table></figure>
<h4 id="5-使用数据库"><a href="#5-使用数据库" class="headerlink" title="5. 使用数据库"></a>5. 使用数据库</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询当前正在使用的数据库名称</span></span><br><span class="line"><span class="keyword">select</span> database();</span><br><span class="line"><span class="comment">-- 使用数据库</span></span><br><span class="line">use 数据库名称;</span><br></pre></td></tr></table></figure>

<h3 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h3><h4 id="1-C-Create-：创建-1"><a href="#1-C-Create-：创建-1" class="headerlink" title="1.  C(Create)：创建"></a>1.  C(Create)：创建</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 语法：</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">	列名<span class="number">1</span> 数据类型<span class="number">1</span>,</span><br><span class="line">	列名<span class="number">2</span> 数据类型<span class="number">2</span>,</span><br><span class="line"> 	....</span><br><span class="line"> 	列名n 数据类型n</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 注意：最后一列，不需要加逗号（,）</span></span><br><span class="line"><span class="comment">-- 数据库类型：</span></span><br><span class="line"></span><br><span class="line">	<span class="number">1.</span> <span class="type">int</span>：整数类型</span><br><span class="line">			age <span class="type">int</span>,</span><br><span class="line">	<span class="number">2.</span> <span class="keyword">double</span>:小数类型</span><br><span class="line">			score <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line">	<span class="number">3.</span> <span class="type">date</span>:日期，只包含年月日，yyyy<span class="operator">-</span>MM<span class="operator">-</span>dd</span><br><span class="line">	<span class="number">4.</span> datetime:日期，包含年月日时分秒	 yyyy<span class="operator">-</span>MM<span class="operator">-</span>dd HH:mm:ss</span><br><span class="line">	<span class="number">5.</span> <span class="type">timestamp</span>:时间错类型	包含年月日时分秒	 yyyy<span class="operator">-</span>MM<span class="operator">-</span>dd HH:mm:ss	</span><br><span class="line">	如果将来不给这个字段赋值，或赋值为<span class="keyword">null</span>，则默认使用当前的系统时间，来自动赋值</span><br><span class="line">	<span class="number">6.</span> <span class="type">varchar</span>：字符串</span><br><span class="line">			name <span class="type">varchar</span>(<span class="number">20</span>):姓名最大<span class="number">20</span>个字符</span><br><span class="line">			zhangsan <span class="number">8</span>个字符  张三 <span class="number">2</span>个字符</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表:</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">32</span>),</span><br><span class="line">	age <span class="type">int</span> ,</span><br><span class="line">	score <span class="keyword">double</span>(<span class="number">4</span>,<span class="number">1</span>),</span><br><span class="line">	birthday <span class="type">date</span>,</span><br><span class="line">	insert_time <span class="type">timestamp</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 复制表：</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 <span class="keyword">like</span> 被复制的表名;  	</span><br></pre></td></tr></table></figure>

<h4 id="2-R-Retrieve-：查询-1"><a href="#2-R-Retrieve-：查询-1" class="headerlink" title="2. R(Retrieve)：查询"></a>2. R(Retrieve)：查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询某个数据库中所有的表名称</span></span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"><span class="comment">-- 查询表结构</span></span><br><span class="line"><span class="keyword">desc</span> 表名;</span><br></pre></td></tr></table></figure>
<h4 id="3-U-Update-：修改-1"><a href="#3-U-Update-：修改-1" class="headerlink" title="3. U(Update)：修改"></a>3. U(Update)：修改</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 修改表名</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 rename <span class="keyword">to</span> 新的表名;</span><br><span class="line"><span class="comment">-- 2. 修改表的字符集</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="type">character</span> <span class="keyword">set</span> 字符集名称;</span><br><span class="line"><span class="comment">-- 3. 添加一列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 数据类型;</span><br><span class="line"><span class="comment">-- 4. 修改列名称 类型</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 列名 新列别 新数据类型;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 列名 新数据类型;</span><br><span class="line"><span class="comment">-- 5. 删除列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 列名;</span><br></pre></td></tr></table></figure>
<h4 id="4-D-Delete-：删除-1"><a href="#4-D-Delete-：删除-1" class="headerlink" title="4. D(Delete)：删除"></a>4. D(Delete)：删除</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span>  if <span class="keyword">exists</span> 表名 ;</span><br></pre></td></tr></table></figure>

<h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><h4 id="1-添加数据："><a href="#1-添加数据：" class="headerlink" title="1. 添加数据："></a>1. 添加数据：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法：</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(列名<span class="number">1</span>,列名<span class="number">2</span>,...列名n) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...值n);</span><br><span class="line"><span class="comment">-- 注意：</span></span><br><span class="line">	<span class="number">1.</span> 列名和值要一一对应。</span><br><span class="line">	<span class="number">2.</span> 如果表名后，不定义列名，则默认给所有列添加值</span><br><span class="line">		<span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...值n);</span><br><span class="line">	<span class="number">3.</span> 除了数字类型，其他类型需要使用引号(单双都可以)引起来</span><br></pre></td></tr></table></figure>
<h4 id="2-删除数据："><a href="#2-删除数据：" class="headerlink" title="2. 删除数据："></a>2. 删除数据：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法：</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件]</span><br><span class="line"><span class="comment">-- 注意：</span></span><br><span class="line">	<span class="number">1.</span> 如果不加条件，则删除表中所有记录。</span><br><span class="line">	<span class="number">2.</span> 如果要删除所有记录</span><br><span class="line">		<span class="number">1.</span> <span class="keyword">delete</span> <span class="keyword">from</span> 表名; <span class="comment">-- 不推荐使用。有多少条记录就会执行多少次删除操作</span></span><br><span class="line">		<span class="number">2.</span> <span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名; <span class="comment">-- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。</span></span><br></pre></td></tr></table></figure>
<h4 id="3-修改数据："><a href="#3-修改数据：" class="headerlink" title="3. 修改数据："></a>3. 修改数据：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法：</span></span><br><span class="line">update 表名 <span class="keyword">set</span> 列名<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span>, 列名<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span>,... [<span class="keyword">where</span> 条件];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：</span></span><br><span class="line">	<span class="number">1.</span> 如果不加任何条件，则会将表中所有记录全部修改。</span><br></pre></td></tr></table></figure>

<h2 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h2><h3 id="1-语法格式"><a href="#1-语法格式" class="headerlink" title="1. 语法格式"></a>1. 语法格式</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 语法：</span></span><br><span class="line">	<span class="keyword">select</span></span><br><span class="line">		字段列表</span><br><span class="line">	<span class="keyword">from</span></span><br><span class="line">		表名列表</span><br><span class="line">	<span class="keyword">where</span></span><br><span class="line">		条件列表</span><br><span class="line">	<span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">		分组字段</span><br><span class="line">	<span class="keyword">having</span></span><br><span class="line">		分组之后的条件</span><br><span class="line">	<span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">		排序</span><br><span class="line">	limit</span><br><span class="line">		分页限定</span><br></pre></td></tr></table></figure>



<h3 id="2-基础查询"><a href="#2-基础查询" class="headerlink" title="2. 基础查询"></a>2. 基础查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 多个字段的查询</span></span><br><span class="line"><span class="keyword">select</span> 字段名<span class="number">1</span>，字段名<span class="number">2.</span>.. <span class="keyword">from</span> 表名；</span><br><span class="line"><span class="comment">-- 注意：如果查询所有字段，则可以使用*来替代字段列表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 去除重复：distinct</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 计算列</span></span><br><span class="line">	一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）</span><br><span class="line">	ifnull(表达式<span class="number">1</span>,表达式<span class="number">2</span>)：<span class="keyword">null</span>参与的运算，计算结果都为<span class="keyword">null</span></span><br><span class="line">		表达式<span class="number">1</span>：哪个字段需要判断是否为<span class="keyword">null</span></span><br><span class="line">		如果该字段为<span class="keyword">null</span>后的替换值。</span><br><span class="line"><span class="comment">-- 4. 起别名：</span></span><br><span class="line">	<span class="keyword">as</span>：<span class="keyword">as</span>也可以省略</span><br></pre></td></tr></table></figure>

<h3 id="3-条件查询"><a href="#3-条件查询" class="headerlink" title="3. 条件查询"></a>3. 条件查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. where子句后跟条件</span></span><br><span class="line"><span class="comment">-- 2. 运算符</span></span><br><span class="line">	<span class="operator">*</span> <span class="operator">&gt;</span> 、<span class="operator">&lt;</span> 、<span class="operator">&lt;=</span> 、<span class="operator">&gt;=</span> 、<span class="operator">=</span> 、<span class="operator">&lt;&gt;</span></span><br><span class="line">	<span class="operator">*</span> BETWEEN...AND  </span><br><span class="line">	<span class="operator">*</span> <span class="keyword">IN</span>( 集合) </span><br><span class="line">	<span class="operator">*</span> <span class="keyword">LIKE</span>：模糊查询</span><br><span class="line">		占位符：</span><br><span class="line">			_:单个任意字符</span><br><span class="line">			<span class="operator">%</span>:多个任意字符</span><br><span class="line">	<span class="operator">*</span> <span class="keyword">IS</span> <span class="keyword">NULL</span>  </span><br><span class="line">	<span class="operator">*</span> <span class="keyword">and</span> 或 <span class="operator">&amp;&amp;</span></span><br><span class="line">	<span class="operator">*</span> <span class="keyword">or</span>  或 <span class="operator">||</span> </span><br><span class="line">	<span class="operator">*</span> <span class="keyword">not</span> 或 <span class="operator">!</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">-- 查询年龄大于20岁</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询年龄等于20岁</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询年龄不等于20岁</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">!=</span> <span class="number">20</span>;</span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询年龄大于等于20 小于等于30</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="operator">&amp;&amp;</span>  age <span class="operator">&lt;=</span><span class="number">30</span>;</span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="keyword">AND</span>  age <span class="operator">&lt;=</span><span class="number">30</span>;</span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询年龄22岁，18岁，25岁的信息</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">22</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">18</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">25</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IN</span> (<span class="number">22</span>,<span class="number">18</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询英语成绩为null</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english <span class="operator">=</span> <span class="keyword">NULL</span>; <span class="comment">-- 不对的。null值不能使用 = （!=） 判断</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询英语成绩不为null</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english  <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询姓马的有哪些？ like</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;马%&#x27;</span>;</span><br><span class="line">		<span class="comment">-- 查询姓名第二个字是化的人</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> &quot;_化%&quot;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询姓名是3个字的人</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;___&#x27;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 查询姓名中包含德的人</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;%德%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-排序查询"><a href="#4-排序查询" class="headerlink" title="4. 排序查询"></a>4. 排序查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法：order by 子句</span></span><br><span class="line">	<span class="operator">*</span> <span class="keyword">order</span> <span class="keyword">by</span> 排序字段<span class="number">1</span> 排序方式<span class="number">1</span> ，  排序字段<span class="number">2</span> 排序方式<span class="number">2.</span>..</span><br><span class="line"></span><br><span class="line">	<span class="operator">*</span> 排序方式：</span><br><span class="line">		<span class="operator">*</span> <span class="keyword">ASC</span>：升序，默认的。</span><br><span class="line">		<span class="operator">*</span> <span class="keyword">DESC</span>：降序。</span><br><span class="line"></span><br><span class="line">	<span class="operator">*</span> 注意：</span><br><span class="line">		<span class="operator">*</span> 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</span><br></pre></td></tr></table></figure>

<h3 id="5-聚合函数"><a href="#5-聚合函数" class="headerlink" title="5. 聚合函数"></a>5. 聚合函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 聚合函数：将一列数据作为一个整体，进行纵向的计算。</span></span><br><span class="line">	<span class="number">1.</span> count：计算个数</span><br><span class="line">		<span class="number">1.</span> 一般选择非空的列：主键</span><br><span class="line">		<span class="number">2.</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">	<span class="number">2.</span> max：计算最大值</span><br><span class="line">	<span class="number">3.</span> min：计算最小值</span><br><span class="line">	<span class="number">4.</span> sum：计算和</span><br><span class="line">	<span class="number">5.</span> avg：计算平均值</span><br><span class="line">	<span class="operator">*</span> 注意：聚合函数的计算，排除<span class="keyword">null</span>值。</span><br><span class="line">		解决方案：</span><br><span class="line">			<span class="number">1.</span> 选择不包含非空的列进行计算</span><br><span class="line">			<span class="number">2.</span> IFNULL函数</span><br></pre></td></tr></table></figure>

<h3 id="6-分组查询"><a href="#6-分组查询" class="headerlink" title="6. 分组查询"></a>6. 分组查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 分组查询:</span></span><br><span class="line">	<span class="number">1.</span> 语法：<span class="keyword">group</span> <span class="keyword">by</span> 分组字段；</span><br><span class="line">	<span class="number">2.</span> 注意：</span><br><span class="line">		<span class="number">1.</span> 分组之后查询的字段：分组字段、聚合函数</span><br><span class="line">		<span class="number">2.</span> <span class="keyword">where</span> 和 <span class="keyword">having</span> 的区别？</span><br><span class="line">			<span class="number">1.</span> <span class="keyword">where</span> 在分组之前进行限定，如果不满足条件，则不参与分组。<span class="keyword">having</span>在分组之后进行限定，如果不满足结果，则不会被查询出来</span><br><span class="line">			<span class="number">2.</span> <span class="keyword">where</span> 后不可以跟聚合函数，<span class="keyword">having</span>可以进行聚合函数的判断。</span><br><span class="line"></span><br><span class="line">		<span class="comment">-- 按照性别分组。分别查询男、女同学的平均分</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> sex , <span class="built_in">AVG</span>(math) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">-- 按照性别分组。分别查询男、女同学的平均分,人数</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">SELECT</span> sex , <span class="built_in">AVG</span>(math),<span class="built_in">COUNT</span>(id) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组</span></span><br><span class="line">		<span class="keyword">SELECT</span> sex , <span class="built_in">AVG</span>(math),<span class="built_in">COUNT</span>(id) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> math <span class="operator">&gt;</span> <span class="number">70</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人</span></span><br><span class="line">		<span class="keyword">SELECT</span> sex , <span class="built_in">AVG</span>(math),<span class="built_in">COUNT</span>(id) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> math <span class="operator">&gt;</span> <span class="number">70</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(id) <span class="operator">&gt;</span> <span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">SELECT</span> sex , <span class="built_in">AVG</span>(math),<span class="built_in">COUNT</span>(id) 人数 <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> math <span class="operator">&gt;</span> <span class="number">70</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex <span class="keyword">HAVING</span> 人数 <span class="operator">&gt;</span> <span class="number">2</span>;	</span><br></pre></td></tr></table></figure>

<h3 id="7-分页查询"><a href="#7-分页查询" class="headerlink" title="7. 分页查询"></a>7. 分页查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 分页查询</span></span><br><span class="line">	<span class="number">1.</span> 语法：limit 开始的索引,每页查询的条数;</span><br><span class="line">	<span class="number">2.</span> 公式：开始的索引 <span class="operator">=</span> （当前的页码 <span class="operator">-</span> <span class="number">1</span>） <span class="operator">*</span> 每页显示的条数</span><br><span class="line">		<span class="comment">-- 每页显示3条记录 </span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LIMIT <span class="number">0</span>,<span class="number">3</span>; <span class="comment">-- 第1页</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LIMIT <span class="number">3</span>,<span class="number">3</span>; <span class="comment">-- 第2页</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LIMIT <span class="number">6</span>,<span class="number">3</span>; <span class="comment">-- 第3页</span></span><br><span class="line"></span><br><span class="line">	<span class="number">3.</span> limit 是一个MySQL&quot;方言&quot;</span><br></pre></td></tr></table></figure>

<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p><strong>概念：</strong> 对表中的数据进行限定，保证数据的正确性、有效性和完整性。</p>
<p><strong>分类：</strong></p>
<ol>
<li>主键约束：<strong>primary key</strong></li>
<li>非空约束：<strong>not null</strong></li>
<li>唯一约束：<strong>unique</strong></li>
<li>外键约束：<strong>foreign key</strong></li>
</ol>
<p><strong>非空约束：not null</strong>，某一列的值不能为null</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建表时添加约束</span></span><br><span class="line">		<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(</span><br><span class="line">			id <span class="type">INT</span>,</span><br><span class="line">			NAME <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="comment">-- name为非空</span></span><br><span class="line">		);</span><br><span class="line"><span class="comment">-- 2. 创建表完后，添加非空约束</span></span><br><span class="line">		<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu MODIFY NAME <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 删除name的非空约束</span></span><br><span class="line">		<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu MODIFY NAME <span class="type">VARCHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p><strong>唯一约束： unique</strong>，某一列的值不能重复</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 注意：</span></span><br><span class="line">		<span class="operator">*</span> 唯一约束可以有<span class="keyword">NULL</span>值，但是只能有一条记录为<span class="keyword">null</span></span><br><span class="line"><span class="comment">-- 2. 在创建表时，添加唯一约束</span></span><br><span class="line">		<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(</span><br><span class="line">			id <span class="type">INT</span>,</span><br><span class="line">			phone_number <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span> <span class="comment">-- 手机号</span></span><br><span class="line">		);</span><br><span class="line"><span class="comment">-- 3. 删除唯一约束</span></span><br><span class="line">		<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">DROP</span> INDEX phone_number;</span><br><span class="line"><span class="comment">-- 4. 在表创建完后，添加唯一约束</span></span><br><span class="line">		<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu MODIFY phone_number <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>;</span><br></pre></td></tr></table></figure>

<p><strong>主键约束：primary key</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 注意：</span></span><br><span class="line">		<span class="number">1.</span> 含义：非空且唯一</span><br><span class="line">		<span class="number">2.</span> 一张表只能有一个字段为主键</span><br><span class="line">		<span class="number">3.</span> 主键就是表中记录的唯一标识</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 在创建表时，添加主键约束</span></span><br><span class="line">		<span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">			id <span class="type">int</span> <span class="keyword">primary</span> key,<span class="comment">-- 给id添加主键约束</span></span><br><span class="line">			name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 删除主键</span></span><br><span class="line">		<span class="comment">-- 错误 alter table stu modify id int ;</span></span><br><span class="line">		<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 创建完表后，添加主键</span></span><br><span class="line">		<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu MODIFY id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. 自动增长：</span></span><br><span class="line">		<span class="number">1.</span>概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长</span><br><span class="line"></span><br><span class="line">		<span class="number">2.</span>在创建表时，添加主键约束，并且完成主键自增长</span><br><span class="line">            <span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">                id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,<span class="comment">-- 给id添加主键约束</span></span><br><span class="line">                name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">            );</span><br><span class="line">		<span class="number">3.</span> 删除自动增长</span><br><span class="line">			<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu MODIFY id <span class="type">INT</span>;</span><br><span class="line">		<span class="number">4.</span> 添加自动增长</span><br><span class="line">			<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu MODIFY id <span class="type">INT</span> AUTO_INCREMENT;</span><br></pre></td></tr></table></figure>

<p><strong>外键约束：foreign key</strong>,让表于表产生关系，从而保证数据的正确性</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 在创建表时，可以添加外键</span></span><br><span class="line">		<span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">			....</span><br><span class="line">			外键列</span><br><span class="line">			<span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key (外键列名称) <span class="keyword">references</span> 主表名称(主表列名称)</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 删除外键</span></span><br><span class="line">		<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 创建表之后，添加外键</span></span><br><span class="line">		<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名称) <span class="keyword">REFERENCES</span> 主表名称(主表列名称);</span><br><span class="line"><span class="comment">-- 4. 级联操作</span></span><br><span class="line">		<span class="number">1.</span> 添加级联操作</span><br><span class="line">			<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 </span><br><span class="line">			<span class="keyword">FOREIGN</span> KEY (外键字段名称) <span class="keyword">REFERENCES</span> 主表名称(主表列名称) <span class="keyword">ON</span> UPDATE CASCADE <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE;</span><br><span class="line">		<span class="number">2.</span> 分类：</span><br><span class="line">			<span class="number">1.</span> 级联更新：<span class="keyword">ON</span> UPDATE CASCADE </span><br><span class="line">			<span class="number">2.</span> 级联删除：<span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE 		</span><br></pre></td></tr></table></figure>

<h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><h3 id="1-多表之间的关系"><a href="#1-多表之间的关系" class="headerlink" title="1. 多表之间的关系"></a>1. 多表之间的关系</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 分类：</span></span><br><span class="line">	</span><br><span class="line">	<span class="number">1.</span> 一对一(了解)：</span><br><span class="line">		<span class="operator">*</span> 如：人和身份证</span><br><span class="line">		<span class="operator">*</span> 分析：一个人只有一个身份证，一个身份证只能对应一个人</span><br><span class="line">	<span class="number">2.</span> 一对多(多对一)：</span><br><span class="line">		<span class="operator">*</span> 如：部门和员工</span><br><span class="line">		<span class="operator">*</span> 分析：一个部门有多个员工，一个员工只能对应一个部门</span><br><span class="line">	<span class="number">3.</span> 多对多：</span><br><span class="line">		<span class="operator">*</span> 如：学生和课程</span><br><span class="line">		<span class="operator">*</span> 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择</span><br><span class="line">	</span><br><span class="line"><span class="comment">-- 2. 实现关系：</span></span><br><span class="line">	<span class="number">1.</span> 一对多(多对一)：</span><br><span class="line">		<span class="operator">*</span> 如：部门和员工</span><br><span class="line">		<span class="operator">*</span> 实现方式：在多的一方建立外键，指向一的一方的主键。</span><br><span class="line">	<span class="number">2.</span> 多对多：</span><br><span class="line">		<span class="operator">*</span> 如：学生和课程</span><br><span class="line">		<span class="operator">*</span> 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键</span><br><span class="line">	<span class="number">3.</span> 一对一(了解)：</span><br><span class="line">		<span class="operator">*</span> 如：人和身份证</span><br><span class="line">		<span class="operator">*</span> 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 案例</span></span><br><span class="line">	<span class="comment">/*  </span></span><br><span class="line"><span class="comment">		创建旅游线路分类表 tab_category</span></span><br><span class="line"><span class="comment">		cid 旅游线路分类主键，自动增长</span></span><br><span class="line"><span class="comment">		cname 旅游线路分类名称非空，唯一，字符串 100</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_category (</span><br><span class="line">		cid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">		cname <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span></span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- 创建旅游线路表 tab_route</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		rid 旅游线路主键，自动增长</span></span><br><span class="line"><span class="comment">		rname 旅游线路名称非空，唯一，字符串 100</span></span><br><span class="line"><span class="comment">		price 价格</span></span><br><span class="line"><span class="comment">		rdate 上架时间，日期类型</span></span><br><span class="line"><span class="comment">		cid 外键，所属分类</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_route(</span><br><span class="line">		rid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">		rname <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">		price <span class="keyword">DOUBLE</span>,</span><br><span class="line">		rdate <span class="type">DATE</span>,</span><br><span class="line">		cid <span class="type">INT</span>,</span><br><span class="line">		<span class="keyword">FOREIGN</span> KEY (cid) <span class="keyword">REFERENCES</span> tab_category(cid)</span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- 创建用户表 tab_user</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		uid 用户主键，自增长</span></span><br><span class="line"><span class="comment">		username 用户名长度 100，唯一，非空</span></span><br><span class="line"><span class="comment">		password 密码长度 30，非空</span></span><br><span class="line"><span class="comment">		name 真实姓名长度 100</span></span><br><span class="line"><span class="comment">		birthday 生日</span></span><br><span class="line"><span class="comment">		sex 性别，定长字符串 1</span></span><br><span class="line"><span class="comment">		telephone 手机号，字符串 11</span></span><br><span class="line"><span class="comment">		email 邮箱，字符串长度 100</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_user (</span><br><span class="line">		uid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">		username <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">		PASSWORD <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">		NAME <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">		birthday <span class="type">DATE</span>,</span><br><span class="line">		sex <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">		telephone <span class="type">VARCHAR</span>(<span class="number">11</span>),</span><br><span class="line">		email <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">	);</span><br><span class="line">	<span class="comment">-- 创建收藏表 tab_favorite</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		rid 旅游线路 id，外键</span></span><br><span class="line"><span class="comment">		date 收藏时间</span></span><br><span class="line"><span class="comment">		uid 用户 id，外键</span></span><br><span class="line"><span class="comment">		rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_favorite (</span><br><span class="line">		rid <span class="type">INT</span>, <span class="comment">-- 线路id</span></span><br><span class="line">		<span class="type">DATE</span> DATETIME,</span><br><span class="line">		uid <span class="type">INT</span>, <span class="comment">-- 用户id</span></span><br><span class="line">		<span class="comment">-- 创建复合主键</span></span><br><span class="line">		<span class="keyword">PRIMARY</span> KEY(rid,uid), <span class="comment">-- 联合主键</span></span><br><span class="line">		<span class="keyword">FOREIGN</span> KEY (rid) <span class="keyword">REFERENCES</span> tab_route(rid),</span><br><span class="line">		<span class="keyword">FOREIGN</span> KEY(uid) <span class="keyword">REFERENCES</span> tab_user(uid)</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>

<h3 id="2-数据库设计的范式"><a href="#2-数据库设计的范式" class="headerlink" title="2.数据库设计的范式"></a>2.数据库设计的范式</h3><ul>
<li><p>概念：**设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求</p>
</li>
<li><p>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p>
</li>
<li><p>目前关系数据库有六种范式：<strong>第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）</strong>。</p>
</li>
<li><p>分类：</p>
<ol>
<li>第一范式（1NF）：每一列都是不可分割的原子数据项</li>
<li>第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）<ul>
<li>几个概念：<pre><code>1. **函数依赖：**A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A
    例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数
2. **完全函数依赖：**A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。
    例如：（学号，课程名称） --&gt; 分数
3. **部分函数依赖：**A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。
    例如：（学号，课程名称） -- &gt; 姓名
4. **传递函数依赖：**A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A
    例如：学号--&gt;系名，系名--&gt;系主任
5. **码：**如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码
    例如：该表中码为：（学号，课程名称）
    **主属性：**码属性组中的所有属性
    **非主属性：**除过码属性组的属性
</code></pre>
</li>
</ul>
</li>
<li>第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</li>
</ol>
</li>
</ul>
<h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><ol>
<li>命令行：<ul>
<li>备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径</li>
<li>还原：<pre><code>  1. 登录数据库
  2. 创建数据库
  3. 使用数据库
  4. 执行文件。source 文件路径
</code></pre>
</li>
</ul>
</li>
<li>图形化工具：</li>
</ol>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><ul>
<li>有两个集合A,B .取这两个集合的所有组成情况。</li>
<li>要完成多表查询，需要消除无用的数据</li>
</ul>
<h3 id="多表查询的分类"><a href="#多表查询的分类" class="headerlink" title="多表查询的分类"></a>多表查询的分类</h3><h4 id="1-内连接查询："><a href="#1-内连接查询：" class="headerlink" title="1. 内连接查询："></a>1. 内连接查询：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 隐式内连接：使用where条件消除无用数据</span></span><br><span class="line">		<span class="operator">*</span> 例子：</span><br><span class="line">		<span class="comment">-- 查询所有员工信息和对应的部门信息</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp,dept <span class="keyword">WHERE</span> emp.`dept_id` <span class="operator">=</span> dept.`id`;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">-- 查询员工表的名称，性别。部门表的名称</span></span><br><span class="line">		<span class="keyword">SELECT</span> emp.name,emp.gender,dept.name <span class="keyword">FROM</span> emp,dept <span class="keyword">WHERE</span> emp.`dept_id` <span class="operator">=</span> dept.`id`;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">SELECT</span> </span><br><span class="line">			t1.name, <span class="comment">-- 员工表的姓名</span></span><br><span class="line">			t1.gender,<span class="comment">-- 员工表的性别</span></span><br><span class="line">			t2.name <span class="comment">-- 部门表的名称</span></span><br><span class="line">		<span class="keyword">FROM</span></span><br><span class="line">			emp t1,</span><br><span class="line">			dept t2</span><br><span class="line">		<span class="keyword">WHERE</span> </span><br><span class="line">			t1.`dept_id` <span class="operator">=</span> t2.`id`;</span><br><span class="line"><span class="comment">-- 2. 显式内连接：</span></span><br><span class="line">		<span class="operator">*</span> 语法： <span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名<span class="number">1</span> [<span class="keyword">inner</span>] <span class="keyword">join</span> 表名<span class="number">2</span> <span class="keyword">on</span> 条件</span><br><span class="line">		<span class="operator">*</span> 例如：</span><br><span class="line">			<span class="operator">*</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> emp.`dept_id` <span class="operator">=</span> dept.`id`;	</span><br><span class="line">			<span class="operator">*</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> emp.`dept_id` <span class="operator">=</span> dept.`id`;	</span><br><span class="line"><span class="comment">-- 3. 内连接查询：</span></span><br><span class="line">		<span class="number">1.</span> 从哪些表中查询数据</span><br><span class="line">		<span class="number">2.</span> 条件是什么</span><br><span class="line">		<span class="number">3.</span> 查询哪些字段				</span><br></pre></td></tr></table></figure>


<h4 id="2-外链接查询："><a href="#2-外链接查询：" class="headerlink" title="2. 外链接查询："></a>2. 外链接查询：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 左外连接：</span></span><br><span class="line">		<span class="operator">*</span> 语法：<span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">left</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件；</span><br><span class="line">		<span class="operator">*</span> 查询的是左表所有数据以及其交集部分。</span><br><span class="line">		<span class="operator">*</span> 例子：</span><br><span class="line">			<span class="comment">-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称</span></span><br><span class="line">			<span class="keyword">SELECT</span> 	t1.<span class="operator">*</span>,t2.`name` <span class="keyword">FROM</span> emp t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept t2 <span class="keyword">ON</span> t1.`dept_id` <span class="operator">=</span> t2.`id`;</span><br><span class="line"><span class="comment">-- 2. 右外连接：</span></span><br><span class="line">		<span class="operator">*</span> 语法：<span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">right</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件；</span><br><span class="line">		<span class="operator">*</span> 查询的是右表所有数据以及其交集部分。</span><br><span class="line">		<span class="operator">*</span> 例子：</span><br><span class="line">			<span class="keyword">SELECT</span> 	<span class="operator">*</span> <span class="keyword">FROM</span> dept t2 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> emp t1 <span class="keyword">ON</span> t1.`dept_id` <span class="operator">=</span> t2.`id`;</span><br></pre></td></tr></table></figure>

<h4 id="3-子查询："><a href="#3-子查询：" class="headerlink" title="3. 子查询："></a>3. 子查询：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 概念：查询中嵌套查询，称嵌套查询为子查询。</span></span><br><span class="line">		<span class="comment">-- 查询工资最高的员工信息</span></span><br><span class="line">		<span class="comment">-- 1 查询最高的工资是多少 9000</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> emp;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">-- 2 查询员工信息，并且工资等于9000的</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.`salary` <span class="operator">=</span> <span class="number">9000</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">-- 一条sql就完成这个操作。子查询</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.`salary` <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> emp);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子查询不同情况</span></span><br><span class="line">		<span class="number">1.</span> 子查询的结果是单行单列的：</span><br><span class="line">			<span class="operator">*</span> 子查询可以作为条件，使用运算符去判断。 运算符： <span class="operator">&gt;</span> <span class="operator">&gt;=</span> <span class="operator">&lt;</span> <span class="operator">&lt;=</span> <span class="operator">=</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">-- 查询员工工资小于平均工资的人</span></span><br><span class="line">			<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.salary <span class="operator">&lt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> emp);</span><br><span class="line">		<span class="number">2.</span> 子查询的结果是多行单列的：</span><br><span class="line">			<span class="comment">-- 子查询可以作为条件，使用运算符in来判断</span></span><br><span class="line">			<span class="comment">-- 查询&#x27;财务部&#x27;和&#x27;市场部&#x27;所有的员工信息</span></span><br><span class="line">			<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span> <span class="keyword">OR</span> NAME <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>;</span><br><span class="line">			<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id <span class="operator">=</span> <span class="number">3</span> <span class="keyword">OR</span> dept_id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">			<span class="comment">-- 子查询</span></span><br><span class="line">			<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span> <span class="keyword">OR</span> NAME <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="number">3.</span> 子查询的结果是多行多列的：</span><br><span class="line">			<span class="operator">*</span> 子查询可以作为一张虚拟表参与查询</span><br><span class="line">			<span class="comment">-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息</span></span><br><span class="line">			<span class="comment">-- 子查询</span></span><br><span class="line">			<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dept t1 ,(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.`join_date` <span class="operator">&gt;</span> <span class="string">&#x27;2011-11-11&#x27;</span>) t2</span><br><span class="line">			<span class="keyword">WHERE</span> t1.id <span class="operator">=</span> t2.dept_id;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">-- 普通内连接</span></span><br><span class="line">			<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp t1,dept t2 <span class="keyword">WHERE</span> t1.`dept_id` <span class="operator">=</span> t2.`id` <span class="keyword">AND</span> t1.`join_date` <span class="operator">&gt;</span>  <span class="string">&#x27;2011-11-11&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="1-事务的基本介绍"><a href="#1-事务的基本介绍" class="headerlink" title="1. 事务的基本介绍"></a>1. 事务的基本介绍</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 概念：</span></span><br><span class="line">	<span class="operator">*</span>  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</span><br><span class="line"><span class="comment">-- 2. 操作：</span></span><br><span class="line">	<span class="number">1.</span> 开启事务： <span class="keyword">start</span> transaction;</span><br><span class="line">	<span class="number">2.</span> 回滚：<span class="keyword">rollback</span>;</span><br><span class="line">	<span class="number">3.</span> 提交：<span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">-- 3. 例子：</span></span><br><span class="line">	<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account (</span><br><span class="line">		id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">		NAME <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">		balance <span class="keyword">DOUBLE</span></span><br><span class="line">	);</span><br><span class="line">	<span class="comment">-- 添加数据</span></span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> account (NAME, balance) <span class="keyword">VALUES</span> (<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">1000</span>), (<span class="string">&#x27;lisi&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br><span class="line">	UPDATE account <span class="keyword">SET</span> balance <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">	<span class="comment">-- 张三给李四转账 500 元</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- 0. 开启事务</span></span><br><span class="line">	<span class="keyword">START</span> TRANSACTION;</span><br><span class="line">	<span class="comment">-- 1. 张三账户 -500</span></span><br><span class="line">	</span><br><span class="line">	UPDATE account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">500</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line">	<span class="comment">-- 2. 李四账户 +500</span></span><br><span class="line">	<span class="comment">-- 出错了...</span></span><br><span class="line">	UPDATE account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">500</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;lisi&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- 发现执行没有问题，提交事务</span></span><br><span class="line">	<span class="keyword">COMMIT</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- 发现出问题了，回滚事务</span></span><br><span class="line">	<span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="comment">-- 4. MySQL数据库中事务默认自动提交</span></span><br><span class="line">	</span><br><span class="line">	<span class="operator">*</span> 事务提交的两种方式：</span><br><span class="line">		<span class="operator">*</span> 自动提交：</span><br><span class="line">			<span class="operator">*</span> mysql就是自动提交的</span><br><span class="line">			<span class="operator">*</span> 一条DML(增删改)语句会自动提交一次事务。</span><br><span class="line">		<span class="operator">*</span> 手动提交：</span><br><span class="line">			<span class="operator">*</span> Oracle 数据库默认是手动提交事务</span><br><span class="line">			<span class="operator">*</span> 需要先开启事务，再提交</span><br><span class="line">	<span class="operator">*</span> 修改事务的默认提交方式：</span><br><span class="line">		<span class="operator">*</span> 查看事务的默认提交方式：<span class="keyword">SELECT</span> @<span class="variable">@autocommit</span>; <span class="comment">-- 1 代表自动提交  0 代表手动提交</span></span><br><span class="line">		<span class="operator">*</span> 修改默认提交方式： <span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-事务的四大特征：ACID"><a href="#2-事务的四大特征：ACID" class="headerlink" title="2. 事务的四大特征：ACID"></a>2. 事务的四大特征：ACID</h3><ol>
<li><strong>原子性（Atomicity）：</strong>是不可分割的最小操作单位，要么同时成功，要么同时失败。</li>
<li><strong>一致性（Consistency）：</strong>事务操作前后，数据总量不变</li>
<li><strong>隔离性（Isolation）：</strong>多个事务之间。相互独立。</li>
<li><strong>持久性（Durability）：</strong>当事务提交或回滚后，数据库会持久化的保存数据。<h3 id="3-事务的隔离级别（了解）"><a href="#3-事务的隔离级别（了解）" class="headerlink" title="3. 事务的隔离级别（了解）"></a>3. 事务的隔离级别（了解）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 存在问题：</span></span><br><span class="line">	<span class="number">1.</span> 脏读：一个事务，读取到另一个事务中没有提交的数据</span><br><span class="line">	<span class="number">2.</span> 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。</span><br><span class="line">	<span class="number">3.</span> 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</span><br><span class="line">	</span><br><span class="line"><span class="comment">-- 隔离级别：</span></span><br><span class="line">	<span class="number">1.</span> read uncommitted：读未提交</span><br><span class="line">		<span class="operator">*</span> 产生的问题：脏读、不可重复读、幻读</span><br><span class="line">	<span class="number">2.</span> read committed：读已提交 （Oracle）</span><br><span class="line">		<span class="operator">*</span> 产生的问题：不可重复读、幻读</span><br><span class="line">	<span class="number">3.</span> repeatable read：可重复读 （MySQL默认）</span><br><span class="line">		<span class="operator">*</span> 产生的问题：幻读</span><br><span class="line">	<span class="number">4.</span> serializable：串行化</span><br><span class="line">		<span class="operator">*</span> 可以解决所有的问题</span><br><span class="line"></span><br><span class="line">	<span class="operator">*</span> 注意：隔离级别从小到大安全性越来越高，但是效率越来越低</span><br><span class="line">	<span class="operator">*</span> 数据库查询隔离级别：</span><br><span class="line">		<span class="operator">*</span> <span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;</span><br><span class="line">	<span class="operator">*</span> 数据库设置隔离级别：</span><br><span class="line">		<span class="operator">*</span> <span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level  级别字符串;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 演示：</span></span><br><span class="line">	<span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level read uncommitted;</span><br><span class="line">	<span class="keyword">start</span> transaction;</span><br><span class="line">	<span class="comment">-- 转账操作</span></span><br><span class="line">	update account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">500</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	update account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">500</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​    </p>
<h2 id="DCL：管理用户，授权"><a href="#DCL：管理用户，授权" class="headerlink" title="DCL：管理用户，授权"></a>DCL：管理用户，授权</h2><ul>
<li><p>SQL分类：</p>
<ol>
<li><strong>DDL：</strong>操作数据库和表</li>
<li><strong>DML：</strong>增删改表中数据</li>
<li><strong>DQL：</strong>查询表中数据</li>
<li><strong>DCL：</strong>管理用户，授权</li>
</ol>
</li>
<li><p><strong>DBA：</strong>数据库管理员</p>
</li>
<li><p><strong>DCL：</strong>管理用户，授权</p>
<h3 id="1-管理用户"><a href="#1-管理用户" class="headerlink" title="1. 管理用户"></a>1. 管理用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 添加用户：</span></span><br><span class="line">		<span class="operator">*</span> 语法：<span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br><span class="line"><span class="comment">-- 2. 删除用户：</span></span><br><span class="line">		<span class="operator">*</span> 语法：<span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br><span class="line"><span class="comment">-- 3. 修改用户密码：</span></span><br><span class="line">		</span><br><span class="line">		UPDATE <span class="keyword">USER</span> <span class="keyword">SET</span> PASSWORD <span class="operator">=</span> PASSWORD(<span class="string">&#x27;新密码&#x27;</span>) <span class="keyword">WHERE</span> <span class="keyword">USER</span> <span class="operator">=</span> <span class="string">&#x27;用户名&#x27;</span>;</span><br><span class="line">		UPDATE <span class="keyword">USER</span> <span class="keyword">SET</span> PASSWORD <span class="operator">=</span> PASSWORD(<span class="string">&#x27;abc&#x27;</span>) <span class="keyword">WHERE</span> <span class="keyword">USER</span> <span class="operator">=</span> <span class="string">&#x27;lisi&#x27;</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> <span class="operator">=</span> PASSWORD(<span class="string">&#x27;新密码&#x27;</span>);</span><br><span class="line">		<span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="operator">=</span> PASSWORD(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="operator">*</span> mysql中忘记了root用户的密码？</span><br><span class="line">			<span class="number">1.</span> cmd <span class="comment">-- &gt; net stop mysql 停止mysql服务</span></span><br><span class="line">				<span class="operator">*</span> 需要管理员运行该cmd</span><br><span class="line"></span><br><span class="line">			<span class="number">2.</span> 使用无验证方式启动mysql服务： mysqld <span class="comment">--skip-grant-tables</span></span><br><span class="line">			<span class="number">3.</span> 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功</span><br><span class="line">			<span class="number">4.</span> use mysql;</span><br><span class="line">			<span class="number">5.</span> update <span class="keyword">user</span> <span class="keyword">set</span> password <span class="operator">=</span> password(<span class="string">&#x27;你的新密码&#x27;</span>) <span class="keyword">where</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">			<span class="number">6.</span> 关闭两个窗口</span><br><span class="line">			<span class="number">7.</span> 打开任务管理器，手动结束mysqld.exe 的进程</span><br><span class="line">			<span class="number">8.</span> 启动mysql服务</span><br><span class="line">			<span class="number">9.</span> 使用新密码登录。</span><br><span class="line"><span class="comment">-- 4. 查询用户：</span></span><br><span class="line">		<span class="comment">-- 1. 切换到mysql数据库</span></span><br><span class="line">		USE myql;</span><br><span class="line">		<span class="comment">-- 2. 查询user表</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="operator">*</span> 通配符： <span class="operator">%</span> 表示可以在任意主机使用用户登录数据库</span><br></pre></td></tr></table></figure>
<h3 id="2-权限管理："><a href="#2-权限管理：" class="headerlink" title="2. 权限管理："></a>2. 权限管理：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 查询权限：</span></span><br><span class="line">		<span class="comment">-- 查询权限</span></span><br><span class="line">		<span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br><span class="line">		<span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;lisi&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 授予权限：</span></span><br><span class="line">		<span class="comment">-- 授予权限</span></span><br><span class="line">		<span class="keyword">grant</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br><span class="line">		<span class="comment">-- 给张三用户授予所有权限，在任意数据库任意表上</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="comment">-- 3. 撤销权限：</span></span><br><span class="line">		<span class="comment">-- 撤销权限：</span></span><br><span class="line">		<span class="keyword">revoke</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">from</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br><span class="line">		<span class="keyword">REVOKE</span> UPDATE <span class="keyword">ON</span> db3.`account` <span class="keyword">FROM</span> <span class="string">&#x27;lisi&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法设计</title>
    <url>/p/a8930426.html</url>
    <content><![CDATA[<h3 id="P53习题"><a href="#P53习题" class="headerlink" title="P53习题"></a>P53习题</h3><p><strong>(1)将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两个链表</strong></p>
<p>  <strong>的存储空间，不另外占用其他的存储空间。表中不允许有重复的数据。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType  data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//下一个节点地址</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line">LinkList pa, pb, pc, q, r, t;</span><br><span class="line">LinkList La, Lb, Lc; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IintList</span> <span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	L = <span class="keyword">new</span> LNode;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span></span>&#123; <span class="comment">// 合并链表La和Lb，合并后的新表使用头指针Lc指向 </span></span><br><span class="line">	pa=La-&gt;next;</span><br><span class="line">	pb=Lb-&gt;next;<span class="comment">//pa和pb分别是链表La和Lb的工作指针，初始化为相应链表的第一个结点</span></span><br><span class="line">	</span><br><span class="line">	Lc = pc =La; <span class="comment">//用La的头结点作为Lc的头结点</span></span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line">	    <span class="keyword">if</span>(pa-&gt;data&lt;pb-&gt;data)&#123;</span><br><span class="line">	        pc-&gt;next=pa;</span><br><span class="line">	        pc=pa;</span><br><span class="line">	        pa=pa-&gt;next;</span><br><span class="line">	    &#125;	<span class="comment">//取较小者La中的元素，将pa链接在pc的后面，pa的指针后移</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pa-&gt;data&gt;pb-&gt;data)&#123;</span><br><span class="line">			pc-&gt;next=pb;</span><br><span class="line">	        pc=pb;</span><br><span class="line">	        pb=pb-&gt;next;</span><br><span class="line">		&#125;   <span class="comment">//取较小者Lb中的元素，将pb链接在pc的后面，pb的指针后移</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">	        pc-&gt;next = pa;</span><br><span class="line">			pc = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">			q = pb-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> pb;</span><br><span class="line">			pb = q;   </span><br><span class="line">		&#125;	<span class="comment">//相等时取La中的元素，删除Lb中的元素 </span></span><br><span class="line">	&#125;</span><br><span class="line">   pc-&gt;next = pa ? pa : pb;  </span><br><span class="line">   <span class="keyword">delete</span> Lb;          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, n;</span><br><span class="line">	<span class="built_in">IintList</span>(La); </span><br><span class="line">	<span class="built_in">IintList</span>(Lb);</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入La表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="comment">// 尾插法</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向La顺序表赋值：&quot;</span>);</span><br><span class="line">	r = La;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">		pa = <span class="keyword">new</span> LNode; </span><br><span class="line">		cin&gt;&gt;pa-&gt;data;</span><br><span class="line"></span><br><span class="line">		pa-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next = pa;</span><br><span class="line">        r = pa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;La的数据为: &quot;</span>);</span><br><span class="line">	<span class="comment">//链表遍历 </span></span><br><span class="line">	pa = La-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pa)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pa-&gt;data);</span><br><span class="line">		pa = pa-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n输入Lb表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="comment">// 尾插法</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向Lb顺序表赋值：&quot;</span>);</span><br><span class="line">	r = Lb;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;n; i++)&#123;</span><br><span class="line">		pb = <span class="keyword">new</span> LNode;  </span><br><span class="line">		cin&gt;&gt;pb-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pb;</span><br><span class="line">		r = pb;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Lb的数据为：&quot;</span>);</span><br><span class="line">	<span class="comment">//链表遍历</span></span><br><span class="line">	pb = Lb-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pb)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pb-&gt;data);</span><br><span class="line">		pb = pb-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">MergeList</span>(La, Lb, Lc);</span><br><span class="line">	<span class="comment">//链表遍历</span></span><br><span class="line">	t = La-&gt;next;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;合并后链表为：&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;data);</span><br><span class="line">		t = t-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)将两个非递减的有序链表合并为一个非递增的有序链表。要求结果链表仍使用原来两个链表的存储空间,不另外占用其他的存储空间。表中允许有重复的数据。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span>	<span class="comment">//下一个节点地址</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line">LinkList pa, pb, pc, q, r, t;</span><br><span class="line">LinkList La, Lb, Lc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IintList</span> <span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	L = <span class="keyword">new</span> LNode;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span></span>&#123; <span class="comment">//合并链表La和Lb，合并后的新表使用头指针Lc指向</span></span><br><span class="line">    pa=La-&gt;next;</span><br><span class="line">    pb=Lb-&gt;next; <span class="comment">//pa和pb分别是链表La和Lb的工作指针，初始化为相应链表的第一个结点</span></span><br><span class="line">    </span><br><span class="line">    Lc = pc =La; <span class="comment">//用La的头结点作为Lc的头结点</span></span><br><span class="line">    Lc-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(pa || pb)&#123;<span class="comment">//只要存在一个非空表，用q指向待摘取的元素 </span></span><br><span class="line">    	<span class="keyword">if</span>(!pa)&#123;</span><br><span class="line">    		q = pb;</span><br><span class="line">    		pb = pb-&gt;next;</span><br><span class="line">		&#125; <span class="comment">//La表为空，用q指向pb，pb指针后移</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!pb)&#123;</span><br><span class="line">			q = pb;</span><br><span class="line">			pa = pa-&gt;next; </span><br><span class="line">		&#125; <span class="comment">//Lb表为空，用q指向pa，pa指针后移</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pa-&gt;data&lt;=pb-&gt;data)&#123;</span><br><span class="line">			q = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">		&#125; <span class="comment">//取较小者（包括等于）La中的元素，用q指向pa，pa指针后移 </span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">	        q = pb;</span><br><span class="line">			pb = pb-&gt;next;</span><br><span class="line">		&#125; <span class="comment">//取较小者Lb中的元素，用q指向pb，pb指针后移 </span></span><br><span class="line">		q-&gt;next = Lc-&gt;next;</span><br><span class="line">		Lc-&gt;next = q; <span class="comment">//将q指向的结点插在Lc表的表头结点之后 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> Lb; <span class="comment">//释放Lb的头结点 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line">	<span class="built_in">IintList</span>(La); </span><br><span class="line">	<span class="built_in">IintList</span>(Lb);</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入La表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向La顺序表赋值：&quot;</span>);</span><br><span class="line">	<span class="comment">//尾插法 </span></span><br><span class="line">	r = La; </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">		pa = <span class="keyword">new</span> LNode; </span><br><span class="line">		cin&gt;&gt;pa-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pa-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pa;</span><br><span class="line">		r = pa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;La的数据为: &quot;</span>);</span><br><span class="line">	<span class="comment">//链表La遍历 </span></span><br><span class="line">	pa = La-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pa)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pa-&gt;data);</span><br><span class="line">		pa = pa-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n输入Lb表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向Lb顺序表赋值：&quot;</span>);</span><br><span class="line">	<span class="comment">//尾插法</span></span><br><span class="line">	r = Lb; </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;n; i++)&#123;</span><br><span class="line">		pb = <span class="keyword">new</span> LNode;  </span><br><span class="line">		cin&gt;&gt;pb-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pb;</span><br><span class="line">		r = pb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Lb的数据为：&quot;</span>);</span><br><span class="line">	<span class="comment">//链表Lb的遍历 </span></span><br><span class="line">	pb = Lb-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pb)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pb-&gt;data);</span><br><span class="line">		pb = pb-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">MergeList</span>(La, Lb, Lc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;合并后链表为：&quot;</span>);</span><br><span class="line">	<span class="comment">//链表遍历</span></span><br><span class="line">	t = La-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;data);</span><br><span class="line">		t = t-&gt;next;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(3)已知两个链表A和B分别表示两个集合，其元素递增排列。 请设计一个算法，用于求出A与B的交集，并存放在A链表中。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType  data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//下一个节点地址</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line">LinkList pa, pb, pc, u, r, t;</span><br><span class="line">LinkList La, Lb, Lc; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IintList</span> <span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	L = <span class="keyword">new</span> LNode;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mix</span><span class="params">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span></span>&#123;</span><br><span class="line">    pa = La-&gt;next;</span><br><span class="line">    pb = Lb-&gt;next;	<span class="comment">//pa和pb分别是链表La和Lb的工作指针，初始化为相应链表的第一个结点</span></span><br><span class="line">    </span><br><span class="line">    Lc = pc =La; <span class="comment">//用La的头结点作为Lc的头结点</span></span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(pa-&gt;data == pb-&gt;data)&#123;	<span class="comment">//交集并入结果表中 </span></span><br><span class="line">    		pc-&gt;next = pa;</span><br><span class="line">			pc = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">			u = pb;</span><br><span class="line">			pb = pb-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> u; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pa-&gt;data&lt;pb-&gt;data)&#123;</span><br><span class="line">			u = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> u;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			u = pb;</span><br><span class="line">			pb = pb-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> u;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(pa)&#123;</span><br><span class="line">		u = pa;</span><br><span class="line">		pa = pa-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> u;</span><br><span class="line">	&#125; <span class="comment">//释放结点空间 </span></span><br><span class="line">	<span class="keyword">while</span>(pb)&#123;</span><br><span class="line">		u = pb;</span><br><span class="line">		pb = pb-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> u;</span><br><span class="line">	&#125; <span class="comment">//释放结点空间 </span></span><br><span class="line">	pc-&gt;next = <span class="literal">NULL</span>; <span class="comment">//置链表尾标记 </span></span><br><span class="line">	<span class="keyword">delete</span> Lb; <span class="comment">//释放Lb的头结点 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, n;</span><br><span class="line">	<span class="built_in">IintList</span>(La); </span><br><span class="line">	<span class="built_in">IintList</span>(Lb);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入La表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向La顺序表赋值：&quot;</span>);</span><br><span class="line">	<span class="comment">//尾插法</span></span><br><span class="line">    r = La;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">		pa = <span class="keyword">new</span> LNode; </span><br><span class="line">		cin&gt;&gt;pa-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pa-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pa;</span><br><span class="line">		r = pa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;La的数据为: &quot;</span>);</span><br><span class="line">	<span class="comment">//链表La的遍历 </span></span><br><span class="line">	pa = La-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pa)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,pa-&gt;data);</span><br><span class="line">		pa = pa-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n输入Lb表的长度n: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;向Lb顺序表赋值：&quot;</span>);</span><br><span class="line">	<span class="comment">//尾插法 </span></span><br><span class="line">	r = Lb;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;n; i++)&#123;</span><br><span class="line">		pb = <span class="keyword">new</span> LNode;  </span><br><span class="line">		cin&gt;&gt;pb-&gt;data;</span><br><span class="line">		</span><br><span class="line">		pb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = pb;</span><br><span class="line">		r = pb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Lb的数据为：&quot;</span>);</span><br><span class="line">	<span class="comment">//链表Lb的遍历 </span></span><br><span class="line">	pb = Lb-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pb)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pb-&gt;data);</span><br><span class="line">		pb = pb-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Mix</span>(La,Lb,Lc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n合并后链表为：&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	t = La-&gt;next;	</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;data);</span><br><span class="line">		t = t-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="P85习题"><a href="#P85习题" class="headerlink" title="P85习题"></a>P85习题</h3><p><strong>(2)回文是指正读反读均相同的字符序列，如：“abba ”和 “abdba ” 均是回文，但“good ” 不是回文。<br>  试写一个算法判定给定的字符序列是否为回文。（提示：将一半字符入栈）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;String.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个栈 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *base;</span><br><span class="line">	<span class="keyword">char</span> *top;</span><br><span class="line">	<span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化栈 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">	S.base=<span class="keyword">new</span> <span class="keyword">char</span>[MAX];</span><br><span class="line">	<span class="keyword">if</span>(!S.base)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	S.top=S.base;</span><br><span class="line">	S.stacksize=MAX;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==S.base)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//栈空 </span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈非空 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断栈是否满</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top-S.base==S.stacksize)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//栈满 </span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈空 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,<span class="keyword">char</span> e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsFull</span>(S))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈满，无法入栈 </span></span><br><span class="line">	&#125;</span><br><span class="line">	*S.top++=e;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,<span class="keyword">char</span> &amp;e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsEmpty</span>(S))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈空，无法出栈 </span></span><br><span class="line">	&#125;</span><br><span class="line">	e=*--S.top;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsHuiWen2</span><span class="params">(SqStack &amp;S,<span class="keyword">char</span> str[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">int</span> m=len/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="built_in">Push</span>(S,str[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(S))&#123;</span><br><span class="line">			<span class="keyword">char</span> e;</span><br><span class="line">			<span class="built_in">Pop</span>(S,e);</span><br><span class="line">			temp=e;</span><br><span class="line">			<span class="keyword">if</span>(temp!=str[i])&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(len%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">		i=i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(S))&#123;</span><br><span class="line">			<span class="keyword">char</span> e;</span><br><span class="line">			<span class="built_in">Pop</span>(S,e);</span><br><span class="line">			temp=e;</span><br><span class="line">			<span class="keyword">if</span>(temp!=str[i])&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	SqStack S;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">InitStack</span>(S))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;初始化成功!\n&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;初始化失败!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入字符串:&quot;</span>);</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsHuiWen2</span>(S,str))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;是回文串!\n&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;不是回文串!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**(3)设从键盘输入一整数的序列：a1,a2,a3,…an,试编写算法实现：<br>   用栈结构存储输入的整数，当ai≠-1时，将ai进栈；当ai=-1时，输入栈顶整数并出栈。<br>   算法应对异常情况（入栈满等）给出相应的信息。 **</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TRUE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> FALSE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STACK_MAXSIZE = <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *base;</span><br><span class="line">    <span class="keyword">int</span> *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_Stack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base=<span class="keyword">new</span> <span class="keyword">int</span> [STACK_MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!S.base) <span class="keyword">return</span>;</span><br><span class="line">    S.top=S.base;</span><br><span class="line">    S.stacksize=STACK_MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Push_Stack</span><span class="params">(SqStack &amp;s, <span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.top - s.base == s.stacksize)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;\nerror:栈满&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		*s.top = e;</span><br><span class="line">		s.top ++;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">Pop_Stack</span><span class="params">(SqStack &amp;s, <span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.top == s.base)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;\n栈空，无法执行出栈操作&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		s.top--;</span><br><span class="line">		e = *s.top;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Page85.2.(3)</span></span><br><span class="line">	<span class="keyword">int</span> input_num, pop_num;</span><br><span class="line">	SqStack s;</span><br><span class="line"> </span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;\n输入整数序列：&quot;</span>;</span><br><span class="line">	<span class="built_in">Init_Stack</span>(s);</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;input_num;</span><br><span class="line">		<span class="keyword">if</span>(input_num == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">Pop_Stack</span>(s, pop_num))</span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;pop_num;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Push_Stack</span>(s, input_num);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(s.top - s.base &lt;= s.stacksize);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;PAUSE&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P109习题"><a href="#P109习题" class="headerlink" title="P109习题"></a>P109习题</h3><p><strong>(1)写一个算法统计在输入字符串中各个不同字符出现的频度并将结果存入文件（字符串中的合法字符串为A~Z这26个字母和0 ~ 9这10个数字)。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">charCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,digit_num[<span class="number">10</span>],cap_num[<span class="number">26</span>];</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">		digit_num[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">26</span>; j++)</span><br><span class="line">		cap_num[j]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((ch = <span class="built_in">getchar</span>())!= <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span>(ch)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>..<span class="number">.&#x27;</span>Z<span class="number">&#x27;</span>:</span><br><span class="line">				j=ch<span class="number">-65</span>;</span><br><span class="line">				cap_num[j]++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>..<span class="number">.&#x27;9&#x27;</span>:</span><br><span class="line">				i=ch<span class="number">-48</span>;</span><br><span class="line">				digit_num[i]++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请输入合法字符（A~Z或0~9）！&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fp = <span class="built_in">fopen</span>(<span class="string">&quot;charCount.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;数字 %d 的个数为 %d ;\n&quot;</span>,i,digit_num[i]);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fprintf</span>(fp,<span class="string">&quot;数字 %d 的个数为 %d ;\n&quot;</span>,i,digit_num[i]) ==<span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;ERROR:结果写入文件charCount.txt失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">26</span>; j++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;字母 %c 的个数为 %d ;\n&quot;</span>,j+<span class="number">65</span>,cap_num[j]);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fprintf</span>(fp,<span class="string">&quot;字母 %c 的个数为 %d ;\n&quot;</span>,j+<span class="number">65</span>,cap_num[j]) == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;ERROR:结果写入文件charCount.txt失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n已将字符频度统计结果写入文件charCount.txt\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入一字符串，以#号结束输入：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">charCount</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）写一个递归算法来实现字符串逆序存储，要求不另设串存储空间</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">(<span class="keyword">char</span> A[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//利用静态变量存储数组下标</span></span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">invert</span>(A);</span><br><span class="line">        A[i++]=ch;<span class="comment">//先存的放到后边</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> A[<span class="number">100</span>];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入一个字符串（以‘#’为结束标志，不包括‘#’）&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">invert</span>(A);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;逆置后为：&quot;</span>&lt;&lt;A;<span class="comment">//char型数组可以利用数组名直接输出，int型则会输出其首地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P147习题"><a href="#P147习题" class="headerlink" title="P147习题"></a>P147习题</h3><p><strong>（1）统计二叉树的叶结点个数。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历顺序建立二叉树为：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreatBiTree</span>(T);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;中序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;后序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PostOrderTraverse</span>(T);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;该二叉树叶子结点个数为：&quot;</span>&lt;&lt;<span class="built_in">LeafCount</span>(T)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序建立二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历:若结点不为空就输出，遍历左子树，然后遍历右子树；</span></span><br><span class="line"><span class="comment">//若为空就不输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历:若结点不为空就遍历左子树，输出根结点数据，再遍历右子树；</span></span><br><span class="line"><span class="comment">//为空就不输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历:若结点不为空就遍历左子树，然后遍历右子树，输出根结点数据；</span></span><br><span class="line"><span class="comment">//若为空就不输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//叶子结点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; T-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LeafCount</span>(T-&gt;lchild)+<span class="built_in">LeafCount</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)判断两棵树是否相等</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitBiTree</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEqual</span><span class="params">(BiTree T1,BiTree T2)</span></span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiTree T1,T2;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历顺序建立二叉树T1为：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreatBiTree</span>(T1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;T1先序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T1);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历顺序建立二叉树T2为：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreatBiTree</span>(T2);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;T2先序遍历输出为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T2);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsEqual</span>(T1,T2))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;T1和T2相等&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">IsEqual</span>(T1,T2))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;T1和T2不相等&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序建立二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span> &amp;&amp; ch!=<span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序遍历:若结点不为空就输出，遍历左子树，然后遍历右子树；</span></span><br><span class="line"><span class="comment">//         若为空就不输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两棵树是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEqual</span><span class="params">(BiTree T1,BiTree T2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((T1==<span class="literal">NULL</span>) &amp;&amp; (T1==<span class="literal">NULL</span>))&#123;<span class="comment">//根结点都为空相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((T1==<span class="literal">NULL</span>)!=(T1==<span class="literal">NULL</span>))&#123;<span class="comment">//根结点一个为空，</span></span><br><span class="line">                                    <span class="comment">//一个不为空不相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(T1-&gt;data!=T2-&gt;data)&#123;<span class="comment">//根结点数据不等就不相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结点不空有数据</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">IsEqual</span>(T1-&gt;lchild,T2-&gt;lchild)</span><br><span class="line">            &amp;&amp; <span class="built_in">IsEqual</span>(T1-&gt;rchild,T2-&gt;rchild));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(6)用按层次顺序遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义结点 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">ElemType</span>;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MAX];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序建立二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span> &amp;&amp; ch!=<span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化循环队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front = Q.rear=<span class="number">0</span>;<span class="comment">//队头和队尾相等即为空队列 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进队 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,BiTree bt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>) % MAX == Q.front)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队列满了无法入队&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear = (Q.rear+<span class="number">1</span>) % MAX;</span><br><span class="line">		Q.data[Q.rear] = bt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队 </span></span><br><span class="line"><span class="function">BiTree <span class="title">OutQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    BiTree bt;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队列空了无法出队&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.front = (Q.front+<span class="number">1</span>) % MAX;</span><br><span class="line">        bt = Q.data[Q.front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断空队 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EmptyQueue</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front==Q.rear);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次顺序遍历:先进先出符合队列，先让第一层结点入队，然后依次入队；</span></span><br><span class="line"><span class="comment">//依次出队就为层次顺序遍历</span></span><br><span class="line"><span class="comment">//度为1的结点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Level</span><span class="params">(BiTree bt)</span></span>&#123;</span><br><span class="line">	BiTree p;</span><br><span class="line">	SqQueue Q;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(bt)&#123;</span><br><span class="line">		<span class="built_in">InitQueue</span>(Q);</span><br><span class="line">		<span class="built_in">EnQueue</span>(Q, bt);</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">EmptyQueue</span>(Q))&#123;</span><br><span class="line">			p=<span class="built_in">OutQueue</span>(Q);</span><br><span class="line">			cout&lt;&lt;p-&gt;data;</span><br><span class="line">			<span class="keyword">if</span>((p-&gt;lchild &amp;&amp; !p-&gt;rchild) ||(!p-&gt;lchild &amp;&amp; p-&gt;rchild))&#123;</span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;lchild)&#123;</span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,p-&gt;lchild);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild)&#123;</span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,p-&gt;rchild);</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历顺序建立二叉树为：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreatBiTree</span>(T);</span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;层次遍历后,度为1的结点个数为：&quot;</span>&lt;&lt;<span class="built_in">Level</span>(T)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
